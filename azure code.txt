trigger:
  branches:
    include:
      - develop

pool:
  vmImage: 'windows-latest'

variables:
  group: powerbi # Ensure this variable group contains clientid, clientsecret, and tenantid
  SOURCE_WORKSPACE_ID: "c017440f-4a5b-46bd-a2c0-93ee3f04ab4d"
  TARGET_WORKSPACE_ID: "a4628c7b-adda-4285-8c1f-758b19162d0b"
  MODULE_LIST: |
    MicrosoftPowerBIMgmt
    Invoke-DQVTesting
    Invoke-SemanticModelRefresh

steps:
# Step 1: Checkout Repository
- checkout: self
  displayName: 'Checkout Repository'

# Step 2: Install Dependencies Dynamically
- task: PowerShell@2
  displayName: 'Install Required Modules'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Installing dependencies dynamically..."

      # Include Az.Accounts module in the list
      $modules = @(
        "Az.Accounts"
        "MicrosoftPowerBIMgmt"
        "Invoke-DQVTesting"
        "Invoke-SemanticModelRefresh"
      )
      
      # Loop through the modules and install if missing
      foreach ($module in $modules) {
        Write-Host "Checking module: $module"
        if (-not (Get-Module -ListAvailable -Name $module)) {
          Write-Host "Installing module: $module"
          Install-Module -Name $module -Scope CurrentUser -Force -ErrorAction Stop
        } else {
          Write-Host "Module $module is already installed."
        }
      }
# Step 3: Authenticate with Azure and Power BI Service
- task: PowerShell@2
  displayName: 'Authenticate with Azure and Power BI Service'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Authenticating with Azure and Power BI Service..."

      # Setup variables for credentials
      $clientSecret = "${{ variables.Clientsecret }}"
      $clientId = "${{ variables.clinetid }}"
      $tenantId = "${{ variables.tenantid }}"

      # Directly login to Azure
      Write-Host "Logging in to Azure using Service Principal..."
      Connect-AzAccount -ServicePrincipal -TenantId $tenantId -ApplicationId $clientId -CertificateThumbprint $clientSecret -ErrorAction Stop

      Write-Host "Azure authentication successful."

      # Optionally set Fabric Auth Token if required
      Write-Host "Setting Fabric authentication token..."
      Set-FabricAuthToken -servicePrincipalId $clientId `
                          -servicePrincipalSecret $clientSecret `
                          -tenantId $tenantId -reset

      Write-Host "Authentication with Azure and Power BI Service completed successfully!"










# Step 4: Detect Changes in Commit
- task: PowerShell@2
  displayName: 'Detect Changes in Commit'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Detecting changes in the latest commit..."
      $changedFiles = git diff --name-only HEAD~1 HEAD
      Write-Host "Changed files detected:"
      Write-Host $changedFiles

# Step 5: Validate Semantic Models and Reports
- task: PowerShell@2
  displayName: 'Validate Semantic Models and Reports'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Validating Semantic Models and Reports..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel") {
          Write-Host "Running Semantic Model Validation for: $file"
          Invoke-SemanticModelRefresh -ModelPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
        if ($file -match "report") {
          Write-Host "Running Data Quality Validation for: $file"
          Invoke-DQVTesting -ReportPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
      }

# Step 6: Promote Files to UAT
- task: PowerShell@2
  displayName: 'Promote Files to UAT'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Promoting files to UAT..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel" -or $file -match "report") {
          Write-Host "Promoting $file to UAT Workspace..."
          Publish-PowerBIFile -Path $file -SourceWorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }} -TargetWorkspaceId ${{ variables.TARGET_WORKSPACE_ID }}
        }
      }

# Step 7: Log Results
- task: PowerShell@2
  displayName: 'Log Results'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Logging results..."
      # Log timestamp
      Get-Date | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      # Log changes and promotions
      foreach ($file in $changedFiles) {
        $logEntry = "Promoted file: $file"
        $logEntry | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      }
      Write-Host "Logs stored in: $(Pipeline.Workspace)/log.txt"





---------------------------------------------------------------------------



steps:
  - task: PowerShell@2
    displayName: 'Test Variable Values'
    inputs:
      targetType: inline
      script: |
        if (-not $env:clientId) {
          Write-Output "clientId is not set or empty."
        } else {
          Write-Output "clientId is set."
        }

        if (-not $env:clientSecret) {
          Write-Output "clientSecret is not set or empty."
        } else {
          Write-Output "clientSecret is set."
        }

        if (-not $env:tenantId) {
          Write-Output "tenantId is not set or empty."
        } else {
          Write-Output "tenantId is set."
        }


-----------------------------------------------------------------------------


trigger:
  branches:
    include:
      - develop

pool:
  vmImage: 'windows-latest'

variables:
  group: powerbi # Contains Clientsecret, clinetid, and tenentid
  SOURCE_WORKSPACE_ID: "c017440f-4a5b-46bd-a2c0-93ee3f04ab4d"
  TARGET_WORKSPACE_ID: "a4628c7b-adda-4285-8c1f-758b19162d0b"

steps:
- checkout: self
  fetchDepth: 0
  displayName: 'Checkout Repository'

- task: PowerShell@2
  displayName: 'Install and Configure All Required Modules'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      # Force TLS 1.2
      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
      
      Write-Host "Setting up PowerShell Gallery..."
      if (Get-PSRepository -Name "PSGallery") {
          Set-PSRepository -Name "PSGallery" -InstallationPolicy Trusted
      } else {
          Register-PSRepository -Default
          Set-PSRepository -Name "PSGallery" -InstallationPolicy Trusted
      }
      
      # Remove AzureRM if present
      if (Get-Module -ListAvailable -Name AzureRM*) {
          Write-Host "Removing AzureRM modules..."
          Get-Module -ListAvailable -Name AzureRM* | ForEach-Object { 
              try {
                  Uninstall-Module -Name $_.Name -Force -ErrorAction SilentlyContinue
              } catch {
                  Write-Warning "Could not uninstall $_"
              }
          }
      }
      
      Write-Host "Installing required modules..."
      $modules = @(
          @{Name = "Az.Accounts"; AllowPrerelease = $false},
          @{Name = "MicrosoftPowerBIMgmt"; AllowPrerelease = $false},
          @{Name = "Invoke-DQVTesting"; AllowPrerelease = $true},
          @{Name = "Invoke-SemanticModelRefresh"; AllowPrerelease = $true}
      )
      
      foreach ($module in $modules) {
          try {
              if (-not (Get-Module -ListAvailable -Name $module.Name)) {
                  Write-Host "Installing $($module.Name)..."
                  Install-Module -Name $module.Name `
                               -Force `
                               -AllowClobber `
                               -Scope CurrentUser `
                               -Repository PSGallery `
                               -AllowPrerelease:$module.AllowPrerelease `
                               -ErrorAction Stop
                  Write-Host "$($module.Name) installed successfully"
              } else {
                  Write-Host "$($module.Name) is already installed"
              }
          } catch {
              Write-Error "Failed to install $($module.Name): $_"
              throw
          }
      }
      
      # Create directory for custom modules
      Write-Host "Setting up custom modules directory..."
      $customModulePath = ".\.nuget\custom_modules"
      New-Item -Path $customModulePath -ItemType Directory -Force
      
      # Download and set up FabricPS-PBIP module
      $fabricPsUrls = @(
          "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
          "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
      )
      
      foreach ($url in $fabricPsUrls) {
          $fileName = Split-Path $url -Leaf
          $outputPath = Join-Path $customModulePath $fileName
          Invoke-WebRequest -Uri $url -OutFile $outputPath
      }

- task: PowerShell@2
  displayName: 'Authenticate and Process Changes'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Starting Authentication Process..."
      
      try {
          # Import required modules
          Import-Module Az.Accounts
          Import-Module MicrosoftPowerBIMgmt
          Import-Module Invoke-DQVTesting
          Import-Module Invoke-SemanticModelRefresh
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
          
          Write-Host "Getting credentials from environment..."
          # Get credentials from variables and create SecureString
          $securePassword = ConvertTo-SecureString -String $env:CLIENTSECRET -AsPlainText -Force
          
          # Create PSCredential object
          $credential = New-Object System.Management.Automation.PSCredential($env:CLIENTID, $securePassword)
          
          Write-Host "Connecting to Azure..."
          # Connect to Azure
          Connect-AzAccount -ServicePrincipal `
                          -Credential $credential `
                          -TenantId $env:TENANTID
          
          Write-Host "Connecting to Power BI..."
          # Connect to Power BI
          Connect-PowerBIServiceAccount -ServicePrincipal `
                                      -Credential $credential `
                                      -TenantId $env:TENANTID
          
          # Set Fabric auth token
          Write-Host "Setting Fabric authentication token..."
          Set-FabricAuthToken -servicePrincipalId $env:CLIENTID `
                             -servicePrincipalSecret $env:CLIENTSECRET `
                             -tenantId $env:TENANTID `
                             -reset
          
          Write-Host "Successfully authenticated with all services"
          
          # Identify Changes For Promotion
          Write-Host "Detecting changes..."
          $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Dataset/**/*.SemanticModel/**')
          $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Report/**')
          
          # Remove duplicates
          $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
          $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique
          
          # Handle Semantic Models
          foreach ($change in $pbipDSChanges) {
              Write-Host "Processing semantic model change: $change"
              try {
                  # Get parent folder containing .pbism file
                  $parentFolder = Split-Path $change -Parent
                  while ($null -ne $parentFolder -and !(Test-Path (Join-Path $parentFolder "*.pbism"))) {
                      $parentFolder = Split-Path $parentFolder -Parent
                  }
                  
                  if ($parentFolder) {
                      Write-Host "Promoting semantic model from: $parentFolder"
                      $item = Import-FabricItem -workspaceId $env:SOURCE_WORKSPACE_ID -path $parentFolder
                      
                      if ($item) {
                          Write-Host "Successfully deployed semantic model to source workspace"
                          
                          # Validate the semantic model
                          Write-Host "Validating semantic model..."
                          Invoke-SemanticModelRefresh -ModelPath $change `
                                                    -WorkspaceId $env:SOURCE_WORKSPACE_ID `
                                                    -Credential $credential `
                                                    -TenantId $env:TENANTID
                                                    
                          Write-Host "Semantic model validated successfully"
                          
                          # Copy to UAT workspace if validation successful
                          Import-FabricItem -workspaceId $env:TARGET_WORKSPACE_ID -path $parentFolder
                          Write-Host "Copied semantic model to UAT workspace"
                      }
                  }
              }
              catch {
                  Write-Error "Failed to process semantic model $change : $_"
                  throw
              }
          }
          
          # Handle Reports
          foreach ($change in $pbipRPTChanges) {
              Write-Host "Processing report change: $change"
              try {
                  # Get parent folder containing .pbir file
                  $parentFolder = Split-Path $change -Parent
                  while ($null -ne $parentFolder -and !(Test-Path (Join-Path $parentFolder "*.pbir"))) {
                      $parentFolder = Split-Path $parentFolder -Parent
                  }
                  
                  if ($parentFolder) {
                      Write-Host "Promoting report from: $parentFolder"
                      
                      # Get report definition
                      $def = Get-ChildItem -Path $parentFolder -Recurse -Include "definition.pbir"
                      $semanticModelPath = (Get-Content $def.FullName | ConvertFrom-Json).datasetReference.byPath
                      
                      if ($semanticModelPath) {
                          $pathToCheck = Join-Path $parentFolder $semanticModelPath.path
                          $metadataSM = Get-ChildItem -Path $pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                              Where-Object { (Split-Path -Path $_.FullName).EndsWith(".Dataset") -or 
                                          (Split-Path -Path $_.FullName).EndsWith(".SemanticModel") }
                          
                          if ($metadataSM) {
                              $content = Get-Content $metadataSM.FullName | ConvertFrom-Json
                              $semanticModelName = if ($metadataSM.Name -eq "item.metadata.json") {
                                  $content.displayName
                              } else {
                                  $content.metadata.displayName
                              }
                              
                              # Get semantic model ID from workspace
                              $items = Invoke-FabricAPIRequest -Uri "workspaces/$env:SOURCE_WORKSPACE_ID/items" -Method Get
                              $semanticModel = $items | Where-Object { 
                                  $_.type -eq "SemanticModel" -and $_.displayName -eq $semanticModelName 
                              }
                              
                              if ($semanticModel) {
                                  # Deploy to source workspace
                                  Write-Host "Deploying report to source workspace..."
                                  $sourceItem = Import-FabricItem -workspaceId $env:SOURCE_WORKSPACE_ID `
                                                                -path $parentFolder `
                                                                -itemProperties @{ 
                                                                    semanticmodelId = $semanticModel.id 
                                                                }
                                  
                                  # Run DQV Testing
                                  Write-Host "Running Data Quality Validation..."
                                  Invoke-DQVTesting -ReportPath $change `
                                                  -WorkspaceId $env:SOURCE_WORKSPACE_ID `
                                                  -Credential $credential `
                                                  -TenantId $env:TENANTID
                                  
                                  # Deploy to UAT workspace
                                  Write-Host "Deploying report to UAT workspace..."
                                  Import-FabricItem -workspaceId $env:TARGET_WORKSPACE_ID `
                                                  -path $parentFolder `
                                                  -itemProperties @{ 
                                                      semanticmodelId = $semanticModel.id 
                                                  }
                                  
                                  Write-Host "Successfully deployed report to both workspaces"
                              }
                          }
                      }
                  }
              }
              catch {
                  Write-Error "Failed to process report $change : $_"
                  throw
              }
          }
          
          Write-Host "All changes processed successfully"
          
      } catch {
          Write-Error "Process failed: $_"
          throw
      }
  env:
    CLIENTSECRET: $(Clientsecret)
    CLIENTID: $(clinetid)
    TENANTID: $(tenentid)
    SOURCE_WORKSPACE_ID: $(SOURCE_WORKSPACE_ID)
    TARGET_WORKSPACE_ID: $(TARGET_WORKSPACE_ID)

- task: PowerShell@2
  displayName: 'Log Results'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
      $logEntry = "Deployment completed at $timestamp"
      Write-Host $logEntry
      $logEntry | Out-File -FilePath "$(Build.ArtifactStagingDirectory)/deployment.log" -Append
