trigger:
  branches:
    include:
      - develop

pool:
  vmImage: 'windows-latest'

variables:
  group: powerbi # Ensure this variable group contains clientid, clientsecret, and tenantid
  SOURCE_WORKSPACE_ID: "c017440f-4a5b-46bd-a2c0-93ee3f04ab4d"
  TARGET_WORKSPACE_ID: "a4628c7b-adda-4285-8c1f-758b19162d0b"
  MODULE_LIST: |
    MicrosoftPowerBIMgmt
    Invoke-DQVTesting
    Invoke-SemanticModelRefresh

steps:
# Step 1: Checkout Repository
- checkout: self
  displayName: 'Checkout Repository'

# Step 2: Install Dependencies Dynamically
- task: PowerShell@2
  displayName: 'Install Required Modules'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Installing dependencies dynamically..."
      
      # Convert the MODULE_LIST into an array
      $modules = @(
        "MicrosoftPowerBIMgmt"
        "Invoke-DQVTesting"
        "Invoke-SemanticModelRefresh"
      )
      
      # Loop through the modules and install if missing
      foreach ($module in $modules) {
        Write-Host "Checking module: $module"
        if (-not (Get-Module -ListAvailable -Name $module)) {
          Write-Host "Installing module: $module"
          Install-Module -Name $module -Scope CurrentUser -Force -ErrorAction Stop
        } else {
          Write-Host "Module $module is already installed."
        }
      }


- task: PowerShell@2
  displayName: 'Authenticate with Power BI Service'
  inputs:
    targetType: 'inline'
    pwsh: true
    script: |
      try {
          Write-Host "Starting Power BI Service Authentication..."
          
          # Import Power BI Module explicitly without verbose output
          Import-Module MicrosoftPowerBIMgmt -ErrorAction Stop
          
          # Debug variables (will not show actual values)
          Write-Host "Checking if variables are accessible..."
          
          # Explicitly convert and check variables before use
          $clientSecretValue = [string]$($variables.Clientsecret)
          $clientIdValue = [string]$($variables.clinetid)
          $tenantIdValue = [string]$($variables.tenantid)
          
          # Validate variables
          if ([string]::IsNullOrWhiteSpace($clientSecretValue)) {
              throw "Client Secret is not properly accessed. Check variable configuration."
          }
          
          if ([string]::IsNullOrWhiteSpace($clientIdValue)) {
              throw "Client ID is not properly accessed. Check variable configuration."
          }
          
          if ([string]::IsNullOrWhiteSpace($tenantIdValue)) {
              throw "Tenant ID is not properly accessed. Check variable configuration."
          }
          
          Write-Host "Variables validated successfully."
          
          # Create secure string with explicit string conversion
          $secureSecret = ConvertTo-SecureString -String $clientSecretValue -AsPlainText -Force
          
          # Create credential object with explicit string values
          $credential = New-Object System.Management.Automation.PSCredential `
              -ArgumentList $clientIdValue, $secureSecret
          
          # Connect to Power BI
          Write-Host "Attempting to connect to Power BI Service..."
          Connect-PowerBIServiceAccount -ServicePrincipal `
              -TenantId $tenantIdValue `
              -Credential $credential `
              -ErrorAction Stop
              
          Write-Host "Successfully authenticated with Power BI Service."
          
      } catch {
          $errorMessage = $_.Exception.Message
          Write-Error "Authentication Error: $errorMessage"
          throw
      } finally {
          # Clear sensitive variables
          if ($null -ne $secureSecret) { $secureSecret.Dispose() }
          if ($null -ne $credential) { $credential = $null }
          if ($null -ne $clientSecretValue) { $clientSecretValue = $null }
          [System.GC]::Collect()
      }




# Step 4: Detect Changes in Commit
- task: PowerShell@2
  displayName: 'Detect Changes in Commit'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Detecting changes in the latest commit..."
      $changedFiles = git diff --name-only HEAD~1 HEAD
      Write-Host "Changed files detected:"
      Write-Host $changedFiles

# Step 5: Validate Semantic Models and Reports
- task: PowerShell@2
  displayName: 'Validate Semantic Models and Reports'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Validating Semantic Models and Reports..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel") {
          Write-Host "Running Semantic Model Validation for: $file"
          Invoke-SemanticModelRefresh -ModelPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
        if ($file -match "report") {
          Write-Host "Running Data Quality Validation for: $file"
          Invoke-DQVTesting -ReportPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
      }

# Step 6: Promote Files to UAT
- task: PowerShell@2
  displayName: 'Promote Files to UAT'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Promoting files to UAT..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel" -or $file -match "report") {
          Write-Host "Promoting $file to UAT Workspace..."
          Publish-PowerBIFile -Path $file -SourceWorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }} -TargetWorkspaceId ${{ variables.TARGET_WORKSPACE_ID }}
        }
      }

# Step 7: Log Results
- task: PowerShell@2
  displayName: 'Log Results'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Logging results..."
      # Log timestamp
      Get-Date | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      # Log changes and promotions
      foreach ($file in $changedFiles) {
        $logEntry = "Promoted file: $file"
        $logEntry | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      }
      Write-Host "Logs stored in: $(Pipeline.Workspace)/log.txt"





---------------------------------------------------------------------------



steps:
  - task: PowerShell@2
    displayName: 'Test Variable Values'
    inputs:
      targetType: inline
      script: |
        if (-not $env:clientId) {
          Write-Output "clientId is not set or empty."
        } else {
          Write-Output "clientId is set."
        }

        if (-not $env:clientSecret) {
          Write-Output "clientSecret is not set or empty."
        } else {
          Write-Output "clientSecret is set."
        }

        if (-not $env:tenantId) {
          Write-Output "tenantId is not set or empty."
        } else {
          Write-Output "tenantId is set."
        }




