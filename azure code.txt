
    targetType: inline
    script: |
      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
      Set-PSRepository -Name "PSGallery" -InstallationPolicy Trusted
      Install-Module PowerShellGet -Force -AllowClobber -Scope CurrentUser

- task: PowerShell@2
  displayName: 'Remove AzureRM Module if Loaded and Install Az Module'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      # Remove any AzureRM module that might be loaded in the session
      Get-Module AzureRM* -ListAvailable | Remove-Module -Force -ErrorAction SilentlyContinue

      # Install Az Module explicitly to avoid conflicts
      Install-Module -Name Az.Accounts -Force -AllowClobber -Scope CurrentUser
# Step 2: Install Dependencies Dynamically
- task: PowerShell@2
  displayName: 'Install Required Modules'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Installing dependencies dynamically..."

      # Include Az.Accounts module in the list
      $modules = @(
        "Az.Accounts"
        "MicrosoftPowerBIMgmt"
        "Invoke-DQVTesting"
        "Invoke-SemanticModelRefresh"
      )
      
      # Loop through the modules and install if missing
      foreach ($module in $modules) {
        Write-Host "Checking module: $module"
        if (-not (Get-Module -ListAvailable -Name $module)) {
          Write-Host "Installing module: $module"
          Install-Module -Name $module -Scope CurrentUser -Force -ErrorAction Stop
        } else {
          Write-Host "Module $module is already installed."
        }
      }
# Step 3: Authenticate with Azure and Power BI Service
- task: PowerShell@2
  displayName: 'Authenticate with Azure and Power BI Service'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Authenticating with Azure and Power BI Service..."

      # Setup variables for credentials
      $clientSecret = "${{ variables.Clientsecret }}"
      $clientId = "${{ variables.clinetid }}"
      $tenantId = "${{ variables.tenantid }}"

      # Directly login to Azure
      Write-Host "Logging in to Azure using Service Principal..."
      Connect-AzAccount -ServicePrincipal -TenantId $tenantId -ApplicationId $clientId -CertificateThumbprint $clientSecret -ErrorAction Stop

      Write-Host "Azure authentication successful."

      # Optionally set Fabric Auth Token if required
      Write-Host "Setting Fabric authentication token..."
      Set-FabricAuthToken -servicePrincipalId $clientId `
                          -servicePrincipalSecret $clientSecret `
                          -tenantId $tenantId -reset

      Write-Host "Authentication with Azure and Power BI Service completed successfully!"










# Step 4: Detect Changes in Commit
- task: PowerShell@2
  displayName: 'Detect Changes in Commit'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Detecting changes in the latest commit..."
      $changedFiles = git diff --name-only HEAD~1 HEAD
      Write-Host "Changed files detected:"
      Write-Host $changedFiles

# Step 5: Validate Semantic Models and Reports
- task: PowerShell@2
  displayName: 'Validate Semantic Models and Reports'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Validating Semantic Models and Reports..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel") {
          Write-Host "Running Semantic Model Validation for: $file"
          Invoke-SemanticModelRefresh -ModelPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
        if ($file -match "report") {
          Write-Host "Running Data Quality Validation for: $file"
          Invoke-DQVTesting -ReportPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
      }

# Step 6: Promote Files to UAT
- task: PowerShell@2
  displayName: 'Promote Files to UAT'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Promoting files to UAT..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel" -or $file -match "report") {
          Write-Host "Promoting $file to UAT Workspace..."
          Publish-PowerBIFile -Path $file -SourceWorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }} -TargetWorkspaceId ${{ variables.TARGET_WORKSPACE_ID }}
        }
      }

# Step 7: Log Results
- task: PowerShell@2
  displayName: 'Log Results'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Logging results..."
      # Log timestamp
      Get-Date | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      # Log changes and promotions
      foreach ($file in $changedFiles) {
        $logEntry = "Promoted file: $file"
        $logEntry | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      }
      Write-Host "Logs stored in: $(Pipeline.Workspace)/log.txt"





---------------------------------------------------------------------------



parameters:
  - name: WORKSPACE_NAME
    displayName: "Workspace name to conduct tests?"
    type: string
    default: 'YourWorkspaceName'  # Replace with your default workspace name

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains Clientsecret, clinetid, tenantid
  - name: WORKSPACE_NAME
    value: '${{ parameters.WORKSPACE_NAME }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      - task: PowerShell@2
        displayName: 'Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

      - task: PowerShell@2
        displayName: 'Install Dependencies'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      - task: PowerShell@2
        displayName: 'Deploy Changes and Conduct Testing'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                if (-not ${env:clinetid} -or -not ${env:Clientsecret} -or -not ${env:tenantid}) {
                    Write-Error "Missing one or more required environment variables: clinetid, Clientsecret, tenantid"
                    throw
                }

                $secret = ${env:Clientsecret} | ConvertTo-SecureString -AsPlainText -Force
                $credential = New-Object System.Management.Automation.PSCredential (${env:clinetid}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:tenantid}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
                  [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                )

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                }

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Dataset/**/*.SemanticModel/**')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Report/**')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get workspace Id
                $workspaceObj = Get-FabricWorkspace -workspaceName "${env:WORKSPACE_NAME}"
                $workspaceID = $workspaceObj.Id

                # ----------- Handle Semantic Models For Promotion ----------- #
                # Identify Semantic Models changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipDSChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $smPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $smPathsToPromote = $smPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $smPromotedItems = @()

                # Promote semantic models to workspace
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "##[debug]Promoting semantic model at $($promotePath) to workspace ${env:WORKSPACE_NAME}"
                    $smPromotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath
                    $smPromotedItems += $smPromotedItem
                }

                # ----------- Promote Reports ----------- #
                # Retrieve all items in workspace (after semantic models have been promoted)
                $items = Invoke-FabricAPIRequest -Uri "workspaces/${workspaceID}/items" -Method Get

                # Identify Reports changed
                $rptPathsToPromote = @()
                $filter = "*.pbir"

                foreach ($change in $pbipRPTChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $rptPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $rptPathsToPromote = $rptPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $rptPromotedItems = @()

                Write-Host "##[debug] rptPathsToPromote: $($rptPathsToPromote)"

                # Promote reports to workspace
                foreach ($promotePath in $rptPathsToPromote) {
                    # Get report definition
                    $def = Get-ChildItem -Path $promotePath -Recurse -Include "definition.pbir"
                    $semanticModelPath = (Get-Content $def.FullName | ConvertFrom-Json).datasetReference.byPath

                    Write-Host "##[debug] SemanticModelPath: $($semanticModelPath)"

                    # If byPath was null, we'll assume byConnection is set and skip
                    if ($semanticModelPath -ne $null) {
                        # Semantic Model path is relative to the report path, Join-Path can handle relative paths
                        $pathToCheck = Join-Path $promotePath $semanticModelPath.path
                        $metadataSM = Get-ChildItem -Path $pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                      Where-Object { (Split-Path -Path $_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $_.FullName).EndsWith(".SemanticModel") }

                        if ($metadataSM -ne $null) {
                            $content = Get-Content $metadataSM.FullName | ConvertFrom-Json

                            # Handle item.metadata.json
                            if ($metadataSM.Name -eq "item.metadata.json") {
                                # Prior to March-2024 release
                                $semanticModelName = $content.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            } else {
                                $semanticModelName = $content.metadata.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            }
                        } else {
                            Write-Host "##[error] Semantic Model definition not found in workspace."
                        }
                    }

                    # Get the semantic model id from items in the workspace
                    $semanticModel = $items | Where-Object { $_.type -eq "SemanticModel" -and $_.displayName -eq $semanticModelName }

                    Write-Host "##[debug] semanticModel: $($semanticModel)"

                    if (!$semanticModel) {
                        Write-Host "##[error] Semantic Model not found in workspace."
                    } else {
                        # Import report with appropriate semantic model id
                        Write-Host "##[debug] Promoting report at $($promotePath) to workspace ${env:WORKSPACE_NAME}"
                        $promotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath -itemProperties @{ semanticmodelId = "$($semanticModel.id)" }
                        $rptPromotedItems += $promotedItem
                    }
                }

                # ----------- Run Refreshes and Tests ----------- #

                # Generate Run GUID
                $runGuid = (New-Guid).Guid
                $projectName = $($env:SYSTEM_TEAMPROJECT)
                $repoName = $($env:BUILD_REPOSITORY_NAME)
                $branchName = $($env:BUILD_SOURCEBRANCHNAME)
                $userName = "$($env:BUILD_REQUESTEDFOREMAIL)"
                $buildReason = "$($env:BUILD_REASON)"

                if ($buildReason -eq 'schedule' -or $buildReason -eq 'ScheduleForced') {
                    $userName = "Scheduled - Build-Agent"
                }

                Write-Host "##[debug]Run GUID: $($runGuid)"
                Write-Host "##[debug]Project Name: $($projectName)"
                Write-Host "##[debug]Repository Name: $($repoName)"
                Write-Host "##[debug]Branch Name: $($branchName)"
                Write-Host "##[debug]User Name: $($userName)"

                $idqVersion = (Get-Module -Name "Invoke-DQVTesting" -ListAvailable).Version.toString()
                $testResults = @()

                # Get UTC representation of run
                $dateTimeofRun = (Get-Date -Format "yyyy-MM-ddTHH-mm-ssZ")
                $fileName = "$($dateTimeofRun)-$($runGuid).csv"

                # Run synchronous refresh for each semantic model
                foreach ($promotedItem in $smPromotedItems) {
                    # Test refresh which validates functionality
                    Invoke-SemanticModelRefresh -WorkspaceId $workspaceID `
                        -SemanticModelId $promotedItem.Id `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -Environment Public `
                        -LogOutput "ADO"
                }

                # Run tests for functionality and data accuracy
                foreach ($promotedItem in $smPromotedItems) {
                    $testResults += Invoke-DQVTesting -WorkspaceName "${env:WORKSPACE_NAME}" `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -DatasetId $promotedItem.Id `
                        -LogOutput "Table"
                }

                # Add additional properties to the array of objects
                $i = 0

                $testResults | ForEach-Object {
                    Add-Member -InputObject $_ -Name "BranchName" -Value $branchName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RepositoryName" -Value $repoName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "ProjectName" -Value $projectName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "UserName" -Value $userName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunID" -Value $runGuid -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "Order" -Value $i -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunDateTime" -Value $dateTimeofRun -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "InvokeDQTestingVersion" -Value $idqVersion -MemberType NoteProperty
                    $i++
                }

                $testResults | Select-Object * | Export-Csv -Path ".\$fileName"

                $getAbsPath = (Resolve-Path ".\$fileName").Path

                Write-Host "##[debug] Test Results for $($promotedItem.Id) saved locally to $($getAbsPath)."

                # Output test results
                $testResults | ForEach-Object {
                    $prefix = "##[debug]"
                    switch ($_.LogType) {
                        'Warning' { $prefix = "##vso[task.logissue type=warning]" }
                        'Error' { $prefix = "##vso[task.logissue type=error]" }
                        'Failure' { $prefix = "##vso[task.complete result=Failed;]" }
                        'Success' { $prefix = "##vso[task.complete result=Succeeded;]" }
                    }
                    Write-Host "$($prefix)$($_.Message)"
                }

            } catch {
                Write-Error "Authentication or processing failed: $_"
                throw
            }
        env:
          Clientsecret: $(Clientsecret)
          clinetid: $(clinetid)
          tenantid: $(tenantid)
          WORKSPACE_NAME: $(WORKSPACE_NAME)


--------------------------------------------------------------------------------

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains Clientsecret, clinetid, tenantid
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      - task: PowerShell@2
        displayName: 'Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

      - task: PowerShell@2
        displayName: 'Install Dependencies'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      - task: PowerShell@2
        displayName: 'Deploy Changes and Conduct Testing'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                if (-not ${env:clinetid} -or -not ${env:Clientsecret} -or -not ${env:tenantid}) {
                    Write-Error "Missing one or more required environment variables: clinetid, Clientsecret, tenantid"
                    throw
                }

                $secret = ${env:Clientsecret} | ConvertTo-SecureString -AsPlainText -Force
                $credential = New-Object System.Management.Automation.PSCredential (${env:clinetid}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:tenantid}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
                  [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                )

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                }

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Dataset/**/*.SemanticModel/**')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Report/**')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get Dev and UAT workspace IDs
                $devWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:DEV_WORKSPACE_NAME}"
                $devWorkspaceID = $devWorkspaceObj.Id

                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:UAT_WORKSPACE_NAME}"
                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Identify Semantic Models changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipDSChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $smPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $smPathsToPromote = $smPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $smPromotedItems = @()

                # Promote semantic models to UAT workspace
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "##[debug]Promoting semantic model at $($promotePath) to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                    $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath
                    $smPromotedItems += $smPromotedItem
                }

                # ----------- Retrieve Items in UAT Workspace ----------- #
                $items = Invoke-FabricAPIRequest -Uri "workspaces/${uatWorkspaceID}/items" -Method Get

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Identify Reports changed
                $rptPathsToPromote = @()
                $filter = "*.pbir"

                foreach ($change in $pbipRPTChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $rptPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $rptPathsToPromote = $rptPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $rptPromotedItems = @()

                Write-Host "##[debug] rptPathsToPromote: $($rptPathsToPromote)"

                # Promote reports to UAT workspace
                foreach ($promotePath in $rptPathsToPromote) {
                    # Get report definition
                    $def = Get-ChildItem -Path $promotePath -Recurse -Include "definition.pbir"
                    $semanticModelPath = (Get-Content $def.FullName | ConvertFrom-Json).datasetReference.byPath

                    Write-Host "##[debug] SemanticModelPath: $($semanticModelPath)"

                    # If byPath was null, we'll assume byConnection is set and skip
                    if ($semanticModelPath -ne $null) {
                        # Semantic Model path is relative to the report path, Join-Path can handle relative paths
                        $pathToCheck = Join-Path $promotePath $semanticModelPath.path
                        $metadataSM = Get-ChildItem -Path $pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                      Where-Object { (Split-Path -Path $_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $_.FullName).EndsWith(".SemanticModel") }

                        if ($metadataSM -ne $null) {
                            $content = Get-Content $metadataSM.FullName | ConvertFrom-Json

                            # Handle item.metadata.json
                            if ($metadataSM.Name -eq "item.metadata.json") {
                                # Prior to March-2024 release
                                $semanticModelName = $content.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            } else {
                                $semanticModelName = $content.metadata.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            }
                        } else {
                            Write-Host "##[error] Semantic Model definition not found."
                            continue
                        }
                    }

                    # Get the semantic model id from items in the UAT workspace
                    $semanticModel = $items | Where-Object { $_.type -eq "SemanticModel" -and $_.displayName -eq $semanticModelName }

                    Write-Host "##[debug] semanticModel: $($semanticModel)"

                    if (!$semanticModel) {
                        Write-Host "##[error] Semantic Model not found in UAT workspace."
                        continue
                    } else {
                        # Import report with appropriate semantic model id
                        Write-Host "##[debug] Promoting report at $($promotePath) to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $promotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -itemProperties @{ semanticmodelId = "$($semanticModel.id)" }
                        $rptPromotedItems += $promotedItem
                    }
                }

                # ----------- Run Refreshes and Tests in UAT Workspace ----------- #

                # Generate Run GUID
                $runGuid = (New-Guid).Guid
                $projectName = $($env:SYSTEM_TEAMPROJECT)
                $repoName = $($env:BUILD_REPOSITORY_NAME)
                $branchName = $($env:BUILD_SOURCEBRANCHNAME)
                $userName = "$($env:BUILD_REQUESTEDFOREMAIL)"
                $buildReason = "$($env:BUILD_REASON)"

                if ($buildReason -eq 'schedule' -or $buildReason -eq 'ScheduleForced') {
                    $userName = "Scheduled - Build-Agent"
                }

                Write-Host "##[debug]Run GUID: $($runGuid)"
                Write-Host "##[debug]Project Name: $($projectName)"
                Write-Host "##[debug]Repository Name: $($repoName)"
                Write-Host "##[debug]Branch Name: $($branchName)"
                Write-Host "##[debug]User Name: $($userName)"

                $idqVersion = (Get-Module -Name "Invoke-DQVTesting" -ListAvailable).Version.toString()
                $testResults = @()

                # Get UTC representation of run
                $dateTimeofRun = (Get-Date -Format "yyyy-MM-ddTHH-mm-ssZ")
                $fileName = "$($dateTimeofRun)-$($runGuid).csv"

                # Run synchronous refresh for each semantic model in UAT workspace
                foreach ($promotedItem in $smPromotedItems) {
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID `
                        -SemanticModelId $promotedItem.Id `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -Environment Public `
                        -LogOutput "ADO"
                }

                # Run tests for functionality and data accuracy in UAT workspace
                foreach ($promotedItem in $smPromotedItems) {
                    $testResults += Invoke-DQVTesting -WorkspaceName "${env:UAT_WORKSPACE_NAME}" `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -DatasetId $promotedItem.Id `
                        -LogOutput "Table"
                }

                # Add additional properties to the array of objects
                $i = 0

                $testResults | ForEach-Object {
                    Add-Member -InputObject $_ -Name "BranchName" -Value $branchName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RepositoryName" -Value $repoName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "ProjectName" -Value $projectName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "UserName" -Value $userName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunID" -Value $runGuid -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "Order" -Value $i -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunDateTime" -Value $dateTimeofRun -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "InvokeDQTestingVersion" -Value $idqVersion -MemberType NoteProperty
                    $i++
                }

                $testResults | Select-Object * | Export-Csv -Path ".\$fileName"

                $getAbsPath = (Resolve-Path ".\$fileName").Path

                Write-Host "##[debug] Test Results saved locally to $($getAbsPath)."

                # Output test results
                $testResults | ForEach-Object {
                    $prefix = "##[debug]"
                    switch ($_.LogType) {
                        'Warning' { $prefix = "##vso[task.logissue type=warning]" }
                        'Error' { $prefix = "##vso[task.logissue type=error]" }
                        'Failure' { $prefix = "##vso[task.complete result=Failed;]" }
                        'Success' { $prefix = "##vso[task.complete result=Succeeded;]" }
                    }
                    Write-Host "$($prefix)$($_.Message)"
                }

            } catch {
                Write-Error "Authentication or processing failed: $_"
                throw
            }
        env:
          Clientsecret: $(Clientsecret)
          clinetid: $(clinetid)
          tenantid: $(tenantid)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
______________________________________________________________________________--trigger:
  branches:
    include:
      - develop

variables:
  - group: powerbi  # Contains Clientsecret, clinetid, tenantid

parameters:
  - name: DEV_WORKSPACE_NAME
    type: string
    default: 'Your_Dev_Workspace_Name'
  - name: UAT_WORKSPACE_NAME
    type: string
    default: 'Your_UAT_Workspace_Name'

pool:
  vmImage: 'windows-latest'

steps:
- checkout: self
  fetchDepth: 0
  displayName: 'Checkout Repository'

- task: PowerShell@2
  displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
  inputs:
    targetType: 'inline'
    script: |
      try {
          # ----------- Import PowerShell Modules ----------- #
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
          Import-Module Az.Accounts -Force
          Import-Module MicrosoftPowerBIMgmt -Force

          # ----------- Setup Credentials ----------- #
          if (-not $env:clinetid -or -not $env:Clientsecret -or -not $env:tenantid) {
              Write-Error "Missing one or more required environment variables: clinetid, Clientsecret, tenantid"
              throw
          }

          $tenantId = $env:tenantid.Trim()
          $clientId = $env:clinetid.Trim()
          $clientSecret = $env:Clientsecret.Trim()

          # Optional debugging checks (avoid printing sensitive data)
          if ($tenantId) {
              Write-Host "Tenant ID is set."
          } else {
              Write-Error "Tenant ID is not set."
              throw
          }

          if ($clientId) {
              Write-Host "Client ID is set."
          } else {
              Write-Error "Client ID is not set."
              throw
          }

          if ($clientSecret) {
              Write-Host "Client Secret is set."
          } else {
              Write-Error "Client Secret is not set."
              throw
          }

          # Convert client secret to secure string
          $secureSecret = ConvertTo-SecureString $clientSecret -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential ($clientId, $secureSecret)

          # Check if service principal or username/password
          $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
          $isServicePrincipal = $false

          if ($credential.UserName -match $guidRegex) {
            $isServicePrincipal = $true
          }

          # ----------- Login to Azure and Fabric ----------- #
          $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
            [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
          )

          # Set Fabric Connection
          if ($isServicePrincipal) {
            Set-FabricAuthToken -servicePrincipalId $credential.UserName `
              -servicePrincipalSecret $plainTextPwd `
              -tenantId $tenantId -reset
          } else {
            Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
          }

          # ----------- Connect to Power BI ----------- #
          if ($isServicePrincipal) {
            Connect-PowerBIServiceAccount -ServicePrincipal `
              -Credential $credential `
              -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
          } else {
            Connect-PowerBIServiceAccount -Credential $credential `
              -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
          }

          Write-Host "Authentication successful."

          # ----------- Process Changes ----------- #
          Write-Host "Processing changes..."

          # Get list of files changed in the current commit
          $changedFiles = @(git diff-tree --no-commit-id --name-only -r $env:BUILD_SOURCEVERSION)

          Write-Host "##[debug]Changed files: $($changedFiles)"

          # Identify Semantic Model changes
          $pbipDSChanges = $changedFiles | Where-Object { $_ -like '*.pbism' }

          # Identify Report changes
          $pbipRPTChanges = $changedFiles | Where-Object { $_ -like '*.pbir' }

          $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
          $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

          # Output detected changes for debugging
          Write-Host "##[debug]Detected Semantic Model Changes: $($pbipDSChanges)"
          Write-Host "##[debug]Detected Report Changes: $($pbipRPTChanges)"

          # Detect if no changes
          if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
              Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
              exit 0
          }

          # ----------- Get Workspace IDs ----------- #
          $devWorkspaceName = "$env:DEV_WORKSPACE_NAME".Trim()
          $uatWorkspaceName = "$env:UAT_WORKSPACE_NAME".Trim()

          $devWorkspaceObj = Get-FabricWorkspace -workspaceName $devWorkspaceName
          $uatWorkspaceObj = Get-FabricWorkspace -workspaceName $uatWorkspaceName

          if (-not $devWorkspaceObj) {
              Write-Error "Dev workspace '$devWorkspaceName' not found."
              throw
          }

          if (-not $uatWorkspaceObj) {
              Write-Error "UAT workspace '$uatWorkspaceName' not found."
              throw
          }

          $devWorkspaceID = $devWorkspaceObj.WorkspaceId
          $uatWorkspaceID = $uatWorkspaceObj.WorkspaceId

          # ----------- Promote Changes ----------- #
          # Prepare paths to promote
          $smPathsToPromote = @()
          foreach ($change in $pbipDSChanges) {
              $smPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
          }

          $rptPathsToPromote = @()
          foreach ($change in $pbipRPTChanges) {
              $rptPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
          }

          # Import Semantic Models
          foreach ($promotePath in $smPathsToPromote) {
              try {
                  Write-Host "Promoting semantic model at $promotePath to UAT workspace $uatWorkspaceName"
                  $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
              } catch {
                  Write-Error "Failed to promote semantic model at $promotePath: $_"
                  throw
              }
          }

          # Import Reports
          foreach ($promotePath in $rptPathsToPromote) {
              try {
                  Write-Host "Promoting report at $promotePath to UAT workspace $uatWorkspaceName"
                  $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
              } catch {
                  Write-Error "Failed to promote report at $promotePath: $_"
                  throw
              }
          }

          Write-Host "Promotion of changes to UAT workspace completed successfully."

          # ----------- DQV Testing ----------- #
          Write-Host "Starting Data Quality Validation (DQV) testing..."

          # Assume you have a DQV script or function to execute
          # Replace the following with your actual DQV testing commands

          try {
              # Example DQV Testing Command
              # Replace with your actual DQV testing logic
              Invoke-DQVTest -workspaceId $uatWorkspaceID -Verbose -Debug
              Write-Host "DQV testing completed successfully."
          } catch {
              Write-Error "DQV testing failed: $_"
              throw
          }

          # ----------- Validate Data Refresh ----------- #
          Write-Host "Validating data refresh..."

          try {
              # Example Data Refresh Command
              # Replace with your actual data refresh logic
              Invoke-SemanticModelRefresh -workspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
              Write-Host "Data refresh validated successfully."
          } catch {
              Write-Error "Data refresh validation failed: $_"
              throw
          }

          Write-Host "All steps completed successfully."

      } catch {
          Write-Error "An error occurred: $_"
          throw
      }
  env:
    DEV_WORKSPACE_NAME: ${{ parameters.DEV_WORKSPACE_NAME }}
    UAT_WORKSPACE_NAME: ${{ parameters.UAT_WORKSPACE_NAME }}

--------------------------------------------------------------------------------------

- task: PowerShell@2
  displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
  inputs:
    pwsh: true
    targetType: 'inline'
    script: |
      try {
          # ----------- Import PowerShell Modules ----------- #
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
          Import-Module Az.Accounts -Force
          Import-Module MicrosoftPowerBIMgmt -Force

          # ----------- Setup Credentials ----------- #
          $secret = ${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
          $credential = [System.Management.Automation.PSCredential]::new(${env:CLIENT_ID}, $secret)

          # Check if service principal or username/password
          $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
          $isServicePrincipal = $false

          if ($credential.UserName -match $guidRegex) {
            $isServicePrincipal = $true
          }

          # ----------- Login to Azure and Fabric ----------- #
          $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
          $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

          # Set Fabric Connection
          if ($isServicePrincipal) {
            Set-FabricAuthToken -servicePrincipalId $credential.UserName `
              -servicePrincipalSecret $plainTextPwd `
              -tenantId ${env:TENANT_ID} -reset
          } else {
            Set-FabricAuthToken -credential $credential -tenantId ${env:TENANT_ID} -reset
          }

          # Set AzCopy Connection
          $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
          $oneLakeUri = New-Object System.Uri("${env:ONELAKE_ENDPOINT}")
          $oneLakeDomain = $oneLakeUri.Host

          $loginResult = azcopy login --service-principal `
            --application-id $credential.UserName `
            --tenant-id "${env:TENANT_ID}" `
            --trusted-microsoft-suffixes="${oneLakeDomain}" `
            --output-type json | ConvertFrom-Json

          # Check if login was successful
          $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

          if (!$checkResult) {
            Write-Host "##[error] Failed to login to azcopy"
            throw "AzCopy login failed."
          }

          Write-Host "Authentication successful."

          # ----------- Connect to Power BI ----------- #
          if ($isServicePrincipal) {
            Connect-PowerBIServiceAccount -ServicePrincipal `
              -Credential $credential `
              -TenantId ${env:TENANT_ID} -ErrorAction Stop -Verbose -Debug
          } else {
            Connect-PowerBIServiceAccount -Credential $credential `
              -TenantId ${env:TENANT_ID} -ErrorAction Stop -Verbose -Debug
          }

          Write-Host "Connected to Power BI successfully."

          # ----------- Process Changes ----------- #
          Write-Host "Processing changes..."

--------------------------------------------------------------------------------

TEMP:



parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: ONELAKE_ENDPOINT
    displayName: "OneLake Endpoint"
    type: string
    default: 'https://onelakeendpoint.fabric.microsoft.com'  # Replace with your actual OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: ONELAKE_ENDPOINT
    value: '${{ parameters.ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Uninstall AzureRM Modules ----------- #
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = ${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new(${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # Set AzCopy Connection
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("${env:ONELAKE_ENDPOINT}")
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="${oneLakeDomain}" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipDSChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRPTChanges)"

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get Dev and UAT workspace IDs
                $devWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:DEV_WORKSPACE_NAME}"
                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:UAT_WORKSPACE_NAME}"

                if (-not $devWorkspaceObj) {
                    Write-Error "Dev workspace '${env:DEV_WORKSPACE_NAME}' not found."
                    throw
                }

                if (-not $uatWorkspaceObj) {
                    Write-Error "UAT workspace '${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $devWorkspaceID = $devWorkspaceObj.Id
                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Prepare paths to promote
                $smPathsToPromote = @()
                foreach ($change in $pbipDSChanges) {
                    $smPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Semantic Models
                foreach ($promotePath in $smPathsToPromote) {
                    try {
                        Write-Host "Promoting semantic model at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath: $_"
                        throw
                    }
                }

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Prepare paths to promote
                $rptPathsToPromote = @()
                foreach ($change in $pbipRPTChanges) {
                    $rptPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Reports
                foreach ($promotePath in $rptPathsToPromote) {
                    try {
                        Write-Host "Promoting report at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote report at $promotePath: $_"
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $uatWorkspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          ONELAKE_ENDPOINT: $(ONELAKE_ENDPOINT)
------------------------------------------------------------------------------------------------------

one lake system varibale:

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Uninstall AzureRM Modules ----------- #
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = ${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new(${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # Set AzCopy Connection
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("${env:ONELAKE_ENDPOINT}")
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="${oneLakeDomain}" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipDSChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRPTChanges)"

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get Dev and UAT workspace IDs
                $devWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:DEV_WORKSPACE_NAME}"
                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:UAT_WORKSPACE_NAME}"

                if (-not $devWorkspaceObj) {
                    Write-Error "Dev workspace '${env:DEV_WORKSPACE_NAME}' not found."
                    throw
                }

                if (-not $uatWorkspaceObj) {
                    Write-Error "UAT workspace '${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $devWorkspaceID = $devWorkspaceObj.Id
                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Prepare paths to promote
                $smPathsToPromote = @()
                foreach ($change in $pbipDSChanges) {
                    $smPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Semantic Models
                foreach ($promotePath in $smPathsToPromote) {
                    try {
                        Write-Host "Promoting semantic model at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath: $_"
                        throw
                    }
                }

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Prepare paths to promote
                $rptPathsToPromote = @()
                foreach ($change in $pbipRPTChanges) {
                    $rptPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Reports
                foreach ($promotePath in $rptPathsToPromote) {
                    try {
                        Write-Host "Promoting report at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote report at $promotePath: $_"
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $uatWorkspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
---------------------------------------------------------


2 lake points:


parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual Dev OneLake endpoint

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual UAT OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Uninstall AzureRM Modules ----------- #
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = $${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = $${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $$false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $$true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # Set AzCopy Connection based on the target OneLake endpoint
                # We need to determine which endpoint to use based on the workspace we're promoting to
                $targetWorkspaceName = "$${env:UAT_WORKSPACE_NAME}".Trim()
                $targetOneLakeEndpoint = "$${env:UAT_ONELAKE_ENDPOINT}".Trim()

                $${env:AZCOPY_SPA_CLIENT_SECRET} = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("$${targetOneLakeEndpoint}")
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="$${oneLakeDomain}" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $$_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $$($pbipDSChanges)"
                Write-Host "##[debug]Detected Report Changes: $$($pbipRPTChanges)"

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "$${env:UAT_WORKSPACE_NAME}"

                if (-not $uatWorkspaceObj) {
                    Write-Error "UAT workspace '$${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Prepare paths to promote
                $smPathsToPromote = @()
                foreach ($change in $pbipDSChanges) {
                    $smPathsToPromote += (Join-Path -Path $${env:BUILD_SOURCESDIRECTORY} -ChildPath $change)
                }

                # Import Semantic Models
                foreach ($promotePath in $smPathsToPromote) {
                    try {
                        Write-Host "Promoting semantic model at $$promotePath to UAT workspace $${env:UAT_WORKSPACE_NAME}"
                        $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $$promotePath -Verbose -Debug
                        Write-Host "Semantic model imported successfully."
                    } catch {
                        Write-Error "Failed to promote semantic model at $$promotePath: $$_"
                        throw
                    }
                }

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Prepare paths to promote
                $rptPathsToPromote = @()
                foreach ($change in $pbipRPTChanges) {
                    $rptPathsToPromote += (Join-Path -Path $${env:BUILD_SOURCESDIRECTORY} -ChildPath $change)
                }

                # Import Reports
                foreach ($promotePath in $rptPathsToPromote) {
                    try {
                        Write-Host "Promoting report at $$promotePath to UAT workspace $${env:UAT_WORKSPACE_NAME}"
                        $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $$promotePath -Verbose -Debug
                        Write-Host "Report imported successfully."
                    } catch {
                        Write-Error "Failed to promote report at $$promotePath: $$_"
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $uatWorkspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $$_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $$_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $$_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)
--------------------------------------------------------------------
reference code imported logic:

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual Dev OneLake endpoint

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual UAT OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # Uninstall AzureRM Modules
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # Install Required PowerShell Modules
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $$_ -OutFile ".\.nuget\custom_modules\$$(Split-Path $$_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = $${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = $${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($$tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$$($$tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($$credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$$($$credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $$guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $$isServicePrincipal = $$false

                if ($$credential.UserName -match $$guidRegex) {
                  $$isServicePrincipal = $$true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $$secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($$credential.Password)
                $$plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($$secureStringPtr)

                # Set Fabric Connection
                if ($$isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $$credential.UserName `
                    -servicePrincipalSecret $$plainTextPwd `
                    -tenantId $$tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $$credential -tenantId $$tenantId -reset
                }

                # Set AzCopy Connection based on the target OneLake endpoint
                $${env:AZCOPY_SPA_CLIENT_SECRET} = $$plainTextPwd
                $$oneLakeUri = New-Object System.Uri("$${env:UAT_ONELAKE_ENDPOINT}".Trim())
                $$oneLakeDomain = $$oneLakeUri.Host

                $$loginResult = azcopy login --service-principal `
                  --application-id $$credential.UserName `
                  --tenant-id $$tenantId `
                  --trusted-microsoft-suffixes="$$oneLakeDomain" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $$checkResult = $$loginResult | Where-Object { $$_.$MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($$isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $$credential `
                    -TenantId $$tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $$credential `
                    -TenantId $$tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $$pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $$pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $$pbipSMChanges = $$pbipSMChanges | Sort-Object -Unique
                $$pbipRptChanges = $$pbipRptChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $$($$pbipSMChanges)"
                Write-Host "##[debug]Detected Report Changes: $$($$pbipRptChanges)"

                # Detect if no changes
                if ($$pbipSMChanges.Count -eq 0 -and $$pbipRptChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $$workspaceObj = Get-FabricWorkspace -workspaceName "$${env:UAT_WORKSPACE_NAME}"

                if (-not $$workspaceObj) {
                    Write-Error "UAT workspace '$${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $$workspaceID = $$workspaceObj.Id

                # ----------- Handle Semantic Models For Promotion ----------- #
                # Identify Semantic Models changed
                $$smPathsToPromote = @()
                $$filter = "*.pbism"

                foreach ($$change in $$pbipSMChanges) {
                    $$parentFolder = Split-Path $$change -Parent
                    while ($$null -ne $$parentFolder -and !(-Test-Path (Join-Path $$parentFolder $$filter))) {
                        $$parentFolder = Split-Path $$parentFolder -Parent
                    }
                    $$smPathsToPromote += $$parentFolder
                }

                # Remove duplicates
                $$smPathsToPromote = @([System.Collections.Generic.HashSet[string]]$$smPathsToPromote)

                # Setup promoted items array
                $$smPromotedItems = @()

                # Promote semantic models to UAT workspace
                foreach ($$promotePath in $$smPathsToPromote) {
                    Write-Host "##[debug]Promoting semantic model at $$($$promotePath) to workspace $${env:UAT_WORKSPACE_NAME}"
                    $$smPromotedItems += Import-FabricItem -workspaceId $$workspaceID -path $$promotePath
                }

                # Retrieve all items in workspace
                $$items = Invoke-FabricRestMethod -Method GET -Url "workspaces/$$workspaceID/items"

                # ----------- Handle Reports For Promotion ----------- #
                # Identify Reports changed
                $$rptPathsToPromote = @()
                $$filter = "*.pbir"

                foreach ($$change in $$pbipRptChanges) {
                    $$parentFolder = Split-Path $$change -Parent
                    while ($$null -ne $$parentFolder -and !(-Test-Path (Join-Path $$parentFolder $$filter))) {
                        $$parentFolder = Split-Path $$parentFolder -Parent
                    }
                    $$rptPathsToPromote += $$parentFolder
                }

                # Remove duplicates
                $$rptPathsToPromote = @([System.Collections.Generic.HashSet[string]]$$rptPathsToPromote)

                # Setup promoted items array
                $$rptPromotedItems = @()

                $$semanticModelName = $$null

                Write-Host "##[debug] rptPathsToPromote: $$($$rptPathsToPromote)"

                # Promote reports to UAT workspace
                foreach ($$promotePath in $$rptPathsToPromote) {
                    # Get report definition
                    $$def = Get-ChildItem -Path $$promotePath -Recurse -Include "definition.pbir"
                    $$semanticModelPath = (Get-Content $$def.FullName | ConvertFrom-Json).datasetReference.byPath

                    Write-Host "##[debug] SemanticModelPath: $$($$semanticModelPath)"

                    # If byPath was null, we'll assume byConnection is set and skip
                    if ($$semanticModelPath -ne $$null) {
                        # Semantic Model path is relative to the report path, Join-Path can handle relative paths
                        $$pathToCheck = Join-Path $$promotePath $$semanticModelPath.path
                        $$metadataSM = Get-ChildItem -Path $$pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                      Where-Object { (Split-Path -Path $$_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $$_.FullName).EndsWith(".SemanticModel") }

                        if ($$metadataSM -ne $$null) {
                            $$content = Get-Content $$metadataSM.FullName | ConvertFrom-Json

                            # Handle item.metadata.json
                            if ($$metadataSM.Name -eq "item.metadata.json") {
                                # Prior to March-2024 release
                                $$semanticModelName = $$content.displayName
                                Write-Host "##[debug] SemanticModelName: $$($$semanticModelName)"
                            } else {
                                $$semanticModelName = $$content.metadata.displayName
                                Write-Host "##[debug] SemanticModelName: $$($$semanticModelName)"
                            }
                        } else {
                            Write-Host "##[vso[task.logissue type=error]Semantic Model definition not found in workspace."
                        }
                    }

                    # Get the semantic model id from items in the workspace
                    $$semanticModel = $$items | Where-Object { $$_.type -eq "SemanticModel" -and $$_.displayName -eq $$semanticModelName }

                    Write-Host "##[debug] semanticModel: $$($$semanticModel)"

                    if (!$$semanticModel) {
                        Write-Host "##[vso[task.logissue type=error]Semantic Model not found in workspace."
                    } else {
                        # Import report with appropriate semantic model id
                        Write-Host "##[debug] Promoting report at $$($$promotePath) to workspace $${env:UAT_WORKSPACE_NAME}"
                        $$promotedItem = Import-FabricItem -workspaceId $$workspaceID -path $$promotePath -itemProperties @{ semanticmodelId = "$$($$semanticModel.id)" }
                        $$rptPromotedItems += $$promotedItem
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $$workspaceID -Credential $$credential -TenantId $$tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $$_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $$workspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $$_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $$_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)

--------------------------------------------------------------------------

new gpt:

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual Dev OneLake endpoint

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual UAT OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # Uninstall AzureRM Modules
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # Install Required PowerShell Modules
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = $env:TENANT_ID.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                Write-Host "Authenticating to Fabric API..."
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset -Verbose -Debug
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset -Verbose -Debug
                }

                # Verify that the token is set
                $authToken = Get-FabricAuthToken
                if (-not $authToken) {
                  Write-Error "Failed to obtain Fabric authentication token."
                  throw "Fabric authentication failed."
                } else {
                  Write-Host "Fabric authentication token obtained successfully."
                }

                # Set AzCopy Connection based on the target OneLake endpoint
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("$($env:UAT_ONELAKE_ENDPOINT)".Trim())
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="$oneLakeDomain" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Error "Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipSMChanges = $pbipSMChanges | Sort-Object -Unique
                $pbipRptChanges = $pbipRptChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipSMChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRptChanges)"

                # Detect if no changes
                if ($pbipSMChanges.Count -eq 0 -and $pbipRptChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"

                if (-not $workspaceObj) {
                    Write-Error "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
                    throw
                }

                $workspaceID = $workspaceObj.Id

                # ----------- Handle Semantic Models For Promotion ----------- #
                # Identify Semantic Models changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipSMChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    $smPathsToPromote += $parentFolder
                }

                # Remove duplicates
                $smPathsToPromote = $smPathsToPromote | Select-Object -Unique

                # Setup promoted items array
                $smPromotedItems = @()

                # Promote semantic models to UAT workspace
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "Promoting semantic model at $promotePath to workspace $($env:UAT_WORKSPACE_NAME)"
                    try {
                        $smPromotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath -Verbose -Debug
                        $smPromotedItems += $smPromotedItem
                        Write-Host "Semantic model imported successfully."
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath."
                        Write-Error "Error Details: $_"
                        if ($_.Exception.Response) {
                            $responseContent = $_.Exception.Response.Content
                            Write-Error "API Response: $responseContent"
                        }
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $workspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $workspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)


----------------------------------------------------------------------------------------

test anna
__________________________________________________________________
trigger:
  - main  # Adjust branch as needed

pool:
  vmImage: 'windows-latest'

steps:
  # Step 1: Checkout Repository with Full History
  - task: Checkout@1
    displayName: "Checkout Repository"
    inputs:
      fetchDepth: 0  # Fetch full commit history

  # Step 2: Detect Changes in .pbism and .pbir Files
  - task: PowerShell@2
    displayName: "Detect Changes in Power BI Files"
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "Detecting changes in Power BI files..."

        # Detect changes for .pbism and .pbir files
        $pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
        $pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')

        # Output detected changes for debugging
        Write-Host "Detected Semantic Model Changes: $($pbipSMChanges)"
        Write-Host "Detected Report Changes: $($pbipRptChanges)"

        # Exit if no changes detected
        if ($pbipSMChanges.Count -eq 0 -and $pbipRptChanges.Count -eq 0) {
            Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
            exit 0
        }

  # Step 3: Publish Build Artifacts (if changes are detected)
  - task: PublishBuildArtifacts@1
    displayName: "Publish Build Artifacts"
    inputs:
      pathToPublish: '$(System.DefaultWorkingDirectory)'
      artifactName: 'PowerBIArtifacts'





---------------------------------------------------------------------------
trigger: none  # Trigger manually or by the CI pipeline artifact

resources:
  pipelines:
    - pipeline: ciPipeline  # Reference name for the CI pipeline
      project: Power-BI  # Replace with your actual project name
      source: 142  # CI pipeline ID

variables:
  - group: powerbi
  - name: workspace_id_uat
    value: a4628c7b-adda-4285-8c1f-758b19162d0b

stages:
- stage: Deploy
  displayName: "Continuous Deployment"
  jobs:
  - job: DeployReports
    displayName: "Deploy Reports to Power BI workspace"
    pool:
      vmImage: windows-latest
    steps:
    # Step 1: Install Power BI Module
    - task: PowerShell@2
      displayName: Install and Import Power BI Module
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Checking if the MicrosoftPowerBIMgmt module is already installed..."
          if (-not (Get-Module -ListAvailable -Name MicrosoftPowerBIMgmt)) {
            Write-Host "MicrosoftPowerBIMgmt module not found. Installing now..."
            Install-Module -Name MicrosoftPowerBIMgmt -Force -Scope CurrentUser -AllowClobber
            Install-Module -Name MicrosoftPowerBIMgmt.Profile -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name MicrosoftPowerBIMgmt.Reports -Scope CurrentUser -AllowClobber -Force
          } else {
            Write-Host "MicrosoftPowerBIMgmt module is already installed."
          }
          Import-Module MicrosoftPowerBIMgmt
          Import-Module MicrosoftPowerBIMgmt.Profile
          Import-Module MicrosoftPowerBIMgmt.Reports
          Write-Host "Modules installed and imported successfully."

    # Step 2: Download Artifacts from CI Pipeline
    - task: DownloadPipelineArtifact@2
      displayName: Download Artifacts from CI Pipeline
      inputs:
        source: current
        artifact: PowerBIArtifacts
        path: $(Pipeline.Workspace)

    # Step 3: Deploy Power BI Reports and Models
    - task: PowerShell@2
      displayName: Deploy Power BI Reports and Models
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting deployment of Power BI files to UAT..."
          $workspaceId = "$(workspace_id_uat)"
          Write-Host "Workspace ID set to UAT: $workspaceId"

          # Authenticate to Power BI Service using Service Principal
          $credential = New-Object System.Management.Automation.PSCredential(
            "$(clinetid)",
            (ConvertTo-SecureString "$(Clientsecret)" -AsPlainText -Force)
          )
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId "$(tenantid)"

          # Deploy .pbir files (Power BI Reports)
          $reportFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/PowerBIArtifacts/**/*.pbir" -Recurse
          if ($reportFiles.Count -eq 0) {
            Write-Host "No report files (.pbir) found. Skipping deployment."
          } else {
            $reportFiles | ForEach-Object {
              Write-Host "Deploying report: $($_.FullName)"
              Import-PowerBIReport -Path $_.FullName -WorkspaceId $workspaceId -ConflictAction Overwrite
            }
          }

          # Deploy .pbism files (Power BI Semantic Models)
          $modelFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/PowerBIArtifacts/**/*.pbism" -Recurse
          if ($modelFiles.Count -eq 0) {
            Write-Host "No semantic model files (.pbism) found. Skipping deployment."
          } else {
            $modelFiles | ForEach-Object {
              Write-Host "Deploying semantic model: $($_.FullName)"
              # Add deployment logic for .pbism files if needed
            }
          }

          Write-Host "Deployment completed successfully for UAT."
--------------------------------

trigger: none  # Trigger manually or by the CI pipeline artifact

resources:
  pipelines:
    - pipeline: ciPipeline  # Reference name for the CI pipeline
      project: Power-BI  # Replace with your actual project name
      source: Power-BI-(CI)  # The exact name of your CI pipeline
      trigger: true  # Optional: Enable triggering the CD pipeline after CI completes

variables:
  - group: powerbi
  - name: workspace_id_uat
    value: a4628c7b-adda-4285-8c1f-758b19162d0b

stages:
- stage: Deploy
  displayName: "Continuous Deployment"
  jobs:
  - job: DeployReports
    displayName: "Deploy Reports to Power BI workspace"
    pool:
      vmImage: windows-latest
    steps:
    # Step 1: Install Power BI Module
    - task: PowerShell@2
      displayName: Install and Import Power BI Module
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Checking if the MicrosoftPowerBIMgmt module is already installed..."
          if (-not (Get-Module -ListAvailable -Name MicrosoftPowerBIMgmt)) {
            Write-Host "MicrosoftPowerBIMgmt module not found. Installing now..."
            Install-Module -Name MicrosoftPowerBIMgmt -Force -Scope CurrentUser -AllowClobber
            Install-Module -Name MicrosoftPowerBIMgmt.Profile -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name MicrosoftPowerBIMgmt.Reports -Scope CurrentUser -AllowClobber -Force
          } else {
            Write-Host "MicrosoftPowerBIMgmt module is already installed."
          }
          Import-Module MicrosoftPowerBIMgmt
          Import-Module MicrosoftPowerBIMgmt.Profile
          Import-Module MicrosoftPowerBIMgmt.Reports
          Write-Host "Modules installed and imported successfully."

    # Step 2: Download Artifacts from CI Pipeline
    - download: ciPipeline  # Reference to the pipeline resource defined above
      artifact: 'PowerBIArtifacts'  # Exact artifact name from the CI pipeline
      patterns: '**'  # Optional: Specify patterns if needed
      path: $(Pipeline.Workspace)  # Destination path for the downloaded artifacts

    # Step 3: Deploy Power BI Reports and Models
    - task: PowerShell@2
      displayName: Deploy Power BI Reports and Models
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting deployment of Power BI files to UAT..."
          $workspaceId = "$(workspace_id_uat)"
          Write-Host "Workspace ID set to UAT: $workspaceId"

          # Authenticate to Power BI Service using Service Principal
          $credential = New-Object System.Management.Automation.PSCredential(
            "$(clinetid)",
            (ConvertTo-SecureString "$(Clientsecret)" -AsPlainText -Force)
          )
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId "$(tenantid)"

          # Deploy .pbir files (Power BI Reports)
          $reportFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbir" -Recurse
          if ($reportFiles.Count -eq 0) {
            Write-Host "No report files (.pbir) found. Skipping deployment."
          } else {
            $reportFiles | ForEach-Object {
              Write-Host "Deploying report: $($_.FullName)"
              Import-PowerBIReport -Path $_.FullName -WorkspaceId $workspaceId -ConflictAction Overwrite
            }
          }

          # Deploy .pbism files (Power BI Semantic Models)
          $modelFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbism" -Recurse
          if ($modelFiles.Count -eq 0) {
            Write-Host "No semantic model files (.pbism) found. Skipping deployment."
          } else {
            $modelFiles | ForEach-Object {
              Write-Host "Deploying semantic model: $($_.FullName)"
              # Add deployment logic for .pbism files if needed
            }
          }

          Write-Host "Deployment completed successfully for UAT."
-------------------------------------------------------------------------

- task: DownloadPipelineArtifact@2
      displayName: Download Artifacts from CI Pipeline
      inputs:
        buildType: 'specific'
        project: 'Power-BI'  # Replace with your project name
        definition: 'Power-BI-(CI)'  # Replace with your CI pipeline name
        buildVersionToDownload: 'latest'
        artifactName: 'PowerBIArtifacts'  # Ensure the artifact name matches exactly
        targetPath: '$(Pipeline.Workspace)'

--------------------------------------------

trigger: none  # Trigger manually or by the CI pipeline artifact

resources:
  pipelines:
    - pipeline: ciPipeline  # Reference name for the CI pipeline
      project: Power-BI  # Replace with your actual project name
      source: Power-BI-(CI)  # The exact name of your CI pipeline
      trigger: true  # Optional: Enable triggering the CD pipeline after CI completes

variables:
  - group: powerbi
  - name: workspace_id_uat
    value: a4628c7b-adda-4285-8c1f-758b19162d0b

stages:
- stage: Deploy
  displayName: "Continuous Deployment"
  jobs:
  - job: DeployReports
    displayName: "Deploy Reports to Power BI workspace"
    pool:
      vmImage: windows-latest
    steps:
    # Step 1: Install and Import Power BI Module
    - task: PowerShell@2
      displayName: Install and Import Power BI Module
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Installing MicrosoftPowerBIMgmt modules..."
          # Install all MicrosoftPowerBIMgmt modules
          Install-Module -Name MicrosoftPowerBIMgmt -Force -Scope CurrentUser -AllowClobber -ErrorAction Stop
          # Import the module
          Import-Module MicrosoftPowerBIMgmt -ErrorAction Stop -Verbose
          Write-Host "Modules installed and imported successfully."
          # Verify that Import-PowerBIReport cmdlet is available
          if (Get-Command -Name 'Import-PowerBIReport' -ErrorAction SilentlyContinue) {
              Write-Host "Import-PowerBIReport cmdlet is available."
          } else {
              Write-Error "Import-PowerBIReport cmdlet is not available."
          }
        pwsh: false  # Use Windows PowerShell instead of PowerShell Core

    # Step 2: Download Artifacts from CI Pipeline
    - download: ciPipeline  # Reference to the pipeline resource defined above
      artifact: 'PowerBIArtifacts'  # Exact artifact name from the CI pipeline
      root: $(Pipeline.Workspace)  # Destination path for the downloaded artifacts

    # Step 3: Deploy Power BI Reports and Models
    - task: PowerShell@2
      displayName: Deploy Power BI Reports and Models
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting deployment of Power BI files to UAT..."
          $workspaceId = "$(workspace_id_uat)"
          Write-Host "Workspace ID set to UAT: $workspaceId"

          # Authenticate to Power BI Service using Service Principal
          $credential = New-Object System.Management.Automation.PSCredential(
            "$(clientid)",
            (ConvertTo-SecureString "$(Clientsecret)" -AsPlainText -Force)
          )
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId "$(tenantid)" -ErrorAction Stop

          # Deploy .pbix files (Power BI Reports)
          $reportFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbix" -Recurse
          if ($reportFiles.Count -eq 0) {
            Write-Host "No report files (.pbix) found. Skipping deployment."
          } else {
            $reportFiles | ForEach-Object {
              Write-Host "Deploying report: $($_.FullName)"
              Import-PowerBIReport -Path $_.FullName -WorkspaceId $workspaceId -ConflictAction Overwrite -ErrorAction Stop
            }
          }

          # Deploy .pbism files (Power BI Semantic Models)
          $modelFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbism" -Recurse
          if ($modelFiles.Count -eq 0) {
            Write-Host "No semantic model files (.pbism) found. Skipping deployment."
          } else {
            $modelFiles | ForEach-Object {
              Write-Host "Deploying semantic model: $($_.FullName)"
              # Add deployment logic for .pbism files if needed
            }
          }

          Write-Host "Deployment completed successfully for UAT."
        pwsh: false  # Use Windows PowerShell instead of PowerShell Core

-------------------------------------------------------------------

steps:
    # Step 1: Install and Import Power BI Module
    - task: PowerShell@2
      displayName: Install and Import Power BI Module
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "PowerShell Version:"
          $PSVersionTable

          # Update the NuGet provider
          Write-Host "Updating NuGet provider..."
          Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -ErrorAction Stop

          # Update PowerShellGet module
          Write-Host "Updating PowerShellGet module..."
          Install-Module -Name PowerShellGet -Force -AllowClobber -ErrorAction Stop -Scope AllUsers

          # Set Execution Policy
          Write-Host "Setting execution policy..."
          Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope LocalMachine -Force

          # Install MicrosoftPowerBIMgmt module in AllUsers scope
          Write-Host "Installing MicrosoftPowerBIMgmt modules..."
          Install-Module -Name MicrosoftPowerBIMgmt -Force -AllowClobber -ErrorAction Stop -Scope AllUsers

          # Add the module path to PSModulePath
          $modulePath = "$env:ProgramFiles\WindowsPowerShell\Modules"
          Write-Host "Adding $modulePath to PSModulePath"
          $env:PSModulePath = "$env:PSModulePath;$modulePath"

          # Import the module
          Write-Host "Importing MicrosoftPowerBIMgmt modules..."
          Import-Module MicrosoftPowerBIMgmt -ErrorAction Stop -Force -Verbose

          # Verify that Import-PowerBIReport cmdlet is available
          if (Get-Command -Name 'Import-PowerBIReport' -ErrorAction SilentlyContinue) {
              Write-Host "Import-PowerBIReport cmdlet is available."
          } else {
              Write-Error "Import-PowerBIReport cmdlet is not available."
          }

          # Output available modules
          Write-Host "Available Modules:"
          Get-Module -ListAvailable

          # Output PSModulePath
          Write-Host "PSModulePath is: $env:PSModulePath"

        pwsh: false  # Use Windows PowerShell instead of PowerShell Core




---------------------------------------------------------------------


trigger: none  # Trigger manually or by the CI pipeline artifact

resources:
  pipelines:
    - pipeline: ciPipeline  # Reference name for the CI pipeline
      project: Power-BI  # Replace with your actual project name
      source: Power-BI-(CI)  # The exact name of your CI pipeline
      trigger: true  # Optional: Enable triggering the CD pipeline after CI completes

variables:
  - group: powerbi  # Your variable group containing the variables
  - name: workspace_id_uat
    value: a4628c7b-adda-4285-8c1f-758b19162d0b

stages:
- stage: Deploy
  displayName: "Continuous Deployment"
  jobs:
  - job: DeployReports
    displayName: "Deploy Reports to Power BI workspace"
    pool:
      vmImage: windows-latest
    steps:
    # Step 1: Download Artifacts from CI Pipeline
    - download: ciPipeline  # Reference to the pipeline resource defined above
      artifact: 'PowerBIArtifacts'  # Exact artifact name from the CI pipeline
      root: $(Pipeline.Workspace)  # Destination path for the downloaded artifacts

    # Step 2: Deploy Power BI Reports using REST API
    - task: PowerShell@2
      displayName: Deploy Power BI Reports and Models via REST API
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting deployment of Power BI files to UAT..."

          $tenantId = "$(tenantid)"
          $clientId = "$(clinetid)"
          $clientSecret = "$(Clientsecret)"
          $workspaceId = "$(workspace_id_uat)"

          # Output the variables for debugging (optional, remove in production)
          Write-Host "Tenant ID: $tenantId"
          Write-Host "Client ID: $clientId"
          Write-Host "Workspace ID: $workspaceId"

          # Authenticate and get an access token
          $tokenResponse = Invoke-RestMethod -Method Post -Uri "https://login.microsoftonline.com/$tenantId/oauth2/token" -Body @{
              grant_type    = "client_credentials"
              client_id     = $clientId
              client_secret = $clientSecret
              resource      = "https://analysis.windows.net/powerbi/api"
          }

          if ($tokenResponse -and $tokenResponse.access_token) {
              Write-Host "Successfully obtained access token."
          } else {
              Write-Error "Failed to obtain access token."
              exit 1
          }

          $accessToken = $tokenResponse.access_token

          # Set up the authorization header
          $headers = @{
              "Authorization" = "Bearer $accessToken"
          }

          # Find .pbix files
          $reportFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbix" -Recurse

          if ($reportFiles.Count -eq 0) {
              Write-Host "No report files (.pbix) found. Skipping deployment."
          } else {
              foreach ($file in $reportFiles) {
                  Write-Host "Deploying report: $($file.FullName)"

                  # Read the file content
                  $fileContent = [IO.File]::ReadAllBytes($file.FullName)

                  # Create a boundary for the multipart/form-data
                  $boundary = [System.Guid]::NewGuid().ToString()
                  $contentType = "multipart/form-data; boundary=`"$boundary`""

                  # Build the body
                  $body = "--$boundary`r`n"
                  $body += "Content-Disposition: form-data; name=`"file`"; filename=`"$($file.Name)`"`r`n"
                  $body += "Content-Type: application/octet-stream`r`n`r`n"
                  $bodyBytes = [System.Text.Encoding]::UTF8.GetBytes($body)
                  $fileBytes = $fileContent
                  $endBoundary = "`r`n--$boundary--`r`n"
                  $endBoundaryBytes = [System.Text.Encoding]::UTF8.GetBytes($endBoundary)

                  # Combine the byte arrays
                  $memoryStream = New-Object System.IO.MemoryStream
                  $memoryStream.Write($bodyBytes, 0, $bodyBytes.Length)
                  $memoryStream.Write($fileBytes, 0, $fileBytes.Length)
                  $memoryStream.Write($endBoundaryBytes, 0, $endBoundaryBytes.Length)
                  $memoryStream.Position = 0

                  # Define the URI
                  $uri = "https://api.powerbi.com/v1.0/myorg/groups/$workspaceId/imports?datasetDisplayName=$($file.BaseName)&nameConflict=Overwrite"

                  # Make the POST request
                  try {
                      $response = Invoke-RestMethod -Method Post -Uri $uri -Headers $headers -ContentType $contentType -Body $memoryStream -TimeoutSec 600
                      Write-Host "Successfully deployed report: $($file.Name)"
                  } catch {
                      Write-Error "Failed to deploy report $($file.Name): $_"
                  } finally {
                      $memoryStream.Dispose()
                  }
              }
          }

          Write-Host "Deployment completed successfully for UAT."
      pwsh: false  # Use Windows PowerShell instead of PowerShell Core

_________________________________________________________________________________

CI with auth



trigger:
- main  # Adjust as needed

variables:
- group: powerbi  # References tenantid, clinetid, Clientsecret

pool:
  vmImage: 'windows-latest'

steps:
# Step 1: Checkout Repository with Full History
- checkout: self
  displayName: "Checkout Repository"
  fetchDepth: 0

# Step 2: Detect Changes in .pbism and .pbir Files
- task: PowerShell@2
  displayName: "Detect Changes in Power BI Files"
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Detecting changes in Power BI files..."
      $pbismChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
      $pbirChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')

      Write-Host "Detected Semantic Model Changes (.pbism): $($pbismChanges)"
      Write-Host "Detected Report Changes (.pbir): $($pbirChanges)"

      if ($pbismChanges.Count -eq 0 -and $pbirChanges.Count -eq 0) {
          Write-Host "No changes detected in .pbism or .pbir files. Exiting..."
          exit 0
      } else {
          Write-Host "Changes detected. Proceeding..."
      }

# Step 3: Install Power BI Modules and Authenticate to Confirm Dev Environment
- task: PowerShell@2
  displayName: "Authenticate and Confirm Dev Environment"
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Installing MicrosoftPowerBIMgmt modules..."
      Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -Force -AllowClobber

      Write-Host "Importing modules..."
      Import-Module MicrosoftPowerBIMgmt
      Import-Module MicrosoftPowerBIMgmt.Profile
      Import-Module MicrosoftPowerBIMgmt.Reports

      $tenantId = "$(tenantid)"
      $clientId = "$(clinetid)"
      $clientSecret = "$(Clientsecret)"

      $secureSecret = ConvertTo-SecureString $clientSecret -AsPlainText -Force
      $credential = New-Object System.Management.Automation.PSCredential($clientId, $secureSecret)

      Write-Host "Connecting to Power BI Service..."
      Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop

      Write-Host "Listing Workspaces..."
      $workspaces = Get-PowerBIWorkspace -Scope Organization

      # Check for the Dev workspace by name and ID
      $devWorkspace = $workspaces | Where-Object { $_.Name -eq "Version Control[Dev]" -and $_.Id -eq "c017440f-4a5b-46bd-a2c0-93ee3f04ab4d" }

      if (-not $devWorkspace) {
        Write-Error "Dev workspace 'Version Control[Dev]' with ID 'c017440f-4a5b-46bd-a2c0-93ee3f04ab4d' not found. This might not be the Dev environment."
        exit 1
      } else {
        Write-Host "Confirmed Dev environment with workspace 'Version Control[Dev]' (ID: c017440f-4a5b-46bd-a2c0-93ee3f04ab4d)."
      }

# Step 4: Publish Artifacts
- task: PublishBuildArtifacts@1
  displayName: "Publish Power BI Artifacts"
  inputs:
    pathToPublish: '$(System.DefaultWorkingDirectory)'
    artifactName: 'PowerBIArtifacts'


-----------------------------------------------------------

.pbir logic

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'

trigger:
  branches:
    include:
      - develop

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Promotion Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Required Modules
      - task: PowerShell@2
        displayName: '=== Installing Dependencies ==='
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # Removing legacy modules if present
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            
            Write-Host "Installing required PowerShell modules..."
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            if (-not (Test-Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }
            
            Write-Host "Dependencies installed successfully."

      - task: PowerShell@2
        displayName: '=== Promoting Changes to UAT ==='
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # Import modules
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # Credentials setup
                $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
                $tenantId = $env:TENANT_ID.Trim()

                Write-Host "=== Authenticating to Fabric ==="
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)
                
                # Determine if service principal
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false
                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                $authToken = Get-FabricAuthToken
                if (-not $authToken) {
                  Write-Error "Authentication to Fabric failed."
                  throw "Fabric authentication failed."
                }

                Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential

                Write-Host "=== Authenticating to OneLake with AzCopy ==="
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("$($env:UAT_ONELAKE_ENDPOINT)".Trim())
                $oneLakeDomain = $oneLakeUri.Host
                $loginResult = azcopy login --service-principal --application-id $credential.UserName --tenant-id $tenantId --trusted-microsoft-suffixes="$oneLakeDomain" --output-type json | ConvertFrom-Json
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }
                if (!$checkResult) {
                  Write-Error "AzCopy authentication failed."
                  throw "AzCopy login failed."
                }

                Write-Host "=== Connecting to Power BI Service ==="
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential -TenantId $tenantId -ErrorAction Stop
                }

                Write-Host "=== Detecting Changes ==="
                $pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipSMChanges = $pbipSMChanges | Sort-Object -Unique
                $pbipRptChanges = $pbipRptChanges | Sort-Object -Unique

                if ($pbipSMChanges.Count -eq 0 -and $pbipRptChanges.Count -eq 0) {
                    Write-Host "No changes detected. Exiting pipeline."
                    exit 0
                }

                Write-Host "=== Retrieving UAT Workspace ==="
                $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
                if (-not $workspaceObj) {
                    Write-Error ("UAT workspace '{0}' not found." -f $env:UAT_WORKSPACE_NAME)
                    throw "Workspace not found."
                }

                $workspaceID = $workspaceObj.Id

                function Import-SemanticModel($modelPath, $workspaceID) {
                    Write-Host ("Importing semantic model from {0} into UAT workspace." -f $modelPath)
                    try {
                        $smItem = Import-FabricItem -workspaceId $workspaceID -path $modelPath
                        Write-Host "Semantic model imported successfully."
                        return $smItem
                    } catch {
                        $err = $_
                        Write-Error ("Failed to import semantic model at {0}: {1}" -f $modelPath, $err)
                        throw $err
                    }
                }

                $smPromotedItems = @()

                # Import semantic models if changed
                if ($pbipSMChanges.Count -gt 0) {
                    Write-Host "=== Importing Changed Semantic Models ==="
                    $smPathsToPromote = @()
                    $filter = "*.pbism"
                    foreach ($change in $pbipSMChanges) {
                        $parentFolder = Split-Path $change -Parent
                        while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                            $parentFolder = Split-Path $parentFolder -Parent
                        }
                        $smPathsToPromote += $parentFolder
                    }
                    $smPathsToPromote = $smPathsToPromote | Select-Object -Unique

                    foreach ($promotePath in $smPathsToPromote) {
                        $smImported = Import-SemanticModel $promotePath $workspaceID
                        $smPromotedItems += $smImported
                    }
                }

                # If no reports changed, just exit after semantic models updated
                if ($pbipRptChanges.Count -eq 0) {
                    Write-Host "No report changes detected. All requested semantic models are updated."
                    Write-Host "Pipeline completed successfully."
                    exit 0
                }

                # Import reports
                Write-Host "=== Importing Changed Reports ==="
                $itemsJson = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET
                $allItems = $itemsJson
                $finalSemanticModelId = $null

                foreach ($change in $pbipRptChanges) {
                    $parentFolder = Split-Path $change -Parent
                    $filter = "*.pbir"
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        # Get report definition
                        $def = Get-ChildItem -Path $parentFolder -Recurse -Include "definition.pbir"
                        if ($def -eq $null) {
                            Write-Error ("Report definition.pbir not found in {0}" -f $parentFolder)
                            throw "Report definition not found."
                        }

                        $reportDefinition = Get-Content $def.FullName | ConvertFrom-Json
                        $semanticModelPath = $reportDefinition.datasetReference.byPath
                        if ($semanticModelPath -eq $null) {
                            Write-Error "Report definition does not specify datasetReference.byPath."
                            throw "No semantic model path for the report."
                        }

                        $pathToCheck = Join-Path $parentFolder $semanticModelPath.path
                        $pbismFile = Get-ChildItem -Path $pathToCheck -Recurse -Include "*.pbism"
                        if ($pbismFile -eq $null) {
                            Write-Error "No .pbism file found for the report's semantic model."
                            throw "Semantic model .pbism not found."
                        }

                        # Re-import the semantic model from the pbism folder
                        $reImportedSM = Import-SemanticModel $($pbismFile.DirectoryName) $workspaceID
                        $semanticModelName = $reImportedSM.displayName
                        $semanticModelId = $reImportedSM.id
                        $finalSemanticModelId = $semanticModelId

                        if (-not $semanticModelId) {
                            Write-Error ("Semantic Model '{0}' not found/created properly. Cannot import report." -f $semanticModelName)
                            throw "Semantic model for the report not found."
                        }

                        Write-Host ("Importing report at {0} to UAT workspace with semantic model ID: {1}" -f $parentFolder, $semanticModelId)
                        try {
                            $promotedItem = Import-FabricItem -workspaceId $workspaceID -path $parentFolder -itemProperties @{ semanticModelId = $semanticModelId }
                            Write-Host "Report imported successfully."
                        } catch {
                            $err = $_
                            Write-Error ("Failed to import report at {0}: {1}" -f $parentFolder, $err)
                            throw $err
                        }
                    }
                }

                # No data refresh or DQV testing as requested
                Write-Host "All changes imported successfully."
                Write-Host "Pipeline completed successfully."

            } catch {
                $err = $_
                Write-Error ("An error occurred: {0}" -f $err)
                throw $err
            }
        env:
          CLIENT_SECRET: $(Clientsecret)
          CLIENT_ID: $(clinetid)
          TENANT_ID: $(tenantid)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)

--------------------------------------------------------------------
BUILD
____________________________________________________________________
trigger:
  branches:
    include:
      - develop

pool:
  vmImage: 'windows-latest'

# Variable group if needed (e.g., for credentials). Not strictly required for CI.
variables:
  - group: 'powerbi'

jobs:
  - job: Build
    displayName: "Power BI Build Pipeline - Archive .pbir & .pbism"

    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      - task: PowerShell@2
        displayName: 'Detect & Archive Artifacts'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Write-Host "=== Detecting Changes ==="
            # All .pbir files changed
            $changedReports = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
            # All .pbism files changed
            $changedModels = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')

            $changedReports = $changedReports | Sort-Object -Unique
            $changedModels  = $changedModels  | Sort-Object -Unique

            $artifactsPath = "$(System.DefaultWorkingDirectory)/artifacts"
            New-Item -ItemType Directory -Force -Path $artifactsPath | Out-Null

            if ($changedReports.Count -eq 0 -and $changedModels.Count -eq 0) {
                Write-Host "No .pbir or .pbism changes detected."
                $placeholder = Join-Path $artifactsPath "NoChanges.txt"
                "No changes detected in this build." | Out-File $placeholder
                exit 0
            }

            # Create subfolders for clarity
            $reportsPath = Join-Path $artifactsPath "Reports"
            $modelsPath  = Join-Path $artifactsPath "SemanticModels"
            New-Item -ItemType Directory -Force -Path $reportsPath | Out-Null
            New-Item -ItemType Directory -Force -Path $modelsPath  | Out-Null

            # -----------------------------------
            # 1) For each changed .pbir, copy the .pbir + its referenced .pbism
            # -----------------------------------
            foreach ($reportRelPath in $changedReports) {
                $sourceReportPath = Join-Path "$(System.DefaultWorkingDirectory)" $reportRelPath
                # Copy the .pbir file itself
                Copy-Item -Path $sourceReportPath -Destination $reportsPath -Force

                # Also parse definition.pbir to find the .pbism reference
                $reportFolder = Split-Path $sourceReportPath -Parent
                $defFile = Join-Path $reportFolder "definition.pbir"
                if (!(Test-Path $defFile)) {
                    Write-Error ("definition.pbir not found at {0}" -f $defFile)
                    throw "Definition file missing."
                }

                $reportDefinition = Get-Content $defFile | ConvertFrom-Json
                $semanticRef = $reportDefinition.datasetReference.byPath
                if (!$semanticRef) {
                    Write-Error "datasetReference.byPath missing in definition.pbir"
                    throw "No semantic model reference."
                }

                # Build the path to the .pbism folder based on the definition
                $modelFolderRel = Join-Path $reportFolder $semanticRef.path
                if (Test-Path $modelFolderRel) {
                    # Copy entire folder containing .pbism
                    $modelFiles = Get-ChildItem -Path $modelFolderRel -Recurse -Include *.pbism -ErrorAction SilentlyContinue
                    if ($modelFiles) {
                        foreach ($mf in $modelFiles) {
                            $modelDest = Join-Path $modelsPath (Split-Path $mf -Leaf)
                            Copy-Item -Path $mf.FullName -Destination $modelDest -Force
                        }
                    } else {
                        Write-Error "Referenced .pbism not found in $modelFolderRel"
                        throw "Semantic model missing for changed report."
                    }
                } else {
                    Write-Error "Referenced semantic model folder does not exist: $modelFolderRel"
                    throw "Semantic model folder missing."
                }
            }

            # -----------------------------------
            # 2) For changed .pbism not already copied via a changed .pbir reference
            #    Just copy those .pbism files individually
            # -----------------------------------
            foreach ($modelRelPath in $changedModels) {
                $sourceModelPath = Join-Path "$(System.DefaultWorkingDirectory)" $modelRelPath
                $destModelPath   = Join-Path $modelsPath (Split-Path $modelRelPath -Leaf)

                # If it's already copied via the .pbir logic above, skip duplication
                if (!(Test-Path $destModelPath)) {
                    Copy-Item -Path $sourceModelPath -Destination $destModelPath -Force
                }
            }

            Write-Host "=== Artifacts prepared in: $artifactsPath ==="

      - task: PublishBuildArtifacts@1
        displayName: 'Publish Artifacts'
        inputs:
          PathtoPublish: '$(System.DefaultWorkingDirectory)/artifacts'
          ArtifactName: 'PowerBIArtifacts'




-----------------------------------------------------------------------------
RELEASE
____________________________________________________________________________

trigger: none

parameters:
  - name: UAT_WORKSPACE_NAME
    type: string
    default: 'YourUATWorkspaceName'
  - name: UAT_ONELAKE_ENDPOINT
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'

pool:
  vmImage: 'windows-latest'

variables:
  - group: 'powerbi'
  - name: UAT_WORKSPACE_NAME
    value: ${{ parameters.UAT_WORKSPACE_NAME }}
  - name: UAT_ONELAKE_ENDPOINT
    value: ${{ parameters.UAT_ONELAKE_ENDPOINT }}

jobs:
  - job: Release
    displayName: "CD Pipeline - Promote Artifacts to UAT"

    steps:
      - checkout: none

      - task: DownloadBuildArtifacts@0
        displayName: "Download Build Artifacts"
        inputs:
          buildType: 'specific'
          project: '$(System.TeamProjectId)'
          definition: 'Power-BI-(CI)'
          buildVersionToDownload: 'latest'
          artifactName: 'PowerBIArtifacts'
          downloadPath: '$(System.DefaultWorkingDirectory)/PowerBIArtifacts'

      - task: PowerShell@2
        displayName: '=== Installing Dependencies ==='
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Write-Host "Installing required modules..."
            Install-Module -Name Az.Accounts -Force -Scope CurrentUser -AllowClobber
            Install-Module -Name MicrosoftPowerBIMgmt -Force -Scope CurrentUser -AllowClobber

            if (-not (Test-Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force | Out-Null
            }

            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              $fileName = Split-Path $_ -Leaf
              $destPath = Join-Path ".\.nuget\custom_modules" $fileName
              Invoke-WebRequest -Uri $_ -OutFile $destPath
            }

      - task: PowerShell@2
        displayName: '=== Promoting Items to UAT ==='
        env:
          CLIENT_SECRET: $(clientsecret)
          CLIENT_ID: $(clinetid)
          TENANT_ID: $(tenantid)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
                $tenantId = $env:TENANT_ID.Trim()

                Write-Host "=== Authenticating ==="
                $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password))

                Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential
                Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId
                Set-FabricAuthToken -servicePrincipalId $env:CLIENT_ID -servicePrincipalSecret $plainTextPwd -tenantId $tenantId -reset

                $artifactRoot = "$(System.DefaultWorkingDirectory)/PowerBIArtifacts/PowerBIArtifacts"
                Write-Host "Artifact root path: $artifactRoot"

                # Function to import semantic model
                function Import-SemanticModel {
                    param(
                        $workspaceId,
                        $modelPath
                    )
                    Write-Host "Processing semantic model from: $modelPath"
                    try {
                        # Get model definition file
                        $modelFile = Get-ChildItem -Path $modelPath -Filter "definition.pbism" -File
                        if (-not $modelFile) {
                            throw "definition.pbism not found in $modelPath"
                        }

                        # Get model name from folder
                        $modelName = Split-Path $modelPath -Leaf
                        Write-Host "Model name: $modelName"
                        Write-Host "Definition file: $($modelFile.FullName)"

                        # Debug: Show file content
                        $modelContent = Get-Content $modelFile.FullName -Raw
                        Write-Host "Model file size: $((Get-Item $modelFile.FullName).Length) bytes"

                        # Import with explicit properties
                        $result = Import-FabricItem `
                            -workspaceId $workspaceId `
                            -path $modelPath `
                            -itemProperties @{
                                displayName = $modelName
                                itemType = "semanticModel"
                            } `
                            -Verbose

                        if ($result) {
                            Write-Host "Successfully imported semantic model: $modelName"
                            return $result
                        } else {
                            throw "Import-FabricItem returned null result"
                        }
                    }
                    catch {
                        Write-Error "Failed to import semantic model from $modelPath`: $_"
                        throw
                    }
                }

                # Function to import report
                function Import-Report {
                    param(
                        $workspaceId,
                        $reportPath,
                        $semanticModelId
                    )
                    Write-Host "Processing report from: $reportPath"
                    try {
                        $reportName = Split-Path $reportPath -Leaf
                        $result = Import-FabricItem `
                            -workspaceId $workspaceId `
                            -path $reportPath `
                            -itemProperties @{
                                displayName = $reportName
                                itemType = "report"
                                semanticModelId = $semanticModelId
                            } `
                            -Verbose

                        Write-Host "Successfully imported report: $reportName"
                        return $result
                    }
                    catch {
                        Write-Error "Failed to import report from $reportPath`: $_"
                        throw
                    }
                }

                Write-Host "=== Getting Workspace ==="
                $workspaceObj = Get-FabricWorkspace -workspaceName $env:UAT_WORKSPACE_NAME
                if (-not $workspaceObj) {
                    throw "UAT workspace not found: $($env:UAT_WORKSPACE_NAME)"
                }
                $workspaceId = $workspaceObj.Id
                Write-Host "Found workspace: $($workspaceObj.Name) ($workspaceId)"

                # Find files
                Write-Host "`n=== Scanning for Files ==="
                $semanticModels = @()
                $reports = @()

                # Look in SemanticModels folder
                $smPath = Join-Path $artifactRoot "SemanticModels"
                if (Test-Path $smPath) {
                    $semanticModels = Get-ChildItem -Path $smPath -Directory
                    Write-Host "Found $($semanticModels.Count) semantic model(s) in SemanticModels folder"
                }

                # Look in Reports folder
                $rptPath = Join-Path $artifactRoot "Reports"
                if (Test-Path $rptPath) {
                    $reports = Get-ChildItem -Path $rptPath -Directory
                    Write-Host "Found $($reports.Count) report(s) in Reports folder"
                }

                $importedModels = @{}

                # Process semantic models
                foreach ($model in $semanticModels) {
                    Write-Host "`n=== Processing Semantic Model: $($model.Name) ==="
                    try {
                        $result = Import-SemanticModel -workspaceId $workspaceId -modelPath $model.FullName
                        if ($result) {
                            $importedModels[$model.Name] = $result.id
                            Write-Host "Added model to imported list with ID: $($result.id)"
                        }
                    }
                    catch {
                        Write-Error "Failed to process semantic model $($model.Name): $_"
                        continue
                    }
                }

                # Process reports
                foreach ($report in $reports) {
                    Write-Host "`n=== Processing Report: $($report.Name) ==="
                    # Find matching model
                    $modelId = $importedModels[$report.Name]
                    if ($modelId) {
                        try {
                            $result = Import-Report -workspaceId $workspaceId -reportPath $report.FullName -semanticModelId $modelId
                            Write-Host "Report processed successfully"
                        }
                        catch {
                            Write-Error "Failed to process report $($report.Name): $_"
                            continue
                        }
                    }
                    else {
                        Write-Warning "No matching semantic model found for report: $($report.Name)"
                    }
                }

                Write-Host "`n=== Deployment Summary ==="
                Write-Host "Successfully processed:"
                Write-Host "- $($importedModels.Count) semantic models"
                Write-Host "- $($reports.Count) reports"

            }
            catch {
                Write-Error "Deployment failed: $_"
                Write-Error $_.ScriptStackTrace
                throw
            }
----------------------------------------------------------------

trigger: none

parameters:
  - name: UAT_WORKSPACE_NAME
    type: string
    default: 'YourUATWorkspaceName'
  - name: UAT_ONELAKE_ENDPOINT
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'

pool:
  vmImage: 'windows-latest'

variables:
  - group: 'powerbi'
  - name: UAT_WORKSPACE_NAME
    value: ${{ parameters.UAT_WORKSPACE_NAME }}
  - name: UAT_ONELAKE_ENDPOINT
    value: ${{ parameters.UAT_ONELAKE_ENDPOINT }}

jobs:
  - job: Release
    displayName: "CD Pipeline - Promote Artifacts to UAT"

    steps:
      - checkout: none

      - task: DownloadBuildArtifacts@0
        displayName: "Download Build Artifacts"
        inputs:
          buildType: 'specific'
          project: '$(System.TeamProjectId)'
          definition: 'Power-BI-(CI)'
          buildVersionToDownload: 'latest'
          artifactName: 'PowerBIArtifacts'
          downloadPath: '$(System.DefaultWorkingDirectory)/PowerBIArtifacts'

      # Install Dependencies with fixed module installation
      - task: PowerShell@2
        displayName: '=== Installing Dependencies ==='
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Write-Host "Setting up PowerShell environment..."
            Set-PSRepository -Name PSGallery -InstallationPolicy Trusted

            Write-Host "Installing required modules..."
            # Install Az module first
            Install-Module -Name Az -Force -AllowClobber -Scope CurrentUser -Repository PSGallery
            Install-Module -Name MicrosoftPowerBIMgmt -Force -AllowClobber -Scope CurrentUser -Repository PSGallery

            # Create directory for custom modules
            if (-not (Test-Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force | Out-Null
            }

            # Download Fabric modules
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              $fileName = Split-Path $_ -Leaf
              $destPath = Join-Path ".\.nuget\custom_modules" $fileName
              Invoke-WebRequest -Uri $_ -OutFile $destPath
            }

            Write-Host "Modules installed successfully"

      - task: PowerShell@2
        displayName: '=== Promoting Items to UAT ==='
        env:
          CLIENT_SECRET: $(clientsecret)
          CLIENT_ID: $(clinetid)
          TENANT_ID: $(tenantid)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                Write-Host "Importing required modules..."
                Import-Module Az.Accounts -Force -ErrorAction Stop
                Import-Module MicrosoftPowerBIMgmt -Force -ErrorAction Stop
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psd1" -Force -ErrorAction Stop

                # Authentication setup
                $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
                $tenantId = $env:TENANT_ID.Trim()

                Write-Host "=== Authenticating ==="
                # Connect to Azure
                Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential -ErrorAction Stop
                Write-Host "Azure connection successful"

                # Get access token
                $context = Get-AzContext
                $token = Get-AzAccessToken -ResourceUrl "https://api.fabric.microsoft.com"
                $accessToken = $token.Token

                # Function to make REST API calls
                function Invoke-FabricAPI {
                    param(
                        [string]$Method,
                        [string]$Endpoint,
                        $Body
                    )
                    
                    $headers = @{
                        'Authorization' = "Bearer $accessToken"
                        'Content-Type' = 'application/json'
                    }
                    
                    $uri = "https://api.fabric.microsoft.com/v1/$Endpoint"
                    Write-Host "Calling $Method $uri"
                    
                    if ($Body) {
                        $jsonBody = $Body | ConvertTo-Json -Depth 100 -Compress
                        $result = Invoke-RestMethod -Uri $uri -Method $Method -Headers $headers -Body $jsonBody
                    }
                    else {
                        $result = Invoke-RestMethod -Uri $uri -Method $Method -Headers $headers
                    }
                    
                    return $result
                }

                # Get workspace
                Write-Host "=== Getting Workspace ==="
                $workspaces = Invoke-FabricAPI -Method GET -Endpoint "workspaces"
                $workspace = $workspaces.value | Where-Object { $_.displayName -eq $env:UAT_WORKSPACE_NAME }
                
                if (-not $workspace) {
                    throw "UAT workspace not found: $($env:UAT_WORKSPACE_NAME)"
                }
                $workspaceId = $workspace.id
                Write-Host "Found workspace: $($workspace.displayName) ($workspaceId)"

                # Track imported models
                $ImportedModels = @{}

                # Process semantic models
                Write-Host "`n=== Processing Semantic Models ==="
                $artifactRoot = "$(System.DefaultWorkingDirectory)/PowerBIArtifacts/PowerBIArtifacts"
                $semanticModelsPath = Join-Path $artifactRoot "SemanticModels"
                
                Write-Host "Looking for semantic models in: $semanticModelsPath"
                if (Test-Path $semanticModelsPath) {
                    $modelFolders = Get-ChildItem -Path $semanticModelsPath -Directory
                    Write-Host "Found $($modelFolders.Count) potential model folder(s)"
                    
                    foreach ($modelFolder in $modelFolders) {
                        Write-Host "Processing model: $($modelFolder.Name)"
                        
                        $definitionFile = Join-Path $modelFolder.FullName "definition.pbism"
                        if (Test-Path $definitionFile) {
                            try {
                                Write-Host "Reading model definition from: $definitionFile"
                                $modelContent = Get-Content $definitionFile -Raw
                                
                                # Prepare request body
                                $modelBody = @{
                                    displayName = $modelFolder.Name
                                    definition = $modelContent
                                }
                                
                                # Import model
                                $modelResult = Invoke-FabricAPI `
                                    -Method POST `
                                    -Endpoint "workspaces/$workspaceId/semanticmodels" `
                                    -Body $modelBody
                                
                                Write-Host "Successfully imported model: $($modelFolder.Name)"
                                $ImportedModels[$modelFolder.Name] = $modelResult.id
                            }
                            catch {
                                Write-Error "Failed to import model $($modelFolder.Name): $_"
                                continue
                            }
                        }
                        else {
                            Write-Warning "No definition.pbism found in $($modelFolder.FullName)"
                        }
                    }
                }
                else {
                    Write-Warning "SemanticModels directory not found at: $semanticModelsPath"
                }

                # Process reports
                Write-Host "`n=== Processing Reports ==="
                $reportsPath = Join-Path $artifactRoot "Reports"
                
                Write-Host "Looking for reports in: $reportsPath"
                if (Test-Path $reportsPath) {
                    $reportFolders = Get-ChildItem -Path $reportsPath -Directory
                    Write-Host "Found $($reportFolders.Count) potential report folder(s)"
                    
                    foreach ($reportFolder in $reportFolders) {
                        Write-Host "Processing report: $($reportFolder.Name)"
                        
                        $definitionFile = Join-Path $reportFolder.FullName "definition.pbir"
                        if (Test-Path $definitionFile) {
                            try {
                                Write-Host "Reading report definition from: $definitionFile"
                                $reportContent = Get-Content $definitionFile -Raw
                                
                                # Get associated model ID
                                $modelId = $ImportedModels[$reportFolder.Name]
                                if ($modelId) {
                                    # Prepare request body
                                    $reportBody = @{
                                        displayName = $reportFolder.Name
                                        definition = $reportContent
                                        semanticModelId = $modelId
                                    }
                                    
                                    # Import report
                                    $reportResult = Invoke-FabricAPI `
                                        -Method POST `
                                        -Endpoint "workspaces/$workspaceId/reports" `
                                        -Body $reportBody
                                    
                                    Write-Host "Successfully imported report: $($reportFolder.Name)"
                                }
                                else {
                                    Write-Warning "No matching semantic model found for report: $($reportFolder.Name)"
                                }
                            }
                            catch {
                                Write-Error "Failed to import report $($reportFolder.Name): $_"
                                continue
                            }
                        }
                        else {
                            Write-Warning "No definition.pbir found in $($reportFolder.FullName)"
                        }
                    }
                }
                else {
                    Write-Warning "Reports directory not found at: $reportsPath"
                }

                Write-Host "`n=== Deployment Summary ==="
                Write-Host "Successfully processed:"
                Write-Host "- $($ImportedModels.Count) semantic models"
                Write-Host "- $($reportFolders.Count) reports"

            }
            catch {
                Write-Error "Deployment failed: $_"
                Write-Error $_.ScriptStackTrace
                throw
            }

-------------------------------------------


trigger: none

parameters:
  - name: UAT_WORKSPACE_NAME
    type: string
    default: 'YourUATWorkspaceName'
  - name: UAT_ONELAKE_ENDPOINT
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'

pool:
  vmImage: 'windows-latest'

variables:
  - group: 'powerbi'
  - name: UAT_WORKSPACE_NAME
    value: ${{ parameters.UAT_WORKSPACE_NAME }}
  - name: UAT_ONELAKE_ENDPOINT
    value: ${{ parameters.UAT_ONELAKE_ENDPOINT }}

jobs:
  - job: Release
    displayName: "CD Pipeline - Promote Artifacts to UAT"
    steps:
      - checkout: none

      - task: DownloadBuildArtifacts@0
        displayName: "Download Build Artifacts"
        inputs:
          buildType: 'specific'
          project: '$(System.TeamProjectId)'
          definition: 'Power-BI-(CI)'
          buildVersionToDownload: 'latest'
          artifactName: 'PowerBIArtifacts'
          downloadPath: '$(System.DefaultWorkingDirectory)/PowerBIArtifacts'

      # Install Dependencies
      - task: PowerShell@2
        displayName: '=== Installing Dependencies ==='
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Write-Host "Setting up PowerShell environment..."
            Set-PSRepository -Name PSGallery -InstallationPolicy Trusted

            Write-Host "Installing required modules..."
            Install-Module -Name Az -Force -AllowClobber -Scope CurrentUser -Repository PSGallery
            Install-Module -Name MicrosoftPowerBIMgmt -Force -AllowClobber -Scope CurrentUser -Repository PSGallery

            # Create directory for custom modules
            if (-not (Test-Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force | Out-Null
            }

            # Download Fabric modules
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              $fileName = Split-Path $_ -Leaf
              $destPath = Join-Path ".\.nuget\custom_modules" $fileName
              Invoke-WebRequest -Uri $_ -OutFile $destPath
            }

            Write-Host "Modules installed successfully"

     - task: PowerShell@2
  displayName: '=== Promoting Items to UAT ==='
  env:
    CLIENT_SECRET: $(clientsecret)
    CLIENT_ID: $(clinetid)
    TENANT_ID: $(tenantid)
    UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
    UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)
  inputs:
    pwsh: true
    targetType: inline
    script: |
      try {
          # Import modules
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
          Import-Module Az.Accounts -Force
          Import-Module MicrosoftPowerBIMgmt -Force

          # Credentials setup
          $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
          $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
          $tenantId = $env:TENANT_ID.Trim()

          Write-Host "=== Authenticating to Fabric ==="
          $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
          $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)
          
          # Determine if service principal
          $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
          $isServicePrincipal = $false
          if ($credential.UserName -match $guidRegex) {
            $isServicePrincipal = $true
          }

          if ($isServicePrincipal) {
            Set-FabricAuthToken -servicePrincipalId $credential.UserName `
              -servicePrincipalSecret $plainTextPwd `
              -tenantId $tenantId -reset
          } else {
            Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
          }

          $authToken = Get-FabricAuthToken
          if (-not $authToken) {
            Write-Error "Authentication to Fabric failed."
            throw "Fabric authentication failed."
          }

          Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential

          Write-Host "=== Authenticating to OneLake with AzCopy ==="
          $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
          $oneLakeUri = New-Object System.Uri("$($env:UAT_ONELAKE_ENDPOINT)".Trim())
          $oneLakeDomain = $oneLakeUri.Host
          $loginResult = azcopy login --service-principal --application-id $credential.UserName --tenant-id $tenantId --trusted-microsoft-suffixes="$oneLakeDomain" --output-type json | ConvertFrom-Json
          $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }
          if (!$checkResult) {
            Write-Error "AzCopy authentication failed."
            throw "AzCopy login failed."
          }

          Write-Host "=== Connecting to Power BI Service ==="
          if ($isServicePrincipal) {
            Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop
          } else {
            Connect-PowerBIServiceAccount -Credential $credential -TenantId $tenantId -ErrorAction Stop
          }

          Write-Host "=== Retrieving UAT Workspace ==="
          $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
          if (-not $workspaceObj) {
              Write-Error ("UAT workspace '{0}' not found." -f $env:UAT_WORKSPACE_NAME)
              throw "Workspace not found."
          }
          $workspaceID = $workspaceObj.Id

          # Set the root directory where artifacts are located
          $downloadRoot = "$(System.DefaultWorkingDirectory)/PowerBIArtifacts"
          Write-Host "Artifacts root: $downloadRoot"

          # Find semantic model and report files
          $allPbismFiles = Get-ChildItem -Path $downloadRoot -Filter "*.pbism" -Recurse
          $allPbirFiles = Get-ChildItem -Path $downloadRoot -Filter "*.pbir" -Recurse

          if ($allPbismFiles.Count -eq 0 -and $allPbirFiles.Count -eq 0) {
              Write-Host "No semantic model or report files found in artifacts. Nothing to promote."
              exit 0
          }

          function Import-SemanticModel([string]$modelFolderPath, [string]$workspaceID) {
              # Find the pbism file in this folder
              $pbismFile = Get-ChildItem -Path $modelFolderPath -Filter "*.pbism" -File -Recurse | Select-Object -First 1
              if (-not $pbismFile) {
                  Write-Error ("No .pbism file found in folder {0}" -f $modelFolderPath)
                  throw "Semantic model definition not found."
              }

              $definition = Get-Content $pbismFile.FullName -Raw
              $modelName = Split-Path $modelFolderPath -Leaf
              Write-Host ("Importing semantic model '{0}' from {1}" -f $modelName, $modelFolderPath)

              try {
                  $smItem = Import-FabricItem -workspaceId $workspaceID -path $modelFolderPath -itemProperties @{
                      itemType = "SemanticModel"
                      displayName = $modelName
                      definition = $definition
                  }
                  Write-Host "Semantic model imported successfully: $($smItem.displayName)"
                  return $smItem
              } catch {
                  Write-Error ("Failed to import semantic model at {0}: {1}" -f $modelFolderPath, $_)
                  throw
              }
          }

          function Import-Report([string]$reportFolder, [string]$workspaceID, $semanticModelId = $null) {
              $reportName = Split-Path $reportFolder -Leaf
              
              # definition.pbir should contain the report definition if present
              $definitionFile = Get-ChildItem -Path $reportFolder -Filter "definition.pbir" -ErrorAction SilentlyContinue
              $reportDefinition = $null
              if ($definitionFile) {
                  $reportDefinition = Get-Content $definitionFile.FullName -Raw
              } else {
                  # If no definition file named definition.pbir, try any *.pbir file as the definition
                  $pbirFile = Get-ChildItem -Path $reportFolder -Filter "*.pbir" -File -Recurse | Where-Object { $_.Name -ne "definition.pbir" } | Select-Object -First 1
                  if (-not $pbirFile) {
                      Write-Error ("No report definition found in {0}" -f $reportFolder)
                      throw "Report definition not found."
                  }
                  $reportDefinition = Get-Content $pbirFile.FullName -Raw
              }

              Write-Host ("Importing report '{0}' from {1}" -f $reportName, $reportFolder)
              $itemProps = @{
                  itemType = "Report"
                  displayName = $reportName
                  definition = $reportDefinition
              }
              if ($semanticModelId) {
                  $itemProps.Add("semanticModelId", $semanticModelId)
              }

              try {
                  $promotedItem = Import-FabricItem -workspaceId $workspaceID -path $reportFolder -itemProperties $itemProps
                  Write-Host "Report imported successfully: $($promotedItem.displayName)"
              } catch {
                  Write-Error ("Failed to import report at {0}: {1}" -f $reportFolder, $_)
                  throw
              }
          }

          # Import semantic models
          Write-Host "`n=== Importing Semantic Models ==="
          $importedModels = [System.Collections.Generic.Dictionary[string,object]]::new()
          foreach ($modelFile in $allPbismFiles) {
              $modelFolder = $modelFile.DirectoryName
              if (-not $importedModels.ContainsKey($modelFolder)) {
                  $smImported = Import-SemanticModel $modelFolder $workspaceID
                  if ($smImported) {
                      $importedModels[$modelFolder] = $smImported
                  }
              }
          }

          # Import reports
          Write-Host "`n=== Importing Reports ==="
          if ($allPbirFiles.Count -gt 0) {
              foreach ($reportFile in $allPbirFiles) {
                  $reportFolder = $reportFile.DirectoryName
                  # Attempt to find a semantic model reference from definition.pbir if present
                  $definitionFile = Get-ChildItem -Path $reportFolder -Filter "definition.pbir" -ErrorAction SilentlyContinue
                  $semanticModelId = $null
                  if ($definitionFile) {
                      $reportDef = (Get-Content $definitionFile.FullName -Raw) | ConvertFrom-Json
                      $semanticModelRef = $reportDef?.datasetReference?.byPath?.path
                      if ($semanticModelRef) {
                          # semanticModelRef is relative
                          $smFullPath = Join-Path $reportFolder $semanticModelRef
                          $pbismRefFile = Get-ChildItem -Path $smFullPath -Filter "*.pbism" -Recurse -ErrorAction SilentlyContinue
                          if ($pbismRefFile) {
                              $smFolderForReport = $pbismRefFile.DirectoryName
                              # Import/Refresh semantic model for the report
                              $smImportedForReport = Import-SemanticModel $smFolderForReport $workspaceID
                              $semanticModelId = $smImportedForReport.id
                          }
                      }
                  }

                  # Import the report now that we possibly have a semantic model ID
                  Import-Report $reportFolder $workspaceID $semanticModelId
              }
          } else {
              Write-Host "No reports found."
          }

          Write-Host "`n=== Deployment Summary ==="
          Write-Host "Semantic models imported: $($importedModels.Count)"
          Write-Host "Reports imported: $($allPbirFiles.Count)"
          Write-Host "Deployment completed successfully."

      } catch {
          $err = $_
          Write-Error ("An error occurred: {0}" -f $err)
          throw $err
      }
-------------------------------------------------------------------------


- task: PowerShell@2
  displayName: "=== Promote PBIX Artifacts to UAT (Using MicrosoftPowerBIMgmt) ==="
  env:
    CLIENT_SECRET: "$(clientsecret)"
    CLIENT_ID: "$(clinetid)"
    TENANT_ID: "$(tenantid)"
    UAT_WORKSPACE_NAME: "$(UAT_WORKSPACE_NAME)"
    SYSTEM_DEFAULTWORKINGDIRECTORY: "$(System.DefaultWorkingDirectory)"
  inputs:
    pwsh: true
    targetType: inline
    script: |
      try {
          Write-Host "=== Starting Promotion to UAT with PBIX files using MicrosoftPowerBIMgmt ==="

          Write-Host "=== Debugging Inputs ==="
          Write-Host "CLIENT_ID: $env:CLIENT_ID"
          Write-Host "TENANT_ID: $env:TENANT_ID"
          Write-Host "UAT_WORKSPACE_NAME: $env:UAT_WORKSPACE_NAME"
          Write-Host "SYSTEM_DEFAULTWORKINGDIRECTORY: $env:SYSTEM_DEFAULTWORKINGDIRECTORY"

          Write-Host "=== Loading MicrosoftPowerBIMgmt Modules ==="
          # If needed, uncomment the following line to ensure modules are available:
          # Install-Module MicrosoftPowerBIMgmt -Scope CurrentUser -Force
          Import-Module MicrosoftPowerBIMgmt.Profile -Force
          Import-Module MicrosoftPowerBIMgmt.Reports -Force
          Import-Module MicrosoftPowerBIMgmt.Workspaces -Force
          # Additional modules available: MicrosoftPowerBIMgmt.Data, MicrosoftPowerBIMgmt.Admin, etc., if needed.

          Write-Host "=== Setting up Credentials ==="
          $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
          $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
          $tenantId = $env:TENANT_ID.Trim()

          Write-Host "=== Connecting to Power BI Service ==="
          # Service principal authentication requires TenantId
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop
          Write-Host "Connected to Power BI Service successfully."

          Write-Host "=== Retrieving UAT Workspace ==="
          $workspace = Get-PowerBIWorkspace -Name $env:UAT_WORKSPACE_NAME -First 1
          if (-not $workspace) {
              Write-Error ("UAT workspace '{0}' not found." -f $env:UAT_WORKSPACE_NAME)
              throw "Workspace not found."
          }
          $workspaceId = $workspace.Id
          Write-Host "Workspace found: $($workspace.Name) ($workspaceId)"

          Write-Host "=== Listing PBIX Artifacts ==="
          $downloadRoot = "$env:SYSTEM_DEFAULTWORKINGDIRECTORY/PowerBIArtifacts"
          $pbixFiles = Get-ChildItem -Path $downloadRoot -Recurse -Filter *.pbix

          if (!$pbixFiles -or $pbixFiles.Count -eq 0) {
              Write-Host "No PBIX files found. Nothing to promote."
              exit 0
          } else {
              $pbixFiles | ForEach-Object { Write-Host "Found PBIX artifact: $($_.FullName)" }
          }

          Write-Host "=== Importing PBIX Files into UAT Workspace ==="
          foreach ($pbix in $pbixFiles) {
              Write-Host "Importing PBIX: $($pbix.FullName)"
              try {
                  # Add-PowerBIReport imports a PBIX file as a report
                  # If the PBIX contains a dataset, it will also be included
                  $reportName = $pbix.BaseName
                  $importedReport = Add-PowerBIReport -Path $pbix.FullName -WorkspaceId $workspaceId -Name $reportName
                  
                  if ($importedReport) {
                      Write-Host "Imported PBIX successfully: $($importedReport.Name) (Report ID: $($importedReport.Id))"
                  } else {
                      Write-Error "No report returned from Add-PowerBIReport."
                      throw "Import failed for $($pbix.FullName)."
                  }
              } catch {
                  Write-Error "Failed to import PBIX file via MicrosoftPowerBIMgmt"
                  Write-Error $_.Exception.Message
                  throw
              }
          }

          Write-Host "All PBIX files imported successfully."
          Write-Host "Pipeline completed successfully."
      } catch {
          Write-Error "An error occurred: $($_.Exception.Message)"
          throw
      }
------------------------------------------------------------------------
FINAL TRY
___________________________________________________________________________
CI
___________________________________________________
trigger:
  - main

pool:
  vmImage: 'windows-latest'

jobs:
  - job: BuildAndArchive
    displayName: "CI - Build and Publish PBISM/PBIR Artifacts"

    steps:
      ########################################################################
      # Step 1: Check out source code
      ########################################################################
      - checkout: self
        persistCredentials: true

      ########################################################################
      # Step 2: Install Dependencies
      ########################################################################
      - task: PowerShell@2
        displayName: "Install Dependencies (CI)"
        inputs:
          pwsh: true
          targetType: inline
        script: |
          Write-Host "=== [CI] Setting up PowerShell environment ==="
          Set-PSRepository -Name 'PSGallery' -InstallationPolicy Trusted

          Write-Host "=== [CI] Installing Required Modules ==="
          Install-Module Az -Scope CurrentUser -Force -AllowClobber
          Install-Module MicrosoftPowerBIMgmt -Scope CurrentUser -Force -AllowClobber

          # Optional: Download FabricPS-PBIP
          if (-not (Test-Path ".\.nuget\custom_modules")) {
            New-Item -ItemType Directory -Path ".\.nuget\custom_modules" | Out-Null
          }
          $fabricModuleUrl = "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1"
          Invoke-WebRequest `
            -Uri $fabricModuleUrl `
            -OutFile ".\.nuget\custom_modules\FabricPS-PBIP.psm1"

          Write-Host "=== [CI] Modules Installed ==="

      ########################################################################
      # Step 3: Detect & Copy Changed PBISM/PBIR Files
      ########################################################################
      - task: PowerShell@2
        displayName: "Detect and Archive PBISM/PBIR Changes"
        inputs:
          pwsh: true
          targetType: inline
        script: |
          Write-Host "=== [CI] Detecting PBISM and PBIR files via git diff ==="

          $pbismChanges = git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism'
          $pbirChanges  = git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir'

          $pbismList = $pbismChanges | Sort-Object -Unique
          $pbirList  = $pbirChanges  | Sort-Object -Unique

          Write-Host "PBISM changed files:"
          $pbismList | ForEach-Object { Write-Host "- $_" }
          Write-Host "PBIR changed files:"
          $pbirList  | ForEach-Object { Write-Host "- $_" }

          if (($pbismList.Count -eq 0) -and ($pbirList.Count -eq 0)) {
            Write-Host "No PBISM/PBIR changes detected."
          }

          $artifactFolder = "$(Build.SourcesDirectory)\ChangedArtifacts"
          if (-not (Test-Path $artifactFolder)) {
            New-Item -ItemType Directory -Path $artifactFolder | Out-Null
          }

          foreach ($file in $pbismList + $pbirList) {
            $src = Join-Path "$(Build.SourcesDirectory)" $file
            if (Test-Path $src) {
              Write-Host "Copying file: $src"
              $dest = Join-Path $artifactFolder $file
              $destDir = Split-Path $dest -Parent
              if (-not (Test-Path $destDir)) {
                New-Item -ItemType Directory -Path $destDir | Out-Null
              }
              Copy-Item $src -Destination $dest
            }
          }

          Write-Host "=== [CI] Files copied to artifact folder: $artifactFolder ==="

      ########################################################################
      # Step 4: Publish the Artifact
      ########################################################################
      - task: PublishBuildArtifacts@1
        displayName: "Publish PBISM/PBIR Artifacts"
        inputs:
          PathtoPublish: "$(Build.SourcesDirectory)\ChangedArtifacts"
          ArtifactName: "PowerBIArtifacts"
          publishLocation: "Container"

----------------------------------------------------------------
CD
______________________________________________________

trigger: none  # or specify how you want to trigger the CD pipeline

# Reference the CI pipeline so we can download the published artifacts
resources:
  pipelines:
  - pipeline: CI_Pipeline
    source: "<YOUR-CI-PIPELINE-NAME>"
    # Example: 
    # branch: main
    # trigger: true
    # Adjust as needed

pool:
  vmImage: 'windows-latest'

stages:
- stage: CD
  displayName: "Promote Artifacts to UAT"
  jobs:
  - job: DeployToUAT
    displayName: "CD - Import PBISM/PBIR to UAT"
    steps:
      ########################################################################
      # Step 1: Download Artifacts from the CI Pipeline
      ########################################################################
      - task: DownloadPipelineArtifact@2
        displayName: "Download PBISM/PBIR Artifacts"
        inputs:
          buildType: "specific"
          project: "$(System.TeamProjectId)"
          pipeline: "$(CI_Pipeline.pipelineId)" # references the pipeline resource above
          artifact: "PowerBIArtifacts"
          path: "$(System.DefaultWorkingDirectory)/PowerBIArtifacts"

      ########################################################################
      # Step 2: Install Dependencies (CD)
      ########################################################################
      - task: PowerShell@2
        displayName: "Install Dependencies (CD)"
        inputs:
          pwsh: true
          targetType: inline
        script: |
          Write-Host "=== [CD] Installing Modules ==="
          Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
          Install-Module Az -Scope CurrentUser -Force -AllowClobber
          Install-Module MicrosoftPowerBIMgmt -Scope CurrentUser -Force -AllowClobber

          if (-not (Test-Path ".\.nuget\custom_modules")) {
            New-Item -ItemType Directory -Path ".\.nuget\custom_modules" | Out-Null
          }
          $fabricModuleUrl = "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1"
          Invoke-WebRequest -Uri $fabricModuleUrl -OutFile ".\.nuget\custom_modules\FabricPS-PBIP.psm1"

          Write-Host "=== [CD] Modules Installed Successfully ==="

      ########################################################################
      # Step 3: Promote to UAT with itemType, displayName
      ########################################################################
      - task: PowerShell@2
        displayName: "Promote PBISM/PBIR to UAT (with itemType/displayName)"
        env:
          CLIENT_SECRET: "$(clientsecret)"
          CLIENT_ID: "$(clinetid)"
          TENANT_ID: "$(tenantid)"
          UAT_WORKSPACE_NAME: "$(UAT_WORKSPACE_NAME)"
          UAT_ONELAKE_ENDPOINT: "$(UAT_ONELAKE_ENDPOINT)"
        inputs:
          pwsh: true
          targetType: inline
        script: |
          try {
              $DebugPreference = "Continue"
              Write-Host "=== [CD] Starting UAT Promotion ==="

              # Print environment variables
              Write-Host "CLIENT_ID: $env:CLIENT_ID"
              Write-Host "TENANT_ID: $env:TENANT_ID"
              Write-Host "UAT_WORKSPACE_NAME: $env:UAT_WORKSPACE_NAME"

              ########################################################################
              # A) Credentials
              ########################################################################
              $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
              $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
              $tenantId = $env:TENANT_ID.Trim()

              # Determine if service principal
              $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
              $isServicePrincipal = $false
              if ($credential.UserName -match $guidRegex) {
                $isServicePrincipal = $true
              }

              ########################################################################
              # B) Fabric Authentication
              ########################################################################
              Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
              Write-Host "=== [CD] Authenticating to Fabric ==="
              $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
              $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

              if ($isServicePrincipal) {
                Set-FabricAuthToken -ServicePrincipalId $credential.UserName -ServicePrincipalSecret $plainTextPwd -TenantId $tenantId -Reset
              } else {
                Set-FabricAuthToken -Credential $credential -TenantId $tenantId -Reset
              }
              $authToken = Get-FabricAuthToken
              if (-not $authToken) {
                Write-Error "Fabric authentication failed."
                throw "Fabric authentication failed."
              }

              ########################################################################
              # C) Azure & OneLake Auth
              ########################################################################
              Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential -ErrorAction Stop
              Write-Host "=== [CD] Authenticating to OneLake with AzCopy ==="
              $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
              $oneLakeUri = New-Object System.Uri("$($env:UAT_ONELAKE_ENDPOINT)".Trim())
              $oneLakeDomain = $oneLakeUri.Host
              $loginResult = azcopy login --service-principal --application-id $credential.UserName --tenant-id $tenantId --trusted-microsoft-suffixes="$oneLakeDomain" --output-type json | ConvertFrom-Json
              $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }
              if (!$checkResult) {
                Write-Error "AzCopy authentication failed."
                throw "AzCopy login failed."
              }

              ########################################################################
              # D) Power BI Service Auth
              ########################################################################
              Write-Host "=== [CD] Connecting to Power BI Service ==="
              if ($isServicePrincipal) {
                Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop
              } else {
                Connect-PowerBIServiceAccount -Credential $credential -TenantId $tenantId -ErrorAction Stop
              }

              ########################################################################
              # E) List artifacts
              ########################################################################
              $downloadRoot = "$(System.DefaultWorkingDirectory)/PowerBIArtifacts"
              Write-Host "Artifacts root: $downloadRoot"
              $allFiles = Get-ChildItem -Path $downloadRoot -Recurse
              if (-not $allFiles -or $allFiles.Count -eq 0) {
                Write-Host "No .pbism or .pbir artifacts found. Nothing to import."
                exit 0
              }

              Write-Host "Listing all artifacts found:"
              $allFiles | ForEach-Object { Write-Host " - $($_.FullName)" }

              ########################################################################
              # F) Retrieve UAT Workspace
              ########################################################################
              Write-Host "=== [CD] Retrieving UAT Workspace ==="
              $workspaceObj = Get-FabricWorkspace -WorkspaceName "$($env:UAT_WORKSPACE_NAME)"
              if (-not $workspaceObj) {
                Write-Error ("UAT workspace '{0}' not found." -f $env:UAT_WORKSPACE_NAME)
                throw "Workspace not found."
              }
              $workspaceID = $workspaceObj.Id
              Write-Host "Workspace found: $($workspaceObj.DisplayName) ($workspaceID)"

              ########################################################################
              # G) Import PBISM (Semantic Models) with itemType/displayName
              ########################################################################
              Write-Host "=== [CD] Importing PBISM Files with itemType/displayName ==="
              $pbismFiles = $allFiles | Where-Object { -not $_.PSIsContainer -and $_.Extension -eq ".pbism" }
              foreach ($pbism in $pbismFiles) {
                $modelFolder = $pbism.DirectoryName
                $modelName = Split-Path $modelFolder -Leaf
                Write-Host "Importing semantic model from folder: $modelFolder"

                $smProps = @{
                  itemType    = "SemanticModel"
                  displayName = $modelName
                }

                try {
                  $resultSM = Import-FabricItem -WorkspaceId $workspaceID -Path $modelFolder -itemProperties $smProps -ErrorAction Stop
                  Write-Host "Semantic model imported: $($resultSM.displayName) (ID: $($resultSM.id))"
                } catch {
                  Write-Error "Error importing semantic model from $modelFolder:"
                  Write-Error $_.Exception.Message
                  throw
                }
              }

              ########################################################################
              # H) Import PBIR (Reports) with itemType/displayName
              ########################################################################
              Write-Host "=== [CD] Importing PBIR Files with itemType/displayName ==="
              $pbirFiles = $allFiles | Where-Object { -not $_.PSIsContainer -and $_.Extension -eq ".pbir" }
              foreach ($pbir in $pbirFiles) {
                $reportFolder = $pbir.DirectoryName
                $reportName = Split-Path $reportFolder -Leaf
                Write-Host "Importing report from folder: $reportFolder"

                # Potentially parse definition.pbir if needed for semanticModelId resolution
                $rptProps = @{
                  itemType    = "Report"
                  displayName = $reportName
                }

                try {
                  $resultRpt = Import-FabricItem -WorkspaceId $workspaceID -Path $reportFolder -itemProperties $rptProps
                  Write-Host "Report imported successfully: $($resultRpt.displayName)"
                } catch {
                  Write-Error "Error importing report from $reportFolder:"
                  Write-Error $_.Exception.Message
                  throw
                }
              }

              Write-Host "=== [CD] Promotion to UAT completed successfully ==="
              exit 0

          } catch {
              Write-Error "=== [CD] A Fatal Error Occurred ==="
              Write-Error $_.Exception.Message
              throw
          }
-------------------------------------------------

trigger: none

parameters:
  - name: UAT_WORKSPACE_NAME
    type: string
    default: 'YourUATWorkspaceName'
  - name: UAT_ONELAKE_ENDPOINT
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'

pool:
  vmImage: 'windows-latest'

variables:
  - group: 'powerbi'
  - name: UAT_WORKSPACE_NAME
    value: ${{ parameters.UAT_WORKSPACE_NAME }}
  - name: UAT_ONELAKE_ENDPOINT
    value: ${{ parameters.UAT_ONELAKE_ENDPOINT }}

jobs:
  - job: Release
    displayName: "CD Pipeline - Promote Artifacts to UAT"
    steps:
      - checkout: none

      # Download Artifacts
      - task: DownloadBuildArtifacts@0
        displayName: "Download Build Artifacts"
        inputs:
          buildType: 'specific'
          project: '$(System.TeamProjectId)'
          definition: 'Power-BI-(CI)'
          buildVersionToDownload: 'latest'
          artifactName: 'PowerBIArtifacts'
          downloadPath: '$(System.DefaultWorkingDirectory)/PowerBIArtifacts'

      # Install Dependencies
      - task: PowerShell@2
        displayName: 'Install Dependencies'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Write-Host "=== Installing Required Modules ==="
            Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
            Install-Module -Name Az -Force -AllowClobber -Scope CurrentUser
            Install-Module -Name MicrosoftPowerBIMgmt -Force -AllowClobber -Scope CurrentUser

      # Authenticate and Debug Credentials
- task: PowerShell@2
  displayName: "Authenticate and Debug Credentials"
  env:
    CLIENT_SECRET: "$(clientsecret)"
    CLIENT_ID: "$(clientid)"
    TENANT_ID: "$(tenantid)"
  inputs:
    pwsh: true
    targetType: inline
    script: |
      try {
          $DebugPreference = "Continue"
          Write-Host "=== [Auth Debug] Starting Authentication ==="

          # Unload AzureRM to avoid conflicts
          Write-Host "Unloading AzureRM Module (if present)"
          Get-Module -Name AzureRM -ListAvailable | Remove-Module -Force -ErrorAction SilentlyContinue

          # Debugging environment variables
          Write-Host "Environment Variables:"
          Write-Host " - ClientId: $env:CLIENT_ID"
          Write-Host " - TenantId: $env:TENANT_ID"

          # Convert CLIENT_SECRET to secure string
          $secureSecret = ConvertTo-SecureString $env:CLIENT_SECRET -AsPlainText -Force
          $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secureSecret)

          # Authenticate to Azure
          Write-Host "Authenticating to Azure..."
          Connect-AzAccount -ServicePrincipal -Tenant $env:TENANT_ID -Credential $credential -Scope "https://management.azure.com/.default" -ErrorAction Stop
          Write-Host "Azure Authentication Successful"

          # Authenticate to Power BI
          Write-Host "Authenticating to Power BI..."
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $env:TENANT_ID -ErrorAction Stop
          Write-Host "Power BI Authentication Successful"

          Write-Host "=== [Auth Debug] Authentication Completed ==="
      } catch {
          Write-Error "Authentication Failed"
          Write-Error $_.Exception.Message
          throw $_
      }


      # Promote Artifacts to UAT
      - task: PowerShell@2
        displayName: "Promote PBISM/PBIR to UAT"
        env:
          CLIENT_SECRET: "$(clientsecret)"
          CLIENT_ID: "$(clientid)"
          TENANT_ID: "$(tenantid)"
          UAT_WORKSPACE_NAME: "$(UAT_WORKSPACE_NAME)"
          UAT_ONELAKE_ENDPOINT: "$(UAT_ONELAKE_ENDPOINT)"
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
              Write-Host "=== Starting Promotion to UAT ==="
              
              # Load Artifacts
              $downloadRoot = "$(System.DefaultWorkingDirectory)/PowerBIArtifacts"
              $allFiles = Get-ChildItem -Path $downloadRoot -Recurse
              if (-not $allFiles -or $allFiles.Count -eq 0) {
                Write-Host "No artifacts found. Exiting."
                exit 0
              }

              # Retrieve UAT Workspace
              Write-Host "Retrieving UAT Workspace"
              $workspaceObj = Get-FabricWorkspace -WorkspaceName $env:UAT_WORKSPACE_NAME
              if (-not $workspaceObj) {
                throw "UAT Workspace not found"
              }

              # Promote Semantic Models
              Write-Host "Importing Semantic Models"
              $pbismFiles = $allFiles | Where-Object { $_.Extension -eq ".pbism" }
              foreach ($pbism in $pbismFiles) {
                Write-Host "Importing: $($pbism.FullName)"
                Import-FabricItem -WorkspaceId $workspaceObj.Id -Path $pbism.FullName -ItemType "SemanticModel" -DisplayName $pbism.BaseName
              }

              # Promote Reports
              Write-Host "Importing Reports"
              $pbirFiles = $allFiles | Where-Object { $_.Extension -eq ".pbir" }
              foreach ($pbir in $pbirFiles) {
                Write-Host "Importing: $($pbir.FullName)"
                Import-FabricItem -WorkspaceId $workspaceObj.Id -Path $pbir.FullName -ItemType "Report" -DisplayName $pbir.BaseName
              }

              Write-Host "=== Promotion to UAT Completed Successfully ==="
            } catch {
              Write-Error "Promotion Failed"
              Write-Error $_.Exception.Message
              throw $_
            }


______________________________________________________


parameters:
  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'

trigger: none

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Authenticate
    displayName: "Authenticate to Azure, Fabric, and Power BI"
    steps:
      - checkout: none

      - task: PowerShell@2
        displayName: "Authenticate and Debug Credentials"
        inputs:
          pwsh: true
          targetType: inline
        script: |
          try {
              $DebugPreference = "Continue"
              Write-Host "=== Starting Authentication Debug ==="

              # Remove conflicting modules if present
              Write-Host "Unloading conflicting AzureRM modules..."
              Get-Module -Name AzureRM* -ListAvailable | Remove-Module -Force -ErrorAction SilentlyContinue

              # Import required modules
              Import-Module MicrosoftPowerBIMgmt -Force
              Import-Module Az.Accounts -Force
              Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force

              # Debugging environment variables
              Write-Host "ClientId: $env:CLIENT_ID"
              Write-Host "TenantId: $env:TENANT_ID"

              # Convert CLIENT_SECRET to secure string
              $secureSecret = ConvertTo-SecureString $env:CLIENT_SECRET -AsPlainText -Force
              $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secureSecret)
              $tenantId = $env:TENANT_ID.Trim()

              # Authenticate to Azure
              Write-Host "Authenticating to Azure..."
              Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential -ErrorAction Stop
              Write-Host "Azure Authentication Successful."

              # Authenticate to OneLake using AzCopy
              Write-Host "Authenticating to OneLake with AzCopy..."
              $env:AZCOPY_SPA_CLIENT_SECRET = $secureSecret
              $oneLakeUri = New-Object System.Uri("$($env:UAT_ONELAKE_ENDPOINT)".Trim())
              $oneLakeDomain = $oneLakeUri.Host
              $azCopyResult = azcopy login --service-principal `
                  --application-id $env:CLIENT_ID `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="$oneLakeDomain" `
                  --output-type json | ConvertFrom-Json
              if (-not $azCopyResult) {
                  Write-Error "AzCopy authentication failed."
                  throw "AzCopy authentication failed."
              }
              Write-Host "AzCopy Authentication Successful."

              # Authenticate to Power BI Service
              Write-Host "Authenticating to Power BI Service..."
              Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop
              Write-Host "Power BI Authentication Successful."

              Write-Host "=== Authentication Debug Completed Successfully ==="
          } catch {
              Write-Error "Authentication Failed."
              Write-Error $_.Exception.Message
              throw $_
          }
        env:
          CLIENT_SECRET: $(Clientsecret)
          CLIENT_ID: $(clinetid)
          TENANT_ID: $(tenantid)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)



-------------------------------------------------------------------


- task: PowerShell@2
  displayName: 'Detect and Archive PBISM/PBIR Changes'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      # Get changed files with folder deduplication
      $pbismChanges = git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism'
      $pbirChanges = git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir'
      
      # Use hashtables to track unique folders
      $uniqueModelFolders = @{}
      $uniqueReportFolders = @{}
      
      # Process semantic models
      foreach ($change in $pbismChanges) {
          $folder = Split-Path (Split-Path $change -Parent) -Leaf
          $baseFolder = $folder -replace '\.report$|\.semantic$|\.SemanticModel$', ''
          if (-not $uniqueModelFolders.ContainsKey($baseFolder)) {
              $uniqueModelFolders[$baseFolder] = $change
          }
      }
      
      # Process reports
      foreach ($change in $pbirChanges) {
          $folder = Split-Path (Split-Path $change -Parent) -Leaf
          $baseFolder = $folder -replace '\.report$|\.Report$', ''
          if (-not $uniqueReportFolders.ContainsKey($baseFolder)) {
              $uniqueReportFolders[$baseFolder] = $change
          }
      }
      
      Write-Host "Unique PBISM files to process:"
      $uniqueModelFolders.Values | ForEach-Object { Write-Host "- $_" }
      Write-Host "Unique PBIR files to process:"
      $uniqueReportFolders.Values | ForEach-Object { Write-Host "- $_" }
      
      # Create artifact structure
      $artifactFolder = "$(Build.ArtifactStagingDirectory)/PowerBIArtifacts"
      if (-not (Test-Path $artifactFolder)) {
          New-Item -ItemType Directory -Path $artifactFolder -Force | Out-Null
      }
      
      # Copy unique semantic models
      if ($uniqueModelFolders.Count -gt 0) {
          $smFolder = Join-Path $artifactFolder "SemanticModels"
          New-Item -ItemType Directory -Path $smFolder -Force | Out-Null
          
          foreach ($modelFile in $uniqueModelFolders.Values) {
              $src = Join-Path "$(Build.SourcesDirectory)" $modelFile
              $modelName = Split-Path (Split-Path $modelFile -Parent) -Leaf
              $baseModelName = $modelName -replace '\.report$|\.semantic$|\.SemanticModel$', ''
              $destFolder = Join-Path $smFolder $baseModelName
              
              if (-not (Test-Path $destFolder)) {
                  New-Item -ItemType Directory -Path $destFolder -Force | Out-Null
              }
              Copy-Item $src -Destination (Join-Path $destFolder "definition.pbism") -Force
              Write-Host "Copied model: $baseModelName"
          }
      }
      
      # Copy unique reports
      if ($uniqueReportFolders.Count -gt 0) {
          $rptFolder = Join-Path $artifactFolder "Reports"
          New-Item -ItemType Directory -Path $rptFolder -Force | Out-Null
          
          foreach ($reportFile in $uniqueReportFolders.Values) {
              $src = Join-Path "$(Build.SourcesDirectory)" $reportFile
              $reportName = Split-Path (Split-Path $reportFile -Parent) -Leaf
              $baseReportName = $reportName -replace '\.report$|\.Report$', ''
              $destFolder = Join-Path $rptFolder $baseReportName
              
              if (-not (Test-Path $destFolder)) {
                  New-Item -ItemType Directory -Path $destFolder -Force | Out-Null
              }
              Copy-Item $src -Destination (Join-Path $destFolder "definition.pbir") -Force
              Write-Host "Copied report: $baseReportName"
          }
      }

  - task: PublishBuildArtifacts@1
    displayName: 'Publish Artifacts'
    inputs:
      PathtoPublish: '$(Build.ArtifactStagingDirectory)/PowerBIArtifacts'
      ArtifactName: 'PowerBIArtifacts'
      publishLocation: 'Container'
------------------------------------------------------------

- task: PowerShell@2
  displayName: '=== Promoting Items to UAT ==='
  env:
    CLIENT_SECRET: $(clientsecret)
    CLIENT_ID: $(clinetid)
    TENANT_ID: $(tenantid)
    UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
  inputs:
    pwsh: true
    targetType: inline
    script: |
      try {
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
          Import-Module Az.Accounts -Force
          Import-Module MicrosoftPowerBIMgmt -Force

          # Authentication setup
          $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
          $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
          $tenantId = $env:TENANT_ID.Trim()

          Write-Host "=== Authenticating ==="
          Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId
          
          $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password))
          Set-FabricAuthToken -servicePrincipalId $env:CLIENT_ID -servicePrincipalSecret $plainTextPwd -tenantId $tenantId -reset

          # Define artifact paths using pipeline variables
          Write-Host "`n=== Locating Artifacts ==="
          $buildArtifactsPath = Join-Path -Path $env:SYSTEM_DEFAULTWORKINGDIRECTORY -ChildPath "PowerBIArtifacts"
          Write-Host "Build artifacts path: $buildArtifactsPath"

          # Verify artifact path exists
          if (!(Test-Path $buildArtifactsPath)) {
              Write-Host "Primary path not found, checking alternative paths..."
              $altPath = Join-Path -Path $env:SYSTEM_ARTIFACTSDIRECTORY -ChildPath "PowerBIArtifacts"
              if (Test-Path $altPath) {
                  $buildArtifactsPath = $altPath
                  Write-Host "Using alternative path: $buildArtifactsPath"
              } else {
                  # List all available directories for debugging
                  Write-Host "`nAvailable directories:"
                  Get-ChildItem -Path $env:SYSTEM_DEFAULTWORKINGDIRECTORY -Recurse -Directory | ForEach-Object {
                      Write-Host $_.FullName
                  }
                  throw "Could not locate artifacts directory"
              }
          }

          # List files in artifact directory
          Write-Host "`nFiles in artifact directory:"
          Get-ChildItem -Path $buildArtifactsPath -Recurse | ForEach-Object {
              Write-Host " - $($_.FullName)"
          }

          # Get workspace
          Write-Host "`n=== Getting UAT Workspace ==="
          $workspaceObj = Get-FabricWorkspace -workspaceName $env:UAT_WORKSPACE_NAME
          if (-not $workspaceObj) {
              throw "UAT workspace not found: $($env:UAT_WORKSPACE_NAME)"
          }
          $workspaceId = $workspaceObj.Id
          Write-Host "Found workspace: $($workspaceObj.Name) ($workspaceId)"

          # Find all Power BI files
          $pbismFiles = Get-ChildItem -Path $buildArtifactsPath -Recurse -Include "*.pbism" -File -ErrorAction SilentlyContinue
          $pbirFiles = Get-ChildItem -Path $buildArtifactsPath -Recurse -Include "*.pbir" -File -ErrorAction SilentlyContinue

          Write-Host "`nFound files:"
          Write-Host "- $($pbismFiles.Count) semantic model(s)"
          Write-Host "- $($pbirFiles.Count) report(s)"

          if ($pbismFiles.Count -eq 0 -and $pbirFiles.Count -eq 0) {
              throw "No Power BI files found in artifacts"
          }

          # Import semantic models
          $importedModels = @{}
          foreach ($model in $pbismFiles) {
              $modelFolder = $model.Directory
              $modelName = $modelFolder.Name
              Write-Host "`nProcessing semantic model: $modelName"
              
              try {
                  $modelResult = Import-FabricItem `
                      -workspaceId $workspaceId `
                      -path $modelFolder.FullName `
                      -itemProperties @{
                          displayName = $modelName
                          itemType = "semanticModel"
                      }
                  
                  if ($modelResult) {
                      $importedModels[$modelFolder.FullName] = $modelResult.id
                      Write-Host "Successfully imported model: $modelName"
                  }
              }
              catch {
                  Write-Error "Failed to import model $modelName`: $_"
                  throw
              }
          }

          # Import reports
          foreach ($report in $pbirFiles) {
              $reportFolder = $report.Directory
              $reportName = $reportFolder.Name
              Write-Host "`nProcessing report: $reportName"

              $modelId = $importedModels[$reportFolder.FullName]
              if ($modelId) {
                  try {
                      Import-FabricItem `
                          -workspaceId $workspaceId `
                          -path $reportFolder.FullName `
                          -itemProperties @{
                              displayName = $reportName
                              itemType = "report"
                              semanticModelId = $modelId
                          }
                      Write-Host "Successfully imported report: $reportName"
                  }
                  catch {
                      Write-Error "Failed to import report $reportName`: $_"
                      throw
                  }
              }
              else {
                  Write-Warning "No semantic model found for report: $reportName"
              }
          }

          Write-Host "`n=== Deployment Complete ==="

      }
      catch {
          Write-Error "Deployment failed: $_"
          Write-Error $_.ScriptStackTrace
          throw
      }
--------------------------------------------------------------

- task: PowerShell@2
  displayName: "=== Promoting Changes to UAT ==="
  inputs:
    pwsh: true
    targetType: inline
    script: |
      try {
          # Set Debug Level
          $DebugPreference = "Continue"

          Write-Host "=== Starting Promotion Process ==="

          # Import Required Modules
          Write-Host "=== Importing Required Modules ==="
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
          Import-Module Az.Accounts -Force
          Import-Module MicrosoftPowerBIMgmt -Force

          # Set Credentials
          Write-Host "=== Setting Up Credentials ==="
          $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
          $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
          $tenantId = $env:TENANT_ID.Trim()

          # Authenticate to Fabric
          Write-Host "=== Authenticating to Fabric ==="
          $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
          $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

          $isServicePrincipal = $false
          $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
          if ($credential.UserName -match $guidRegex) {
              $isServicePrincipal = $true
          }

          if ($isServicePrincipal) {
              Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                  -servicePrincipalSecret $plainTextPwd `
                  -tenantId $tenantId -reset
          } else {
              Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
          }

          # Validate Authentication
          $authToken = Get-FabricAuthToken
          if (-not $authToken) {
              Write-Error "Authentication to Fabric failed."
              throw "Fabric authentication failed."
          }

          Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential
          Write-Host "Authentication Successful."

          # Detect File Changes and Deletions
          Write-Host "=== Detecting Changes and Deletions ==="
          $pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
          $pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
          $pbipSMDeletions = @(git diff --name-only --relative --diff-filter=D HEAD~1..HEAD '**/*.pbism')
          $pbipRptDeletions = @(git diff --name-only --relative --diff-filter=D HEAD~1..HEAD '**/*.pbir')

          Write-Host "Semantic Model Changes: $($pbipSMChanges.Count)"
          Write-Host "Report Changes: $($pbipRptChanges.Count)"
          Write-Host "Semantic Model Deletions: $($pbipSMDeletions.Count)"
          Write-Host "Report Deletions: $($pbipRptDeletions.Count)"

          # Connect to UAT Workspace
          Write-Host "=== Connecting to UAT Workspace ==="
          $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
          if (-not $workspaceObj) {
              Write-Error ("UAT workspace '{0}' not found." -f $env:UAT_WORKSPACE_NAME)
              throw "Workspace not found."
          }
          $workspaceID = $workspaceObj.Id

          # Handle Semantic Model Deletions
          if ($pbipSMDeletions.Count -gt 0) {
              Write-Host "=== Removing Deleted Semantic Models from UAT ==="
              foreach ($deletion in $pbipSMDeletions) {
                  try {
                      Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items/$deletion" -Method DELETE
                      Write-Host "Deleted Semantic Model: $deletion"
                  } catch {
                      Write-Error "Failed to delete Semantic Model: $deletion. Error: $_"
                      throw
                  }
              }
          }

          # Handle Report Deletions
          if ($pbipRptDeletions.Count -gt 0) {
              Write-Host "=== Removing Deleted Reports from UAT ==="
              foreach ($deletion in $pbipRptDeletions) {
                  try {
                      Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items/$deletion" -Method DELETE
                      Write-Host "Deleted Report: $deletion"
                  } catch {
                      Write-Error "Failed to delete Report: $deletion. Error: $_"
                      throw
                  }
              }
          }

          # Import Semantic Models if Changed
          if ($pbipSMChanges.Count -gt 0) {
              Write-Host "=== Importing Changed Semantic Models ==="
              $smPathsToPromote = $pbipSMChanges | ForEach-Object { Split-Path $_ -Parent } | Select-Object -Unique
              foreach ($promotePath in $smPathsToPromote) {
                  try {
                      Import-FabricItem -workspaceId $workspaceID -path $promotePath
                      Write-Host "Imported Semantic Model: $promotePath"
                  } catch {
                      Write-Error "Failed to import Semantic Model: $promotePath. Error: $_"
                      throw
                  }
              }
          }

          # Import Reports if Changed
          if ($pbipRptChanges.Count -gt 0) {
              Write-Host "=== Importing Changed Reports ==="
              foreach ($change in $pbipRptChanges) {
                  try {
                      $parentFolder = Split-Path $change -Parent
                      Import-FabricItem -workspaceId $workspaceID -path $parentFolder
                      Write-Host "Imported Report: $parentFolder"
                  } catch {
                      Write-Error "Failed to import Report: $change. Error: $_"
                      throw
                  }
              }
          }

          Write-Host "=== Promotion to UAT Completed Successfully ==="
      } catch {
          Write-Error "An error occurred during the promotion process. Details: $_"
          throw
      }
    env:
      CLIENT_SECRET: $(Clientsecret)
      CLIENT_ID: $(clinetid)
      TENANT_ID: $(tenantid)
      UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)



------------------------------------------------------


Write-Host "=== Detecting PBISM & PBIR Changes ==="
          # Compare the previous commit (HEAD~1) to current (HEAD)
          $pbipSMChanges   = @(git diff HEAD~1..HEAD --name-only --relative --diff-filter=AM '**/*.pbism')
          $pbipRptChanges  = @(git diff HEAD~1..HEAD --name-only --relative --diff-filter=AM '**/*.pbir')

          $pbipSMDeletions = @(git diff HEAD~1..HEAD --name-only --relative --diff-filter=D  '**/*.pbism')
          $pbipRptDeletions= @(git diff HEAD~1..HEAD --name-only --relative --diff-filter=D  '**/*.pbir')

          # Sort & Unique
          $pbipSMChanges   = $pbipSMChanges | Sort-Object -Unique
          $pbipRptChanges  = $pbipRptChanges | Sort-Object -Unique
          $pbipSMDeletions = $pbipSMDeletions | Sort-Object -Unique
          $pbipRptDeletions= $pbipRptDeletions | Sort-Object -Unique

          # Print
          Write-Host "PBISM (Add/Mod): $($pbipSMChanges -join ', ')"
          Write-Host "PBIR  (Add/Mod): $($pbipRptChanges -join ', ')"
          Write-Host "PBISM (Del)    : $($pbipSMDeletions -join ', ')"
          Write-Host "PBIR  (Del)    : $($pbipRptDeletions -join ', ')"

          if (
            $pbipSMChanges.Count   -eq 0 -and
            $pbipRptChanges.Count  -eq 0 -and
            $pbipSMDeletions.Count -eq 0 -and
            $pbipRptDeletions.Count -eq 0
          ) {
              Write-Host "No changes detected. Exiting pipeline."
              exit 0
          }

          ##############################################################################
          # 3) Get UAT Workspace
          ##############################################################################
          Write-Host "=== Retrieving UAT Workspace ==="
          $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
          if (-not $workspaceObj) {
              Write-Error "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
              throw "Workspace not found."
          }
          $workspaceID = $workspaceObj.Id

          # Helper function to import a semantic model
          function Import-SemanticModel($modelPath, $wsID) {
              Write-Host ("Importing semantic model from {0} into UAT workspace." -f $modelPath)
              try {
                  $smItem = Import-FabricItem -workspaceId $wsID -path $modelPath
                  Write-Host "Semantic model imported successfully."
                  return $smItem
              } catch {
                  $err = $_
                  Write-Error ("Failed to import semantic model at {0}: {1}" -f $modelPath, $err)
                  throw $err
              }
          }

          ##############################################################################
          # 4) Import/Remove Changed Semantic Models
          ##############################################################################
          # --- A) Added / Modified PBISM ---
          if ($pbipSMChanges.Count -gt 0) {
              Write-Host "=== Importing Changed Semantic Models ==="
              $smPathsToPromote = @()
              $filter = "*.pbism"
              foreach ($smFile in $pbipSMChanges) {
                  $parentFolder = Split-Path $smFile -Parent
                  while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                      $parentFolder = Split-Path $parentFolder -Parent
                  }
                  $smPathsToPromote += $parentFolder
              }
              $smPathsToPromote = $smPathsToPromote | Sort-Object -Unique

              foreach ($smFolder in $smPathsToPromote) {
                  Import-SemanticModel $smFolder $workspaceID | Out-Null
              }
          } else {
              Write-Host "No semantic model add/modify detected. Skipping SM import."
          }

          # --- B) Deleted PBISM ---
          if ($pbipSMDeletions.Count -gt 0) {
              Write-Host "=== Handling Deleted Semantic Models ==="
              foreach ($deletedSM in $pbipSMDeletions) {
                  Write-Host ("Deleted PBISM file: {0}" -f $deletedSM)
                  # Optionally remove from workspace:
                  # Remove-FabricItem -workspaceId $workspaceID -itemName "<ModelName>" -itemType "PowerBIModel"
              }
          }

          ##############################################################################
          # 5) Import/Remove Changed Reports
          ##############################################################################
          # --- A) Added / Modified PBIR ---
          if ($pbipRptChanges.Count -gt 0) {
              Write-Host "=== Importing Changed Reports ==="
              $itemsJson = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET
              $allItems  = $itemsJson

              foreach ($rptFile in $pbipRptChanges) {
                  $parentFolder = Split-Path $rptFile -Parent
                  $filter = "*.pbir"
                  while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                      $parentFolder = Split-Path $parentFolder -Parent
                  }
                  if ($parentFolder) {
                      # 1. Load definition.pbir
                      $def = Get-ChildItem -Path $parentFolder -Recurse -Include "definition.pbir"
                      if (-not $def) {
                          Write-Error ("No definition.pbir found in {0}" -f $parentFolder)
                          throw "Missing report definition."
                      }
                      $reportDefinition = Get-Content $def.FullName | ConvertFrom-Json
                      $smPathRef = $reportDefinition.datasetReference.byPath
                      if (-not $smPathRef) {
                          Write-Error "Report definition missing datasetReference.byPath"
                          throw "No semantic model path for the report."
                      }

                      # 2. Check if .pbism is local or if we reuse existing
                      $pathToCheck = Join-Path $parentFolder $smPathRef.path
                      $pbismFile   = Get-ChildItem -Path $pathToCheck -Recurse -Include "*.pbism"

                      $semanticModelId = $null
                      if ($pbismFile) {
                          # If the .pbism is present, re-import to ensure it's up-to-date
                          Write-Host "Re-importing .pbism for updated report..."
                          $reImportedSM = Import-SemanticModel $pbismFile.DirectoryName $workspaceID
                          $semanticModelId = $reImportedSM.id
                      } else {
                          # If no .pbism changed locally, see if it already exists in UAT
                          $semanticModelName = Split-Path $pathToCheck -Leaf
                          $existingSM = $allItems | Where-Object {
                              $_.type -eq "PowerBIModel" -and $_.displayName -eq $semanticModelName
                          }
                          if ($existingSM) {
                              Write-Host "Using existing SM: $($existingSM.displayName) [ID: $($existingSM.id)]"
                              $semanticModelId = $existingSM.id
                          } else {
                              Write-Error "Cannot find existing semantic model '$semanticModelName' in UAT."
                              throw "Missing dataset in UAT for this report reference."
                          }
                      }

                      # 3. Import the Report
                      if (-not $semanticModelId) {
                          Write-Error "No semantic model ID found; cannot import report."
                          throw "Semantic model not found."
                      }
                      Write-Host ("Importing report from {0} to UAT (SM ID = {1})" -f $parentFolder, $semanticModelId)

                      try {
                          Import-FabricItem -workspaceId $workspaceID -path $parentFolder -itemProperties @{ semanticModelId = $semanticModelId } | Out-Null
                          Write-Host "Report imported successfully."
                      } catch {
                          $err = $_
                          Write-Error ("Failed to import report: {0}" -f $err)
                          throw $err
                      }
                  }
              }
          } else {
              Write-Host "No report add/modify detected. Skipping report import."
          }

          # --- B) Deleted PBIR ---
          if ($pbipRptDeletions.Count -gt 0) {
              Write-Host "=== Handling Deleted Reports ==="
              foreach ($deletedRpt in $pbipRptDeletions) {
                  Write-Host ("Deleted PBIR file: {0}" -f $deletedRpt)
                  # Optionally remove from workspace:
                  # Remove-FabricItem -workspaceId $workspaceID -itemName "<ReportName>" -itemType "PowerBIReport"
              }
          }

          Write-Host "=== Promotion to UAT completed successfully. ==="
      }
      catch {
          $err = $_
          Write-Error ("An error occurred in Promote-to-UAT step: {0}" -f $err)
          throw $err
      }
------------------------------------


##############################################################################
          # 2) Determine Git Diff Range from Azure DevOps Variables
          ##############################################################################
          $baseCommit = $env:Build_SourceVersionBase
          $headCommit = $env:Build_SourceVersion

          Write-Host "Base commit:   $baseCommit"
          Write-Host "Current commit:$headCommit"

          # Fallback logic if variables are empty or identical:
          if ([string]::IsNullOrWhiteSpace($baseCommit) -or [string]::IsNullOrWhiteSpace($headCommit)) {
            Write-Warning "Build.SourceVersionBase or Build.SourceVersion not set."
            Write-Warning "Falling back to HEAD~1..HEAD if possible..."

            if ((git rev-parse HEAD~1 2>$null) -and ($LASTEXITCODE -eq 0)) {
              $baseCommit = "HEAD~1"
              $headCommit = "HEAD"
            }
            else {
              Write-Warning "Could not find HEAD~1. Using HEAD..HEAD."
              $baseCommit = "HEAD"
            }
          }
          elseif ($baseCommit -eq $headCommit) {
            Write-Warning "SourceVersionBase == SourceVersion => Single commit scenario."
            if ((git rev-parse HEAD~1 2>$null) -and ($LASTEXITCODE -eq 0)) {
              $baseCommit = "HEAD~1"
              $headCommit = "HEAD"
            }
            else {
              $baseCommit = "HEAD"
            }
          }

          Write-Host "Using git diff range: $baseCommit $headCommit"

          ##############################################################################
          # 3) Detect Changes (Added/Modified + Deletions)
          ##############################################################################
          Write-Host "=== Detecting PBISM & PBIR Changes ==="
          $pbismAddMod = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- '**/*.pbism')
          $pbirAddMod  = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- '**/*.pbir')

          $pbismDel    = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- '**/*.pbism')
          $pbirDel     = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- '**/*.pbir')

          # Sort & unique
          $pbismAddMod = $pbismAddMod | Sort-Object -Unique
          $pbirAddMod  = $pbirAddMod  | Sort-Object -Unique
          $pbismDel    = $pbismDel    | Sort-Object -Unique
          $pbirDel     = $pbirDel     | Sort-Object -Unique

          # Print for debugging
          Write-Host "PBISM Add/Mod: $($pbismAddMod -join ', ')"
          Write-Host "PBIR Add/Mod:  $($pbirAddMod -join ', ')"
          Write-Host "PBISM Deleted: $($pbismDel -join ', ')"
          Write-Host "PBIR Deleted:  $($pbirDel -join ', ')"

          if (
            $pbismAddMod.Count -eq 0 -and
            $pbirAddMod.Count  -eq 0 -and
            $pbismDel.Count    -eq 0 -and
            $pbirDel.Count     -eq 0
          ) {
            Write-Host "No changes detected. Exiting pipeline."
            exit 0
          }

          ##############################################################################
          # 4) Retrieve UAT Workspace
          ##############################################################################
          Write-Host "=== Retrieving UAT Workspace ==="
          $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
          if (-not $workspaceObj) {
            throw "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
          }
          $workspaceID = $workspaceObj.Id

          # Helper to import semantic model
          function Import-SemanticModel($smFolder, $wsId) {
            Write-Host "Importing semantic model from $smFolder..."
            $smItem = Import-FabricItem -workspaceId $wsId -path $smFolder
            Write-Host "Semantic model imported: $($smItem.displayName)"
            return $smItem
          }

          ##############################################################################
          # 5) Process Semantic Model Changes
          ##############################################################################
          # A) Added or Modified
          if ($pbismAddMod.Count -gt 0) {
            Write-Host "=== Importing Changed Semantic Models ==="
            $smFolders = @()
            foreach ($file in $pbismAddMod) {
              $dir = Split-Path $file -Parent
              while ($dir -and !(Test-Path (Join-Path $dir '*.pbism'))) {
                $dir = Split-Path $dir -Parent
              }
              if ($dir) { $smFolders += $dir }
            }
            $smFolders = $smFolders | Sort-Object -Unique

            foreach ($smFolder in $smFolders) {
              Import-SemanticModel $smFolder $workspaceID | Out-Null
            }
          }

          # B) Deleted
          if ($pbismDel.Count -gt 0) {
            Write-Host "=== Handling Deleted Semantic Models ==="
            foreach ($deletedFile in $pbismDel) {
              Write-Host "Deleted PBISM file: $deletedFile"
              # If you want to remove from workspace, do Remove-FabricItem ...
            }
          }

          ##############################################################################
          # 6) Process Report Changes
          ##############################################################################
          if ($pbirAddMod.Count -gt 0) {
            Write-Host "=== Importing Changed Reports ==="
            $allItems = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET

            foreach ($rptFile in $pbirAddMod) {
              $rptDir = Split-Path $rptFile -Parent
              while ($rptDir -and !(Test-Path (Join-Path $rptDir '*.pbir'))) {
                $rptDir = Split-Path $rptDir -Parent
              }
              if (-not $rptDir) { continue }

              # Load definition
              $defFile = Get-ChildItem -Path $rptDir -Recurse -Include "definition.pbir"
              if (-not $defFile) {
                throw "No definition.pbir found in $rptDir"
              }
              $reportDef = Get-Content $defFile.FullName | ConvertFrom-Json
              $smPathRef = $reportDef.datasetReference.byPath
              if (-not $smPathRef) {
                throw "Report definition missing datasetReference.byPath"
              }

              # Possibly re-import local pbism
              $fullPath   = Join-Path $rptDir $smPathRef.path
              $localSM    = Get-ChildItem -Path $fullPath -Recurse -Include "*.pbism"
              $semanticId = $null

              if ($localSM) {
                # Re-import
                Write-Host "Re-importing semantic model for the updated report..."
                $smImported = Import-SemanticModel $($localSM.DirectoryName) $workspaceID
                $semanticId = $smImported.id
              } else {
                # Reuse existing dataset
                $smName   = Split-Path $fullPath -Leaf
                $existing = $allItems | Where-Object {
                  $_.type -eq "PowerBIModel" -and $_.displayName -eq $smName
                }
                if ($existing) {
                  $semanticId = $existing.id
                  Write-Host "Using existing SM: $($existing.displayName) [ID=$($existing.id)]"
                } else {
                  throw "Cannot find existing semantic model '$smName' in UAT. Aborting."
                }
              }

              if (-not $semanticId) {
                throw "No semantic model ID found. Cannot import report."
              }

              Write-Host "Importing report from $rptDir with SM ID=$semanticId"
              Import-FabricItem -workspaceId $workspaceID -path $rptDir -itemProperties @{ semanticModelId = $semanticId } | Out-Null
              Write-Host "Report imported successfully."
            }
          }

          if ($pbirDel.Count -gt 0) {
            Write-Host "=== Handling Deleted Reports ==="
            foreach ($deletedRpt in $pbirDel) {
              Write-Host "Deleted PBIR file: $deletedRpt"
              # Possibly Remove-FabricItem ...
            }
          }

          Write-Host "=== Promotion to UAT completed successfully. ==="
      }
      catch {
          $err = $_
          Write-Error ("An error occurred in Promote-to-UAT step: {0}" -f $err)
          throw $err
      }
--------------------------force----------------------------

$baseCommit = $env:Build_SourceVersionBase
          $headCommit = $env:Build_SourceVersion
          Write-Host "Base commit:   $baseCommit"
          Write-Host "Current commit:$headCommit"

          if ([string]::IsNullOrWhiteSpace($baseCommit) -or [string]::IsNullOrWhiteSpace($headCommit)) {
            Write-Warning "Build.SourceVersionBase or Build.SourceVersion not set. Falling back to HEAD~1..HEAD."
            if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
              $baseCommit = "HEAD~1"
              $headCommit = "HEAD"
            } else {
              Write-Warning "HEAD~1 not found, fallback to HEAD..HEAD."
              $baseCommit = "HEAD"
            }
          }
          elseif ($baseCommit -eq $headCommit) {
            Write-Warning "Base == Head, single commit scenario, falling back to HEAD~1..HEAD..."
            if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
              $baseCommit = "HEAD~1"
              $headCommit = "HEAD"
            } else {
              $baseCommit = "HEAD"
            }
          }

          Write-Host "Using commit range: $baseCommit..$headCommit"

          ##############################################################################
          # 3) Detect Changes in .pbir & .pbism (Add/Mod/Delete)
          ##############################################################################
          Write-Host "=== Detecting PBIR & PBISM Changes ==="

          $pbirChanged = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- '**/*.pbir' '**/definition.pbir')
          $pbismChanged= @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- '**/*.pbism' '**/definition.pbism')

          $pbirDeleted = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- '**/*.pbir' '**/definition.pbir')
          $pbismDeleted= @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- '**/*.pbism' '**/definition.pbism')

          # Sort & unique
          $pbirChanged = $pbirChanged | Sort-Object -Unique
          $pbismChanged= $pbismChanged| Sort-Object -Unique
          $pbirDeleted = $pbirDeleted | Sort-Object -Unique
          $pbismDeleted= $pbismDeleted| Sort-Object -Unique

          Write-Host "PBIR changed : $($pbirChanged -join ', ')"
          Write-Host "PBISM changed: $($pbismChanged -join ', ')"
          Write-Host "PBIR deleted : $($pbirDeleted -join ', ')"
          Write-Host "PBISM deleted: $($pbismDeleted -join ', ')"

          ##############################################################################
          # 4) (Optional) Force Reimport if no changes found?
          ##############################################################################
          # In tricky edge cases, you might forcibly push the semantic model if this param is set.
          $ForceSemanticReimport = $false  # Set to $true if you want to always reimport PBISM

          $totalChanges = $pbirChanged.Count + $pbismChanged.Count + $pbirDeleted.Count + $pbismDeleted.Count
          if ($totalChanges -eq 0 -and -not $ForceSemanticReimport) {
            Write-Host "No changes detected. Exiting pipeline."
            exit 0
          }

          Write-Host "Some changes detected or ForceSemanticReimport is true. Proceeding..."

          ##############################################################################
          # 5) Retrieve UAT Workspace
          ##############################################################################
          Write-Host "=== Retrieving UAT Workspace ==="
          $ws = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
          if (-not $ws) {
            throw "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
          }
          $workspaceID = $ws.Id

          function Import-SemanticModel($modelPath, $wid) {
            Write-Host ("Importing semantic model from {0} into UAT workspace..." -f $modelPath)
            $imported = Import-FabricItem -workspaceId $wid -path $modelPath
            Write-Host "Semantic model imported: $($imported.displayName)"
            return $imported
          }

          ##############################################################################
          # 6) Handle PBISM Changes (Add/Mod/Delete)
          ##############################################################################
          if ($pbismChanged.Count -gt 0 -or $ForceSemanticReimport) {
            Write-Host "=== Importing Changed (or Forced) Semantic Models ==="
            $smFolders = @()

            if ($pbismChanged.Count -gt 0) {
              foreach ($file in $pbismChanged) {
                $parent = Split-Path $file -Parent
                while ($parent -and !(Test-Path (Join-Path $parent '*.pbism'))) {
                  $parent = Split-Path $parent -Parent
                }
                if ($parent) { $smFolders += $parent }
              }
            }

            # If forcing, you might specify a known path or re-import all PBISM folders.
            if ($ForceSemanticReimport -and $smFolders.Count -eq 0) {
              # Example: reimport all .pbism found in repo
              $allSMs = Get-ChildItem -Path . -Recurse -Include '*.pbism'
              foreach ($sm in $allSMs) {
                $p = Split-Path $sm.FullName -Parent
                $smFolders += $p
              }
            }

            $smFolders = $smFolders | Sort-Object -Unique
            if ($smFolders.Count -eq 0 -and -not $ForceSemanticReimport) {
              Write-Host "No actual semantic model folders found to import."
            } else {
              foreach ($f in $smFolders | Sort-Object -Unique) {
                Import-SemanticModel $f $workspaceID | Out-Null
              }
            }
          }

          if ($pbismDeleted.Count -gt 0) {
            Write-Host "=== Handling Deleted Semantic Models ==="
            foreach ($del in $pbismDeleted) {
              Write-Host "PBISM deleted: $del"
              # Optionally remove from workspace with Remove-FabricItem ...
            }
          }

          ##############################################################################
          # 7) Handle PBIR Changes (Add/Mod/Delete)
          ##############################################################################
          if ($pbirChanged.Count -gt 0) {
            Write-Host "=== Importing Changed Reports ==="
            $wsItems = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET
            foreach ($rfile in $pbirChanged) {
              $rDir = Split-Path $rfile -Parent
              while ($rDir -and !(Test-Path (Join-Path $rDir '*.pbir'))) {
                $rDir = Split-Path $rDir -Parent
              }
              if (-not $rDir) { continue }

              # Load definition
              $defFile = Get-ChildItem -Path $rDir -Recurse -Include "definition.pbir"
              if (-not $defFile) {
                Write-Host "No definition.pbir found in $rDir. Skipping."
                continue
              }
              $reportDef = Get-Content $defFile.FullName | ConvertFrom-Json
              $smPathRef = $reportDef.datasetReference.byPath
              if (-not $smPathRef) {
                throw "Report definition missing datasetReference.byPath."
              }

              # Possibly re-import local .pbism
              $smFull  = Join-Path $rDir $smPathRef.path
              $localSM = Get-ChildItem -Path $smFull -Recurse -Include '*.pbism'
              $smId    = $null

              if ($localSM) {
                # We have local SM changes or a .pbism
                Write-Host "Importing local .pbism for updated report..."
                $reImport = Import-SemanticModel $($localSM.DirectoryName) $workspaceID
                $smId     = $reImport.id
              }
              else {
                # Use existing dataset in UAT
                $smName = Split-Path $smFull -Leaf
                $existing = $wsItems | Where-Object {
                  $_.type -eq "PowerBIModel" -and $_.displayName -eq $smName
                }
                if ($existing) {
                  $smId = $existing.id
                  Write-Host "Using existing semantic model: $($existing.displayName) [ID=$smId]"
                } else {
                  throw "No existing SM named '$smName' found in UAT. Aborting report import."
                }
              }

              if (-not $smId) {
                throw "No semantic model ID found for report. Cannot import."
              }
              Write-Host "Importing report from $rDir with SM ID=$smId"
              Import-FabricItem -workspaceId $workspaceID -path $rDir -itemProperties @{ semanticModelId = $smId } | Out-Null
              Write-Host "Report imported successfully."
            }
          }

          if ($pbirDeleted.Count -gt 0) {
            Write-Host "=== Handling Deleted Reports ==="
            foreach ($delRpt in $pbirDeleted) {
              Write-Host "PBIR deleted: $delRpt"
              # Optionally Remove-FabricItem ...
            }
          }

          Write-Host "=== Promotion to UAT completed successfully. ==="
      }
      catch {
        $err = $_
        Write-Error ("Error in Promote-to-UAT: {0}" -f $err)
        throw $err
      }
-------------------.json----------------------------------

$baseCommit = $env:Build_SourceVersionBase
          $headCommit = $env:Build_SourceVersion
          Write-Host "Base commit:   $baseCommit"
          Write-Host "Current commit:$headCommit"

          if ([string]::IsNullOrWhiteSpace($baseCommit) -or [string]::IsNullOrWhiteSpace($headCommit)) {
            Write-Warning "Build.SourceVersionBase or Build.SourceVersion not set. Falling back to HEAD~1..HEAD."
            if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
              $baseCommit = "HEAD~1"
              $headCommit = "HEAD"
            } else {
              Write-Warning "HEAD~1 not found, fallback to HEAD..HEAD."
              $baseCommit = "HEAD"
            }
          }
          elseif ($baseCommit -eq $headCommit) {
            Write-Warning "Base == Head, single commit scenario, falling back to HEAD~1..HEAD..."
            if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
              $baseCommit = "HEAD~1"
              $headCommit = "HEAD"
            } else {
              $baseCommit = "HEAD"
            }
          }

          Write-Host "Using git diff range: $baseCommit..$headCommit"

          ##############################################################################
          # 3) Detect Changes (Add/Mod + Deletions) for .pbir, .pbism, .json, .pbix
          ##############################################################################
          Write-Host "=== Detecting Changes ==="

          # Patterns for reports
          $reportPatterns = @('**/*.pbir','**/*.pbix','**/*.json')
          # Patterns for semantic models
          $semanticPatterns = @('**/*.pbism')

          $reportAddedMod = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $reportPatterns)
          $reportDeleted  = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $reportPatterns)
          $modelAddedMod  = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $semanticPatterns)
          $modelDeleted   = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $semanticPatterns)

          # Sort & unique
          $reportAddedMod = $reportAddedMod | Sort-Object -Unique
          $reportDeleted  = $reportDeleted  | Sort-Object -Unique
          $modelAddedMod  = $modelAddedMod  | Sort-Object -Unique
          $modelDeleted   = $modelDeleted   | Sort-Object -Unique

          Write-Host "Reports Added/Mod: $($reportAddedMod -join ', ')"
          Write-Host "Reports Deleted:   $($reportDeleted -join ', ')"
          Write-Host "Models Added/Mod:  $($modelAddedMod -join ', ')"
          Write-Host "Models Deleted:    $($modelDeleted -join ', ')"

          $totalChanges = $reportAddedMod.Count + $reportDeleted.Count + $modelAddedMod.Count + $modelDeleted.Count
          if ($totalChanges -eq 0) {
            Write-Host "No changes detected. Exiting pipeline."
            exit 0
          }

          ##############################################################################
          # 4) Retrieve UAT Workspace
          ##############################################################################
          Write-Host "=== Retrieving UAT Workspace ==="
          $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
          if (-not $workspaceObj) {
            throw "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
          }
          $workspaceID = $workspaceObj.Id

          # Helper function to import semantic model
          function Import-SemanticModel($smFolder, $wsId) {
            Write-Host "Importing semantic model from $smFolder..."
            $item = Import-FabricItem -workspaceId $wsId -path $smFolder
            Write-Host "Imported SM: $($item.displayName)"
            return $item
          }

          ##############################################################################
          # 5) Import or Remove Semantic Models
          ##############################################################################
          if ($modelAddedMod.Count -gt 0) {
            Write-Host "=== Importing Changed Semantic Models ==="
            $smFolders = @()
            foreach ($mFile in $modelAddedMod) {
              $dir = Split-Path $mFile -Parent
              while ($dir -and !(Test-Path (Join-Path $dir '*.pbism'))) {
                $dir = Split-Path $dir -Parent
              }
              if ($dir) { $smFolders += $dir }
            }
            $smFolders = $smFolders | Sort-Object -Unique
            foreach ($smf in $smFolders) {
              Import-SemanticModel $smf $workspaceID | Out-Null
            }
          }

          if ($modelDeleted.Count -gt 0) {
            Write-Host "=== Handling Deleted Semantic Models ==="
            foreach ($dMod in $modelDeleted) {
              Write-Host "Semantic Model deleted: $dMod"
              # Optionally Remove-FabricItem ...
            }
          }

          ##############################################################################
          # 6) Import or Remove Reports (.pbir, .pbix, .json)
          ##############################################################################
          if ($reportAddedMod.Count -gt 0) {
            Write-Host "=== Importing Changed Reports ==="
            $allItems = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET

            foreach ($rFile in $reportAddedMod) {
              Write-Host "Processing changed report file: $rFile"
              $dir = Split-Path $rFile -Parent
              # if it's .pbix or .json, you may handle it differently than .pbir
              # For now, let's treat them similarly, calling Import-FabricItem
              # But if you have a separate process for .pbix, adapt that here

              if ($rFile -like '*.pbir') {
                # Existing logic if your pipeline requires you to parse 'definition.pbir'
                $defFile = Get-ChildItem -Path $dir -Recurse -Include 'definition.pbir'
                if ($defFile) {
                  # parse datasetReference, import or reimport SM, etc...
                  # your existing .pbir logic here
                }
                else {
                  # fallback: directly import the folder
                  Write-Host "No definition.pbir found, importing folder as-is."
                }
                # Example direct import
                Import-FabricItem -workspaceId $workspaceID -path $dir | Out-Null
                Write-Host "Report imported successfully (.pbir)."
              }
              elseif ($rFile -like '*.pbix') {
                # If you want to import PBIX, you might do:
                Import-FabricItem -workspaceId $workspaceID -path $dir | Out-Null
                Write-Host "Report imported successfully (.pbix)."
              }
              elseif ($rFile -like '*.json') {
                # If your .json represents a Power BI report, adapt accordingly
                Import-FabricItem -workspaceId $workspaceID -path $dir | Out-Null
                Write-Host "Report imported successfully (.json)."
              }
              else {
                Write-Host "Unrecognized file extension for $rFile. Skipping..."
              }
            }
          }

          if ($reportDeleted.Count -gt 0) {
            Write-Host "=== Handling Deleted Reports ==="
            foreach ($dRpt in $reportDeleted) {
              Write-Host "Report file deleted: $dRpt"
              # Optionally Remove-FabricItem ...
            }
          }

          Write-Host "=== Promotion to UAT completed successfully. ==="
      }
      catch {
        $err = $_
        Write-Error ("An error occurred: {0}" -f $err)
        throw $err
      }
------------------------bypass ---------------------------------

Write-Host "=== Debug: Listing top-level structure ==="
          dir -Name

          Write-Host "=== Debug: Listing entire folder structure ==="
          dir -Recurse | Out-Host

          ##############################################################################
          # 3) Determine Git Commit Range
          ##############################################################################
          $baseCommit = $env:Build_SourceVersionBase
          $headCommit = $env:Build_SourceVersion
          if ([string]::IsNullOrWhiteSpace($baseCommit) -or [string]::IsNullOrWhiteSpace($headCommit)) {
            Write-Warning "Build.SourceVersionBase or Build.SourceVersion not set => fallback HEAD~1..HEAD"
            if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
              $baseCommit = "HEAD~1"
              $headCommit = "HEAD"
            } else {
              $baseCommit = "HEAD"
            }
          }
          elseif ($baseCommit -eq $headCommit) {
            Write-Warning "Base == Head => fallback HEAD~1..HEAD"
            if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
              $baseCommit = "HEAD~1"
              $headCommit = "HEAD"
            } else {
              $baseCommit = "HEAD"
            }
          }
          Write-Host "Comparing commits: $baseCommit..$headCommit"

          ##############################################################################
          # 4) Detect Changes: .pbir, .pbix, .json (reports), .pbism (models)
          ##############################################################################
          Write-Host "=== Detecting Changes ==="
          $reportPatterns = @('**/*.pbir','**/*.pbix','**/*.json')
          $modelPatterns  = @('**/*.pbism')

          $reportAddMod = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $reportPatterns)
          $reportDel    = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $reportPatterns)
          $modelAddMod  = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $modelPatterns)
          $modelDel     = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $modelPatterns)

          $reportAddMod = $reportAddMod | Sort-Object -Unique
          $reportDel    = $reportDel    | Sort-Object -Unique
          $modelAddMod  = $modelAddMod  | Sort-Object -Unique
          $modelDel     = $modelDel     | Sort-Object -Unique

          Write-Host "Reports Add/Mod: $($reportAddMod -join ', ')"
          Write-Host "Reports Deleted: $($reportDel -join ', ')"
          Write-Host "Models Add/Mod : $($modelAddMod -join ', ')"
          Write-Host "Models Deleted : $($modelDel -join ', ')"

          $totalChanges = $reportAddMod.Count + $reportDel.Count + $modelAddMod.Count + $modelDel.Count
          if ($totalChanges -eq 0) {
            Write-Host "No changes detected. Exiting pipeline."
            exit 0
          }

          ##############################################################################
          # 5) Get UAT Workspace
          ##############################################################################
          Write-Host "=== Retrieving UAT Workspace ==="
          $wsObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
          if (-not $wsObj) {
            throw "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
          }
          $workspaceID = $wsObj.Id
          $allItems    = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET

          ##############################################################################
          # 6) Helper to Import local .pbism -> returns ID
          ##############################################################################
          function Import-LocalSemanticModel($pbismFile, $wsId) {
            $pbismDir = Split-Path $pbismFile -Parent
            Write-Host "Importing local SM from $pbismDir"
            $imp = Import-FabricItem -workspaceId $wsId -path $pbismDir
            Write-Host "Semantic model imported => $($imp.displayName) [Id=$($imp.id)]"
            return $imp.id
          }

          function Find-ExistingSMInWorkspace($name, $allItems) {
            # if your workspace naming = the folder name or a part of it
            $found = $allItems | Where-Object {
              $_.type -eq "PowerBIModel" -and $_.displayName -eq $name
            }
            return $found
          }

          ##############################################################################
          # 7) Resolve SM ID for a changed report
          ##############################################################################
          function Resolve-SemanticModelId($reportFile, $wsId, $allItems) {
            # e.g. "report 38.Report/report.json"
            $reportDir = Split-Path $reportFile -Parent  # "report 38.Report"
            $folderName = [System.IO.Path]::GetFileName($reportDir)  # "report 38.Report"

            Write-Host "Resolving SM ID for => $folderName"

            # Attempt local approach: Replace ".Report" w/ ".SemanticModel"
            $modelFolder = $folderName.Replace(".Report", ".SemanticModel")
            if (Test-Path $modelFolder) {
              Write-Host "Found local folder => $modelFolder"
              $pbism = Get-ChildItem -Path $modelFolder -Recurse -Include '*.pbism' -File
              if ($pbism) {
                $smId = Import-LocalSemanticModel $pbism[0].FullName $wsId
                return $smId
              }
              else {
                Write-Host "No .pbism found in $modelFolder => fallback to workspace search"
              }
            }
            else {
              Write-Host "No local folder named $modelFolder => fallback to workspace search"
            }

            # fallback: check if there's an existing model in the workspace
            # maybe the displayName is "report 38" or "report 38.SemanticModel" or "report 38.Report"
            $possibleNames = @(
              $folderName.Replace(".Report",""),  # "report 38"
              $folderName.Replace(".Report",".SemanticModel"),
              $folderName
            )

            foreach ($nameCandidate in $possibleNames) {
              Write-Host "Looking for existing SM named $nameCandidate in workspace..."
              $found = Find-ExistingSMInWorkspace $nameCandidate $allItems
              if ($found) {
                $f = $found | Select-Object -First 1
                Write-Host "Found SM => $($f.displayName) [Id=$($f.id)]"
                return $f.id
              }
            }

            throw "Cannot find or import a semantic model for $reportFile => tried local $modelFolder + workspace fallback with $($possibleNames -join ', ')."
          }

          ##############################################################################
          # 8) Import Changed Reports (with SM)
          ##############################################################################
          if ($reportAddMod.Count -gt 0) {
            Write-Host "=== Importing Changed Reports (attaching SM) ==="
            foreach ($rFile in $reportAddMod) {
              Write-Host "Handling changed report => $rFile"
              $smId = Resolve-SemanticModelId $rFile $workspaceID $allItems

              Write-Host "SM ID resolved => $smId"
              $repDir = Split-Path $rFile -Parent
              Import-FabricItem -workspaceId $workspaceID -path $repDir -itemProperties @{ semanticModelId = $smId } | Out-Null
              Write-Host "Report imported => $rFile attached to SM=$smId"
            }
          }

          # If any models changed, we can also import them directly above if needed
          # If any deletions are found, handle them similarly.

          Write-Host "=== Promotion to UAT completed successfully. ==="
      }
      catch {
        $err = $_
        Write-Error ("ERROR: {0}" -f $err)
        throw $err
      }
-------------------------------------------

# 2) Compare HEAD~1..HEAD with Fallback
        if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
          $baseCommit = "HEAD~1"
          $headCommit = "HEAD"
        } else {
          $baseCommit = "HEAD"
          $headCommit = "HEAD"
        }
        Write-Host "Comparing commits: $baseCommit..$headCommit"

        # 3) Detect Changed or Deleted Files
        $reportPatterns = @('**/*.pbir','**/*.pbix','**/*.json')
        $modelPatterns  = @('**/*.pbism')

        $reportAddMod = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $reportPatterns)
        $reportDel    = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $reportPatterns)
        $modelAddMod  = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $modelPatterns)
        $modelDel     = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $modelPatterns)

        $reportAddMod = $reportAddMod | Sort-Object -Unique
        $reportDel    = $reportDel    | Sort-Object -Unique
        $modelAddMod  = $modelAddMod  | Sort-Object -Unique
        $modelDel     = $modelDel     | Sort-Object -Unique

        Write-Host "Reports Add/Mod: $($reportAddMod -join ', ')"
        Write-Host "Reports Deleted: $($reportDel -join ', ')"
        Write-Host "Models Add/Mod : $($modelAddMod -join ', ')"
        Write-Host "Models Deleted : $($modelDel -join ', ')"

        $totalChanges = $reportAddMod.Count + $reportDel.Count + $modelAddMod.Count + $modelDel.Count
        if ($totalChanges -eq 0) {
          Write-Host "No changes detected. Exiting pipeline."
          exit 0
        }

        # 4) Retrieve UAT Workspace
        $wsObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
        if (-not $wsObj) {
          throw "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
        }

        $workspaceID = $wsObj.Id
        $allItems    = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET

        # 5) Helper Functions
        function Import-LocalSemanticModel($pbismFile, $wsId) {
          $pbismDir = Split-Path $pbismFile -Parent
          $imported = Import-FabricItem -workspaceId $wsId -path $pbismDir
          Write-Host "Semantic model imported => $($imported.displayName) [Id=$($imported.id)]"
          return $imported.id
        }

        function Find-ExistingSMInWorkspace($name, $allItems) {
          $found = $allItems | Where-Object {
            $_.type -eq "PowerBIModel" -and $_.displayName -eq $name
          }
          return $found
        }

        function Resolve-SemanticModelId($reportFile, $wsId, $allItems) {
          $reportDir  = Split-Path $reportFile -Parent
          $folderName = [System.IO.Path]::GetFileName($reportDir)

          $modelFolder = $folderName.Replace(".Report", ".SemanticModel")
          if (Test-Path $modelFolder) {
            $pbism = Get-ChildItem -Path $modelFolder -Recurse -Include '*.pbism' -File
            if ($pbism) {
              return Import-LocalSemanticModel $pbism[0].FullName $wsId
            }
          }

          $possibleNames = @(
            $folderName.Replace(".Report",""),
            $folderName.Replace(".Report",".SemanticModel"),
            $folderName
          )

          foreach ($nameCandidate in $possibleNames) {
            $found = Find-ExistingSMInWorkspace $nameCandidate $allItems
            if ($found) {
              $f = $found | Select-Object -First 1
              Write-Host "Found SM => $($f.displayName) [Id=$($f.id)]"
              return $f.id
            }
          }

          throw "Cannot find or import a semantic model for $reportFile. Tried local '$modelFolder' or fallback '$($possibleNames -join ', ')'."
        }

        # 6) Import Changed Reports with SM
        if ($reportAddMod.Count -gt 0) {
          foreach ($rFile in $reportAddMod) {
            $smId   = Resolve-SemanticModelId $rFile $workspaceID $allItems
            $repDir = Split-Path $rFile -Parent
            Import-FabricItem -workspaceId $workspaceID -path $repDir -itemProperties @{ semanticModelId = $smId } | Out-Null
            Write-Host "Report imported => $rFile attached to SM=$smId"
          }
        }

        Write-Host "Promotion to UAT completed successfully."
      }
      catch {
        $err = $_
        Write-Error ("ERROR: {0}" -f $err)
        throw $err
      }
-----------------FINALLLL-------------------------------------

- checkout: self
  fetchDepth: 0
  displayName: "Checkout (Full Depth)"

- task: PowerShell@2
  displayName: "Promote to UAT"
  inputs:
    pwsh: true
    targetType: inline
    script: |
      try {
        #
        # 1) Import Required Modules & Authenticate
        #
        Import-Module Az.Accounts -ErrorAction Stop
        Import-Module MicrosoftPowerBIMgmt -ErrorAction Stop
        Import-Module FabricPS-PBIP -ErrorAction Stop

        $secret     = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
        $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
        $tenantId   = $env:TENANT_ID.Trim()

        $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
          [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
        )

        $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
        $isSPN      = $false
        if ($credential.UserName -match $guidRegex) {
          $isSPN = $true
        }

        if ($isSPN) {
          Set-FabricAuthToken -servicePrincipalId $credential.UserName -servicePrincipalSecret $plainTextPwd -tenantId $tenantId -reset
        } else {
          Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
        }

        $authToken = Get-FabricAuthToken
        if (-not $authToken) {
          throw "Fabric authentication failed."
        }

        Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential

        $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
        $oneLakeUri = [System.Uri]"$($env:UAT_ONELAKE_ENDPOINT)".Trim()
        $domain     = $oneLakeUri.Host
        $azLogin    = azcopy login `
          --service-principal `
          --application-id $credential.UserName `
          --tenant-id $tenantId `
          --trusted-microsoft-suffixes="$domain" `
          --output-type json | ConvertFrom-Json
        if (-not ($azLogin | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." })) {
          throw "AzCopy login failed."
        }

        if ($isSPN) {
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop
        } else {
          Connect-PowerBIServiceAccount -Credential $credential -TenantId $tenantId -ErrorAction Stop
        }

        #
        # 2) Compare HEAD~1..HEAD (with fallback if HEAD~1 doesn't exist)
        #
        if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
          $baseCommit = "HEAD~1"
          $headCommit = "HEAD"
        } else {
          $baseCommit = "HEAD"
          $headCommit = "HEAD"
        }
        Write-Host "Comparing commits: $baseCommit..$headCommit"

        #
        # 3) Detect Changes in .pbism (model) and .pbir/.pbix/.json (report)
        #
        $modelPatterns  = @('**/*.pbism')
        $reportPatterns = @('**/*.pbir','**/*.pbix','**/*.json')

        $modelAddMod = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $modelPatterns)
        $modelDel    = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $modelPatterns)
        $reportAddMod= @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $reportPatterns)
        $reportDel   = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $reportPatterns)

        $modelAddMod = $modelAddMod | Sort-Object -Unique
        $modelDel    = $modelDel    | Sort-Object -Unique
        $reportAddMod= $reportAddMod| Sort-Object -Unique
        $reportDel   = $reportDel   | Sort-Object -Unique

        Write-Host "Models Add/Mod : $($modelAddMod -join ', ')"
        Write-Host "Models Deleted : $($modelDel -join ', ')"
        Write-Host "Reports Add/Mod: $($reportAddMod -join ', ')"
        Write-Host "Reports Deleted: $($reportDel -join ', ')"

        $totalChanges = $modelAddMod.Count + $modelDel.Count + $reportAddMod.Count + $reportDel.Count
        if ($totalChanges -eq 0) {
          Write-Host "No changes detected. Exiting pipeline."
          exit 0
        }

        #
        # 4) Retrieve UAT Workspace
        #
        $ws = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
        if (-not $ws) {
          throw "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
        }
        $workspaceID = $ws.Id
        $allItems    = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET

        #
        # 5) Dictionary for Newly Imported Model IDs if Both Are Committed
        #
        $localModelIds = @{}  # e.g. "report 38" => "ID"

        #
        # Helper to import local .pbism
        #
        function Import-LocalSemanticModel($pbismFile, $wsId) {
          $pbismDir = Split-Path $pbismFile -Parent
          $imported = Import-FabricItem -workspaceId $wsId -path $pbismDir
          Write-Host "Semantic model imported => $($imported.displayName) [Id=$($imported.id)]"
          return $imported.id
        }

        #
        # Helper to find existing model in the workspace
        #
        function Find-ExistingSMInWorkspace($nameCandidate, $items) {
          $found = $items | Where-Object {
            $_.type -eq "PowerBIModel" -and $_.displayName -eq $nameCandidate
          }
          return $found
        }

        #
        # 6) Import Changed Models First + Store Their IDs
        #
        if ($modelAddMod.Count -gt 0) {
          Write-Host "Importing changed semantic models..."
          foreach ($mFile in $modelAddMod) {
            # Example: if "report 38.SemanticModel/definition.pbism" changed
            # baseName might be "report 38"
            $mDir   = Split-Path $mFile -Parent
            $folder = [System.IO.Path]::GetFileName($mDir)
            # E.g. folder "report 38.SemanticModel" => base "report 38"
            $baseName = $folder.Replace(".SemanticModel","")

            Write-Host "Importing model => $mDir"
            $imp      = Import-FabricItem -workspaceId $workspaceID -path $mDir
            Write-Host "Model imported => $($imp.displayName) [Id=$($imp.id)]"
            $localModelIds[$baseName] = $imp.id
          }

          # Refresh workspace items after importing
          $allItems = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET
        }

        #
        # 7) Handle Model Deletions if needed
        #
        if ($modelDel.Count -gt 0) {
          Write-Host "Handling deleted models if required..."
          foreach ($delM in $modelDel) {
            Write-Host "Model file deleted => $delM"
            # Optionally remove from the workspace with Remove-FabricItem ...
          }
        }

        #
        # 8) Resolve Model ID for a changed report
        #
        function Resolve-SemanticModelId($reportFile, $wsId, $allItems) {
          $reportDir  = Split-Path $reportFile -Parent
          $folderName = [System.IO.Path]::GetFileName($reportDir)

          # e.g. "report 38.Report" => base "report 38"
          $baseName   = $folderName.Replace(".Report","")
          
          # If we see $baseName in $localModelIds, no searching needed
          if ($localModelIds.ContainsKey($baseName)) {
            Write-Host "Found newly imported model ID => $($localModelIds[$baseName]) for $baseName"
            return $localModelIds[$baseName]
          }

          # Otherwise fallback: local folder or existing workspace model
          $modelFolder = $folderName.Replace(".Report",".SemanticModel")
          if (Test-Path $modelFolder) {
            $pbism = Get-ChildItem -Path $modelFolder -Recurse -Include '*.pbism' -File
            if ($pbism) {
              Write-Host "Importing local model from $modelFolder..."
              return Import-LocalSemanticModel $pbism[0].FullName $wsId
            }
          }

          $possibleNames = @($baseName, $modelFolder, $folderName)
          foreach ($candidate in $possibleNames) {
            $found = Find-ExistingSMInWorkspace $candidate $allItems
            if ($found) {
              $f = $found | Select-Object -First 1
              Write-Host "Found existing model => $($f.displayName) [Id=$($f.id)]"
              return $f.id
            }
          }

          throw "Cannot find or import a semantic model for $reportFile. Tried base '$baseName' & folder '$modelFolder'."
        }

        #
        # 9) Import Changed Reports with SM
        #
        if ($reportAddMod.Count -gt 0) {
          Write-Host "Importing changed reports..."
          foreach ($rFile in $reportAddMod) {
            $smId   = Resolve-SemanticModelId $rFile $workspaceID $allItems
            $repDir = Split-Path $rFile -Parent

            Import-FabricItem -workspaceId $workspaceID -path $repDir -itemProperties @{ semanticModelId = $smId } | Out-Null
            Write-Host "Report imported => $rFile attached to SM=$smId"
          }
        }

        #
        # 10) Handle Deleted Reports if needed
        #
        if ($reportDel.Count -gt 0) {
          Write-Host "Handling deleted reports if required..."
          foreach ($delR in $reportDel) {
            Write-Host "Report file deleted => $delR"
            # Optionally remove from workspace with Remove-FabricItem ...
          }
        }

        Write-Host "Promotion to UAT completed successfully."
      }
      catch {
        $err = $_
        Write-Error ("ERROR: {0}" -f $err)
        throw $err
      }
  env:
    CLIENT_SECRET: $(Clientsecret)
    CLIENT_ID: $(clinetid)
    TENANT_ID: $(tenantid)
    UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
    UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)

-------------------------------------------


- checkout: self
  fetchDepth: 0
  displayName: "Checkout (Full Depth)"

- task: PowerShell@2
  displayName: "Promote to UAT"
  inputs:
    pwsh: true
    targetType: inline
    script: |
      try {
        #
        # 1) Import Required Modules & Authenticate
        #
        Import-Module Az.Accounts -ErrorAction Stop
        Import-Module MicrosoftPowerBIMgmt -ErrorAction Stop
        Import-Module FabricPS-PBIP -ErrorAction Stop

        $secret     = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
        $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
        $tenantId   = $env:TENANT_ID.Trim()

        $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
          [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
        )

        $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
        $isSPN      = $false
        if ($credential.UserName -match $guidRegex) {
          $isSPN = $true
        }

        if ($isSPN) {
          Set-FabricAuthToken -servicePrincipalId $credential.UserName `
            -servicePrincipalSecret $plainTextPwd `
            -tenantId $tenantId -reset
        } else {
          Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
        }

        $authToken = Get-FabricAuthToken
        if (-not $authToken) {
          throw "Fabric authentication failed."
        }

        Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential

        $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
        $oneLakeUri = [System.Uri]"$($env:UAT_ONELAKE_ENDPOINT)".Trim()
        $domain     = $oneLakeUri.Host
        $azLogin    = azcopy login `
          --service-principal `
          --application-id $credential.UserName `
          --tenant-id $tenantId `
          --trusted-microsoft-suffixes="$domain" `
          --output-type json | ConvertFrom-Json

        if (-not ($azLogin | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." })) {
          throw "AzCopy login failed."
        }

        if ($isSPN) {
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop
        } else {
          Connect-PowerBIServiceAccount -Credential $credential -TenantId $tenantId -ErrorAction Stop
        }

        #
        # 2) Compare HEAD~1..HEAD (Fallback if HEAD~1 doesn't exist)
        #
        if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
          $baseCommit = "HEAD~1"
          $headCommit = "HEAD"
        } else {
          $baseCommit = "HEAD"
          $headCommit = "HEAD"
        }
        Write-Host "Comparing commits: $baseCommit..$headCommit"

        #
        # 3) Detect Changed/Deleted Files
        #
        $modelPatterns  = @('**/*.pbism')
        $reportPatterns = @('**/*.pbir','**/*.pbix','**/*.json')

        $modelAddMod = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $modelPatterns)
        $modelDel    = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $modelPatterns)
        $reportAddMod= @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $reportPatterns)
        $reportDel   = @(git diff --name-only --relative --diff-filter=D  $baseCommit $headCommit -- $reportPatterns)

        $modelAddMod = $modelAddMod | Sort-Object -Unique
        $modelDel    = $modelDel    | Sort-Object -Unique
        $reportAddMod= $reportAddMod| Sort-Object -Unique
        $reportDel   = $reportDel   | Sort-Object -Unique

        Write-Host "Models Add/Mod : $($modelAddMod -join ', ')"
        Write-Host "Models Deleted : $($modelDel -join ', ')"
        Write-Host "Reports Add/Mod: $($reportAddMod -join ', ')"
        Write-Host "Reports Deleted: $($reportDel -join ', ')"

        $totalChanges = $modelAddMod.Count + $modelDel.Count + $reportAddMod.Count + $reportDel.Count
        if ($totalChanges -eq 0) {
          Write-Host "No changes detected. Exiting pipeline."
          exit 0
        }

        #
        # 4) Retrieve UAT Workspace
        #
        $workspace = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
        if (-not $workspace) {
          throw "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
        }
        $workspaceID = $workspace.Id
        $allItems    = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET

        #
        # 5) Dictionary for newly imported model IDs if both are committed
        #
        $modelIds = @{}  # e.g. "report 38" => "SM_ID"

        #
        # Helper to import .pbism
        #
        function Import-LocalSemanticModel($pbismFile, $wsId) {
          $pbismDir = Split-Path $pbismFile -Parent
          $imported = Import-FabricItem -workspaceId $wsId -path $pbismDir
          Write-Host "Semantic model imported => $($imported.displayName) [Id=$($imported.id)]"
          return $imported.id
        }

        #
        # Helper to find an existing model in workspace
        #
        function Find-ExistingSM($nameCandidate, $items) {
          $found = $items | Where-Object {
            $_.type -eq "PowerBIModel" -and $_.displayName -eq $nameCandidate
          }
          return $found
        }

        #
        # 6) Import Changed Models first & store ID for baseName
        #
        if ($modelAddMod.Count -gt 0) {
          Write-Host "Importing changed semantic models..."
          foreach ($mFile in $modelAddMod) {
            # e.g. if path is 'report 38.SemanticModel/definition.pbism'
            $mDir   = Split-Path $mFile -Parent
            $folder = [System.IO.Path]::GetFileName($mDir)
            $base   = $folder.Replace(".SemanticModel","")

            Write-Host "Importing model => $mDir"
            $imported = Import-FabricItem -workspaceId $workspaceID -path $mDir
            Write-Host "Model imported => $($imported.displayName) [Id=$($imported.id)]"

            # Store the ID in dictionary for direct usage
            $modelIds[$base] = $imported.id
          }

          # refresh allItems after model import
          $allItems = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET
        }

        #
        # 7) Handle model deletions if needed
        #
        if ($modelDel.Count -gt 0) {
          foreach ($delM in $modelDel) {
            Write-Host "Deleted model => $delM"
            # optionally remove from workspace
          }
        }

        #
        # 8) Function to resolve SM ID if only the report changed
        #
        function Fallback-ResolveSemanticModel($reportFile, $wsId, $allItems) {
          $rDir   = Split-Path $reportFile -Parent
          $folder = [System.IO.Path]::GetFileName($rDir)
          $base   = $folder.Replace(".Report","")
          $modelFold = $folder.Replace(".Report",".SemanticModel")

          # if local folder exists, import
          if (Test-Path $modelFold) {
            $pbism = Get-ChildItem -Path $modelFold -Recurse -Include '*.pbism' -File
            if ($pbism) {
              return Import-LocalSemanticModel $pbism[0].FullName $wsId
            }
          }

          # else search workspace
          $candidates = @($base, $modelFold, $folder)
          foreach ($cand in $candidates) {
            $found = Find-ExistingSM $cand $allItems
            if ($found) {
              $f = $found | Select-Object -First 1
              Write-Host "Found existing model => $($f.displayName) [Id=$($f.id)]"
              return $f.id
            }
          }

          throw "Cannot find or import a semantic model for $reportFile (fallback)."
        }

        #
        # 9) Import changed reports
        #
        if ($reportAddMod.Count -gt 0) {
          Write-Host "Importing changed reports..."
          foreach ($rFile in $reportAddMod) {
            $rDir   = Split-Path $rFile -Parent
            $folder = [System.IO.Path]::GetFileName($rDir)
            $base   = $folder.Replace(".Report","")

            # If user committed both model & report => we have $modelIds[$base]
            if ($modelIds.ContainsKey($base)) {
              Write-Host "Both model & report committed => using modelIds[$base] directly"
              $smId = $modelIds[$base]
            }
            else {
              # fallback scenario if only the report changed
              $smId = Fallback-ResolveSemanticModel $rFile $workspaceID $allItems
            }

            Import-FabricItem -workspaceId $workspaceID -path $rDir -itemProperties @{ semanticModelId = $smId } | Out-Null
            Write-Host "Report imported => $rFile attached to SM=$smId"
          }
        }

        #
        # 10) Handle report deletions if needed
        #
        if ($reportDel.Count -gt 0) {
          foreach ($delR in $reportDel) {
            Write-Host "Deleted report => $delR"
            # optionally remove from workspace
          }
        }

        Write-Host "Promotion to UAT completed successfully."
      }
      catch {
        $err = $_
        Write-Error ("ERROR: {0}" -f $err)
        throw $err
      }
  env:
    CLIENT_SECRET: $(Clientsecret)
    CLIENT_ID: $(clinetid)
    TENANT_ID: $(tenantid)
    UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
    UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)

==================calude-----------------

- task: PowerShell@2
  displayName: "Promote to UAT"
  inputs:
    pwsh: true
    targetType: inline
    script: |
      try {
          # Import Required Modules & Authenticate
          Import-Module Az.Accounts -ErrorAction Stop
          Import-Module MicrosoftPowerBIMgmt -ErrorAction Stop
          Import-Module FabricPS-PBIP -ErrorAction Stop

          $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
          $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
          $tenantId = $env:TENANT_ID.Trim()

          $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password))

          $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
          $isSPN = $false
          if ($credential.UserName -match $guidRegex) {
              $isSPN = $true
          }

          if ($isSPN) {
              Set-FabricAuthToken -servicePrincipalId $credential.UserName -servicePrincipalSecret $plainTextPwd -tenantId $tenantId -reset
          } else {
              Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
          }

          $authToken = Get-FabricAuthToken
          if (-not $authToken) {
              throw "Fabric authentication failed"
          }

          Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential

          $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
          $oneLakeUri = [System.Uri]"$($env:UAT_ONELAKE_ENDPOINT)".Trim()
          $domain = $oneLakeUri.Host
          $azLogin = azcopy login --service-principal --application-id $credential.UserName --tenant-id $tenantId --trusted-microsoft-suffixes="$domain" --output-type json | ConvertFrom-Json
          
          if (-not ($azLogin | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." })) {
              throw "AzCopy login failed"
          }

          Write-Host "=== Connecting to Power BI Service ==="
          if ($isSPN) {
              Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop
          } else {
              Connect-PowerBIServiceAccount -Credential $credential -TenantId $tenantId -ErrorAction Stop
          }

          # Get commit range
          if ((git rev-parse HEAD~1) -and ($LASTEXITCODE -eq 0)) {
              $baseCommit = "HEAD~1"
              $headCommit = "HEAD"
          } else {
              $baseCommit = "HEAD"
              $headCommit = "HEAD"
          }
          Write-Host "Comparing commits: $baseCommit..$headCommit"

          # Detect Changes
          Write-Host "=== Detecting Changes ==="
          $modelPatterns = @('**/*.pbism')
          $reportPatterns = @('**/*.pbir', '**/*.pbix', '**/*.json')

          $modelAddMod = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $modelPatterns)
          $modelDel = @(git diff --name-only --relative --diff-filter=D $baseCommit $headCommit -- $modelPatterns)
          $reportAddMod = @(git diff --name-only --relative --diff-filter=AM $baseCommit $headCommit -- $reportPatterns)
          $reportDel = @(git diff --name-only --relative --diff-filter=D $baseCommit $headCommit -- $reportPatterns)

          $modelAddMod = $modelAddMod | Sort-Object -Unique
          $modelDel = $modelDel | Sort-Object -Unique
          $reportAddMod = $reportAddMod | Sort-Object -Unique
          $reportDel = $reportDel | Sort-Object -Unique

          Write-Host "Models Add/Mod: $($modelAddMod -join ', ')"
          Write-Host "Models Deleted: $($modelDel -join ', ')"
          Write-Host "Reports Add/Mod: $($reportAddMod -join ', ')"
          Write-Host "Reports Deleted: $($reportDel -join ', ')"

          $totalChanges = $modelAddMod.Count + $modelDel.Count + $reportAddMod.Count + $reportDel.Count
          if ($totalChanges -eq 0) {
              Write-Host "No changes detected. Exiting pipeline."
              exit 0
          }

          # Get workspace
          Write-Host "=== Getting UAT Workspace ==="
          $ws = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"
          if (-not $ws) {
              throw "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found"
          }
          $workspaceID = $ws.Id
          $allItems = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET

          # Dictionary for model IDs
          $localModelIds = @{}

          function Import-LocalSemanticModel($pbismFile, $wsId) {
              $pbismDir = Split-Path $pbismFile -Parent
              $imported = Import-FabricItem -workspaceId $wsId -path $pbismDir
              Write-Host "Semantic model imported: $($imported.displayName) [Id=$($imported.id)]"
              return $imported.id
          }

          function Find-ExistingSMInWorkspace($nameCandidate, $items) {
              return $items | Where-Object {
                  $_.type -eq "semanticModel" -and $_.displayName -eq $nameCandidate
              }
          }

          function Find-ModelInCommit($reportBaseName) {
              return $modelAddMod | Where-Object {
                  $modelDir = Split-Path $_ -Parent
                  $modelFolderName = [System.IO.Path]::GetFileName($modelDir)
                  $modelBaseName = $modelFolderName.Replace(".SemanticModel", "")
                  return $modelBaseName -eq $reportBaseName
              }
          }

          function Resolve-SemanticModelId($reportFile, $wsId, $allItems) {
              $reportDir = Split-Path $reportFile -Parent
              $folderName = [System.IO.Path]::GetFileName($reportDir)
              $baseName = $folderName.Replace(".Report", "")
              
              Write-Host "Resolving model for report: $reportFile"

              # Check if model is in current commit
              $matchingModel = Find-ModelInCommit $baseName
              if ($matchingModel) {
                  Write-Host "Found matching model in current commit: $matchingModel"
                  if (-not $localModelIds.ContainsKey($baseName)) {
                      $modelDir = Split-Path $matchingModel -Parent
                      Write-Host "Importing model from $modelDir"
                      $importedModel = Import-FabricItem -workspaceId $wsId -path $modelDir
                      $localModelIds[$baseName] = $importedModel.id
                  }
                  return $localModelIds[$baseName]
              }

              # Check cached models
              if ($localModelIds.ContainsKey($baseName)) {
                  Write-Host "Using cached model ID: $($localModelIds[$baseName])"
                  return $localModelIds[$baseName]
              }

              # Check local folder
              $modelFolder = $folderName.Replace(".Report", ".SemanticModel")
              if (Test-Path $modelFolder) {
                  $pbism = Get-ChildItem -Path $modelFolder -Include "*.pbism" -File -Recurse | Select-Object -First 1
                  if ($pbism) {
                      Write-Host "Found local model: $($pbism.FullName)"
                      return Import-LocalSemanticModel $pbism.FullName $wsId
                  }
              }

              # Check workspace
              $possibleNames = @($baseName, $modelFolder, $folderName)
              foreach ($name in $possibleNames) {
                  $found = Find-ExistingSMInWorkspace $name $allItems
                  if ($found) {
                      $model = $found | Select-Object -First 1
                      Write-Host "Found existing model: $($model.displayName) [Id=$($model.id)]"
                      return $model.id
                  }
              }

              throw "Cannot find semantic model for $reportFile. No matching model found in commit, local folder, or workspace."
          }

          # Process Models
          if ($modelAddMod.Count -gt 0) {
              Write-Host "=== Importing Changed Models ==="
              foreach ($mFile in $modelAddMod) {
                  $mDir = Split-Path $mFile -Parent
                  $folder = [System.IO.Path]::GetFileName($mDir)
                  $baseName = $folder.Replace(".SemanticModel", "")

                  Write-Host "Importing model from: $mDir"
                  try {
                      $imp = Import-FabricItem -workspaceId $workspaceID -path $mDir
                      Write-Host "Model imported successfully: $($imp.displayName) [Id=$($imp.id)]"
                      $localModelIds[$baseName] = $imp.id
                  }
                  catch {
                      Write-Error "Failed to import model $mDir`: $_"
                      throw
                  }
              }
              $allItems = Invoke-FabricAPIRequest -Uri "workspaces/$workspaceID/items" -Method GET
          }

          # Process Reports
          if ($reportAddMod.Count -gt 0) {
              Write-Host "=== Importing Changed Reports ==="
              foreach ($rFile in $reportAddMod) {
                  Write-Host "Processing report: $rFile"
                  $smId = Resolve-SemanticModelId $rFile $workspaceID $allItems
                  $repDir = Split-Path $rFile -Parent

                  Import-FabricItem -workspaceId $workspaceID -path $repDir -itemProperties @{ semanticModelId = $smId }
                  Write-Host "Report imported and linked to model ID: $smId"
              }
          }

          # Handle Deletions
          if ($modelDel.Count -gt 0 -or $reportDel.Count -gt 0) {
              Write-Host "=== Processing Deletions ==="
              foreach ($delM in $modelDel) {
                  Write-Host "Model deleted: $delM"
              }
              foreach ($delR in $reportDel) {
                  Write-Host "Report deleted: $delR"
              }
          }

          Write-Host "=== Promotion to UAT completed successfully ==="
      }
      catch {
          Write-Error "Deployment failed: $_"
          Write-Error $_.ScriptStackTrace
          throw
      }
  env:
    CLIENT_SECRET: $(Clientsecret)
    CLIENT_ID: $(clinetid)
    TENANT_ID: $(tenantid)
    UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
    UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)
