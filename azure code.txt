trigger:
  branches:
    include:
      - develop

pool:
  vmImage: 'windows-latest'

variables:
  group: powerbi # Ensure this variable group contains clientid, clientsecret, and tenantid
  SOURCE_WORKSPACE_ID: "c017440f-4a5b-46bd-a2c0-93ee3f04ab4d"
  TARGET_WORKSPACE_ID: "a4628c7b-adda-4285-8c1f-758b19162d0b"
  MODULE_LIST: |
    MicrosoftPowerBIMgmt
    Invoke-DQVTesting
    Invoke-SemanticModelRefresh

steps:
# Step 1: Checkout Repository
- checkout: self
  displayName: 'Checkout Repository'
- task: PowerShell@2
  displayName: 'Setup PowerShell Environment'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
      Set-PSRepository -Name "PSGallery" -InstallationPolicy Trusted
      Install-Module PowerShellGet -Force -AllowClobber -Scope CurrentUser

- task: PowerShell@2
  displayName: 'Remove AzureRM Module if Loaded and Install Az Module'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      # Remove any AzureRM module that might be loaded in the session
      Get-Module AzureRM* -ListAvailable | Remove-Module -Force -ErrorAction SilentlyContinue

      # Install Az Module explicitly to avoid conflicts
      Install-Module -Name Az.Accounts -Force -AllowClobber -Scope CurrentUser
# Step 2: Install Dependencies Dynamically
- task: PowerShell@2
  displayName: 'Install Required Modules'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Installing dependencies dynamically..."

      # Include Az.Accounts module in the list
      $modules = @(
        "Az.Accounts"
        "MicrosoftPowerBIMgmt"
        "Invoke-DQVTesting"
        "Invoke-SemanticModelRefresh"
      )
      
      # Loop through the modules and install if missing
      foreach ($module in $modules) {
        Write-Host "Checking module: $module"
        if (-not (Get-Module -ListAvailable -Name $module)) {
          Write-Host "Installing module: $module"
          Install-Module -Name $module -Scope CurrentUser -Force -ErrorAction Stop
        } else {
          Write-Host "Module $module is already installed."
        }
      }
# Step 3: Authenticate with Azure and Power BI Service
- task: PowerShell@2
  displayName: 'Authenticate with Azure and Power BI Service'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Authenticating with Azure and Power BI Service..."

      # Setup variables for credentials
      $clientSecret = "${{ variables.Clientsecret }}"
      $clientId = "${{ variables.clinetid }}"
      $tenantId = "${{ variables.tenantid }}"

      # Directly login to Azure
      Write-Host "Logging in to Azure using Service Principal..."
      Connect-AzAccount -ServicePrincipal -TenantId $tenantId -ApplicationId $clientId -CertificateThumbprint $clientSecret -ErrorAction Stop

      Write-Host "Azure authentication successful."

      # Optionally set Fabric Auth Token if required
      Write-Host "Setting Fabric authentication token..."
      Set-FabricAuthToken -servicePrincipalId $clientId `
                          -servicePrincipalSecret $clientSecret `
                          -tenantId $tenantId -reset

      Write-Host "Authentication with Azure and Power BI Service completed successfully!"










# Step 4: Detect Changes in Commit
- task: PowerShell@2
  displayName: 'Detect Changes in Commit'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Detecting changes in the latest commit..."
      $changedFiles = git diff --name-only HEAD~1 HEAD
      Write-Host "Changed files detected:"
      Write-Host $changedFiles

# Step 5: Validate Semantic Models and Reports
- task: PowerShell@2
  displayName: 'Validate Semantic Models and Reports'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Validating Semantic Models and Reports..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel") {
          Write-Host "Running Semantic Model Validation for: $file"
          Invoke-SemanticModelRefresh -ModelPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
        if ($file -match "report") {
          Write-Host "Running Data Quality Validation for: $file"
          Invoke-DQVTesting -ReportPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
      }

# Step 6: Promote Files to UAT
- task: PowerShell@2
  displayName: 'Promote Files to UAT'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Promoting files to UAT..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel" -or $file -match "report") {
          Write-Host "Promoting $file to UAT Workspace..."
          Publish-PowerBIFile -Path $file -SourceWorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }} -TargetWorkspaceId ${{ variables.TARGET_WORKSPACE_ID }}
        }
      }

# Step 7: Log Results
- task: PowerShell@2
  displayName: 'Log Results'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Logging results..."
      # Log timestamp
      Get-Date | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      # Log changes and promotions
      foreach ($file in $changedFiles) {
        $logEntry = "Promoted file: $file"
        $logEntry | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      }
      Write-Host "Logs stored in: $(Pipeline.Workspace)/log.txt"





---------------------------------------------------------------------------



parameters:
  - name: WORKSPACE_NAME
    displayName: "Workspace name to conduct tests?"
    type: string
    default: 'YourWorkspaceName'  # Replace with your default workspace name

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains Clientsecret, clinetid, tenantid
  - name: WORKSPACE_NAME
    value: '${{ parameters.WORKSPACE_NAME }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      - task: PowerShell@2
        displayName: 'Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

      - task: PowerShell@2
        displayName: 'Install Dependencies'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      - task: PowerShell@2
        displayName: 'Deploy Changes and Conduct Testing'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                if (-not ${env:clinetid} -or -not ${env:Clientsecret} -or -not ${env:tenantid}) {
                    Write-Error "Missing one or more required environment variables: clinetid, Clientsecret, tenantid"
                    throw
                }

                $secret = ${env:Clientsecret} | ConvertTo-SecureString -AsPlainText -Force
                $credential = New-Object System.Management.Automation.PSCredential (${env:clinetid}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:tenantid}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
                  [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                )

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                }

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Dataset/**/*.SemanticModel/**')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Report/**')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get workspace Id
                $workspaceObj = Get-FabricWorkspace -workspaceName "${env:WORKSPACE_NAME}"
                $workspaceID = $workspaceObj.Id

                # ----------- Handle Semantic Models For Promotion ----------- #
                # Identify Semantic Models changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipDSChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $smPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $smPathsToPromote = $smPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $smPromotedItems = @()

                # Promote semantic models to workspace
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "##[debug]Promoting semantic model at $($promotePath) to workspace ${env:WORKSPACE_NAME}"
                    $smPromotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath
                    $smPromotedItems += $smPromotedItem
                }

                # ----------- Promote Reports ----------- #
                # Retrieve all items in workspace (after semantic models have been promoted)
                $items = Invoke-FabricAPIRequest -Uri "workspaces/${workspaceID}/items" -Method Get

                # Identify Reports changed
                $rptPathsToPromote = @()
                $filter = "*.pbir"

                foreach ($change in $pbipRPTChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $rptPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $rptPathsToPromote = $rptPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $rptPromotedItems = @()

                Write-Host "##[debug] rptPathsToPromote: $($rptPathsToPromote)"

                # Promote reports to workspace
                foreach ($promotePath in $rptPathsToPromote) {
                    # Get report definition
                    $def = Get-ChildItem -Path $promotePath -Recurse -Include "definition.pbir"
                    $semanticModelPath = (Get-Content $def.FullName | ConvertFrom-Json).datasetReference.byPath

                    Write-Host "##[debug] SemanticModelPath: $($semanticModelPath)"

                    # If byPath was null, we'll assume byConnection is set and skip
                    if ($semanticModelPath -ne $null) {
                        # Semantic Model path is relative to the report path, Join-Path can handle relative paths
                        $pathToCheck = Join-Path $promotePath $semanticModelPath.path
                        $metadataSM = Get-ChildItem -Path $pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                      Where-Object { (Split-Path -Path $_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $_.FullName).EndsWith(".SemanticModel") }

                        if ($metadataSM -ne $null) {
                            $content = Get-Content $metadataSM.FullName | ConvertFrom-Json

                            # Handle item.metadata.json
                            if ($metadataSM.Name -eq "item.metadata.json") {
                                # Prior to March-2024 release
                                $semanticModelName = $content.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            } else {
                                $semanticModelName = $content.metadata.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            }
                        } else {
                            Write-Host "##[error] Semantic Model definition not found in workspace."
                        }
                    }

                    # Get the semantic model id from items in the workspace
                    $semanticModel = $items | Where-Object { $_.type -eq "SemanticModel" -and $_.displayName -eq $semanticModelName }

                    Write-Host "##[debug] semanticModel: $($semanticModel)"

                    if (!$semanticModel) {
                        Write-Host "##[error] Semantic Model not found in workspace."
                    } else {
                        # Import report with appropriate semantic model id
                        Write-Host "##[debug] Promoting report at $($promotePath) to workspace ${env:WORKSPACE_NAME}"
                        $promotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath -itemProperties @{ semanticmodelId = "$($semanticModel.id)" }
                        $rptPromotedItems += $promotedItem
                    }
                }

                # ----------- Run Refreshes and Tests ----------- #

                # Generate Run GUID
                $runGuid = (New-Guid).Guid
                $projectName = $($env:SYSTEM_TEAMPROJECT)
                $repoName = $($env:BUILD_REPOSITORY_NAME)
                $branchName = $($env:BUILD_SOURCEBRANCHNAME)
                $userName = "$($env:BUILD_REQUESTEDFOREMAIL)"
                $buildReason = "$($env:BUILD_REASON)"

                if ($buildReason -eq 'schedule' -or $buildReason -eq 'ScheduleForced') {
                    $userName = "Scheduled - Build-Agent"
                }

                Write-Host "##[debug]Run GUID: $($runGuid)"
                Write-Host "##[debug]Project Name: $($projectName)"
                Write-Host "##[debug]Repository Name: $($repoName)"
                Write-Host "##[debug]Branch Name: $($branchName)"
                Write-Host "##[debug]User Name: $($userName)"

                $idqVersion = (Get-Module -Name "Invoke-DQVTesting" -ListAvailable).Version.toString()
                $testResults = @()

                # Get UTC representation of run
                $dateTimeofRun = (Get-Date -Format "yyyy-MM-ddTHH-mm-ssZ")
                $fileName = "$($dateTimeofRun)-$($runGuid).csv"

                # Run synchronous refresh for each semantic model
                foreach ($promotedItem in $smPromotedItems) {
                    # Test refresh which validates functionality
                    Invoke-SemanticModelRefresh -WorkspaceId $workspaceID `
                        -SemanticModelId $promotedItem.Id `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -Environment Public `
                        -LogOutput "ADO"
                }

                # Run tests for functionality and data accuracy
                foreach ($promotedItem in $smPromotedItems) {
                    $testResults += Invoke-DQVTesting -WorkspaceName "${env:WORKSPACE_NAME}" `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -DatasetId $promotedItem.Id `
                        -LogOutput "Table"
                }

                # Add additional properties to the array of objects
                $i = 0

                $testResults | ForEach-Object {
                    Add-Member -InputObject $_ -Name "BranchName" -Value $branchName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RepositoryName" -Value $repoName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "ProjectName" -Value $projectName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "UserName" -Value $userName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunID" -Value $runGuid -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "Order" -Value $i -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunDateTime" -Value $dateTimeofRun -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "InvokeDQTestingVersion" -Value $idqVersion -MemberType NoteProperty
                    $i++
                }

                $testResults | Select-Object * | Export-Csv -Path ".\$fileName"

                $getAbsPath = (Resolve-Path ".\$fileName").Path

                Write-Host "##[debug] Test Results for $($promotedItem.Id) saved locally to $($getAbsPath)."

                # Output test results
                $testResults | ForEach-Object {
                    $prefix = "##[debug]"
                    switch ($_.LogType) {
                        'Warning' { $prefix = "##vso[task.logissue type=warning]" }
                        'Error' { $prefix = "##vso[task.logissue type=error]" }
                        'Failure' { $prefix = "##vso[task.complete result=Failed;]" }
                        'Success' { $prefix = "##vso[task.complete result=Succeeded;]" }
                    }
                    Write-Host "$($prefix)$($_.Message)"
                }

            } catch {
                Write-Error "Authentication or processing failed: $_"
                throw
            }
        env:
          Clientsecret: $(Clientsecret)
          clinetid: $(clinetid)
          tenantid: $(tenantid)
          WORKSPACE_NAME: $(WORKSPACE_NAME)


--------------------------------------------------------------------------------

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains Clientsecret, clinetid, tenantid
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      - task: PowerShell@2
        displayName: 'Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

      - task: PowerShell@2
        displayName: 'Install Dependencies'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      - task: PowerShell@2
        displayName: 'Deploy Changes and Conduct Testing'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                if (-not ${env:clinetid} -or -not ${env:Clientsecret} -or -not ${env:tenantid}) {
                    Write-Error "Missing one or more required environment variables: clinetid, Clientsecret, tenantid"
                    throw
                }

                $secret = ${env:Clientsecret} | ConvertTo-SecureString -AsPlainText -Force
                $credential = New-Object System.Management.Automation.PSCredential (${env:clinetid}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:tenantid}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
                  [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                )

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                }

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Dataset/**/*.SemanticModel/**')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Report/**')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get Dev and UAT workspace IDs
                $devWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:DEV_WORKSPACE_NAME}"
                $devWorkspaceID = $devWorkspaceObj.Id

                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:UAT_WORKSPACE_NAME}"
                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Identify Semantic Models changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipDSChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $smPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $smPathsToPromote = $smPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $smPromotedItems = @()

                # Promote semantic models to UAT workspace
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "##[debug]Promoting semantic model at $($promotePath) to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                    $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath
                    $smPromotedItems += $smPromotedItem
                }

                # ----------- Retrieve Items in UAT Workspace ----------- #
                $items = Invoke-FabricAPIRequest -Uri "workspaces/${uatWorkspaceID}/items" -Method Get

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Identify Reports changed
                $rptPathsToPromote = @()
                $filter = "*.pbir"

                foreach ($change in $pbipRPTChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $rptPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $rptPathsToPromote = $rptPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $rptPromotedItems = @()

                Write-Host "##[debug] rptPathsToPromote: $($rptPathsToPromote)"

                # Promote reports to UAT workspace
                foreach ($promotePath in $rptPathsToPromote) {
                    # Get report definition
                    $def = Get-ChildItem -Path $promotePath -Recurse -Include "definition.pbir"
                    $semanticModelPath = (Get-Content $def.FullName | ConvertFrom-Json).datasetReference.byPath

                    Write-Host "##[debug] SemanticModelPath: $($semanticModelPath)"

                    # If byPath was null, we'll assume byConnection is set and skip
                    if ($semanticModelPath -ne $null) {
                        # Semantic Model path is relative to the report path, Join-Path can handle relative paths
                        $pathToCheck = Join-Path $promotePath $semanticModelPath.path
                        $metadataSM = Get-ChildItem -Path $pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                      Where-Object { (Split-Path -Path $_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $_.FullName).EndsWith(".SemanticModel") }

                        if ($metadataSM -ne $null) {
                            $content = Get-Content $metadataSM.FullName | ConvertFrom-Json

                            # Handle item.metadata.json
                            if ($metadataSM.Name -eq "item.metadata.json") {
                                # Prior to March-2024 release
                                $semanticModelName = $content.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            } else {
                                $semanticModelName = $content.metadata.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            }
                        } else {
                            Write-Host "##[error] Semantic Model definition not found."
                            continue
                        }
                    }

                    # Get the semantic model id from items in the UAT workspace
                    $semanticModel = $items | Where-Object { $_.type -eq "SemanticModel" -and $_.displayName -eq $semanticModelName }

                    Write-Host "##[debug] semanticModel: $($semanticModel)"

                    if (!$semanticModel) {
                        Write-Host "##[error] Semantic Model not found in UAT workspace."
                        continue
                    } else {
                        # Import report with appropriate semantic model id
                        Write-Host "##[debug] Promoting report at $($promotePath) to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $promotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -itemProperties @{ semanticmodelId = "$($semanticModel.id)" }
                        $rptPromotedItems += $promotedItem
                    }
                }

                # ----------- Run Refreshes and Tests in UAT Workspace ----------- #

                # Generate Run GUID
                $runGuid = (New-Guid).Guid
                $projectName = $($env:SYSTEM_TEAMPROJECT)
                $repoName = $($env:BUILD_REPOSITORY_NAME)
                $branchName = $($env:BUILD_SOURCEBRANCHNAME)
                $userName = "$($env:BUILD_REQUESTEDFOREMAIL)"
                $buildReason = "$($env:BUILD_REASON)"

                if ($buildReason -eq 'schedule' -or $buildReason -eq 'ScheduleForced') {
                    $userName = "Scheduled - Build-Agent"
                }

                Write-Host "##[debug]Run GUID: $($runGuid)"
                Write-Host "##[debug]Project Name: $($projectName)"
                Write-Host "##[debug]Repository Name: $($repoName)"
                Write-Host "##[debug]Branch Name: $($branchName)"
                Write-Host "##[debug]User Name: $($userName)"

                $idqVersion = (Get-Module -Name "Invoke-DQVTesting" -ListAvailable).Version.toString()
                $testResults = @()

                # Get UTC representation of run
                $dateTimeofRun = (Get-Date -Format "yyyy-MM-ddTHH-mm-ssZ")
                $fileName = "$($dateTimeofRun)-$($runGuid).csv"

                # Run synchronous refresh for each semantic model in UAT workspace
                foreach ($promotedItem in $smPromotedItems) {
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID `
                        -SemanticModelId $promotedItem.Id `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -Environment Public `
                        -LogOutput "ADO"
                }

                # Run tests for functionality and data accuracy in UAT workspace
                foreach ($promotedItem in $smPromotedItems) {
                    $testResults += Invoke-DQVTesting -WorkspaceName "${env:UAT_WORKSPACE_NAME}" `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -DatasetId $promotedItem.Id `
                        -LogOutput "Table"
                }

                # Add additional properties to the array of objects
                $i = 0

                $testResults | ForEach-Object {
                    Add-Member -InputObject $_ -Name "BranchName" -Value $branchName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RepositoryName" -Value $repoName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "ProjectName" -Value $projectName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "UserName" -Value $userName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunID" -Value $runGuid -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "Order" -Value $i -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunDateTime" -Value $dateTimeofRun -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "InvokeDQTestingVersion" -Value $idqVersion -MemberType NoteProperty
                    $i++
                }

                $testResults | Select-Object * | Export-Csv -Path ".\$fileName"

                $getAbsPath = (Resolve-Path ".\$fileName").Path

                Write-Host "##[debug] Test Results saved locally to $($getAbsPath)."

                # Output test results
                $testResults | ForEach-Object {
                    $prefix = "##[debug]"
                    switch ($_.LogType) {
                        'Warning' { $prefix = "##vso[task.logissue type=warning]" }
                        'Error' { $prefix = "##vso[task.logissue type=error]" }
                        'Failure' { $prefix = "##vso[task.complete result=Failed;]" }
                        'Success' { $prefix = "##vso[task.complete result=Succeeded;]" }
                    }
                    Write-Host "$($prefix)$($_.Message)"
                }

            } catch {
                Write-Error "Authentication or processing failed: $_"
                throw
            }
        env:
          Clientsecret: $(Clientsecret)
          clinetid: $(clinetid)
          tenantid: $(tenantid)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
______________________________________________________________________________--trigger:
  branches:
    include:
      - develop

variables:
  - group: powerbi  # Contains Clientsecret, clinetid, tenantid

parameters:
  - name: DEV_WORKSPACE_NAME
    type: string
    default: 'Your_Dev_Workspace_Name'
  - name: UAT_WORKSPACE_NAME
    type: string
    default: 'Your_UAT_Workspace_Name'

pool:
  vmImage: 'windows-latest'

steps:
- checkout: self
  fetchDepth: 0
  displayName: 'Checkout Repository'

- task: PowerShell@2
  displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
  inputs:
    targetType: 'inline'
    script: |
      try {
          # ----------- Import PowerShell Modules ----------- #
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
          Import-Module Az.Accounts -Force
          Import-Module MicrosoftPowerBIMgmt -Force

          # ----------- Setup Credentials ----------- #
          if (-not $env:clinetid -or -not $env:Clientsecret -or -not $env:tenantid) {
              Write-Error "Missing one or more required environment variables: clinetid, Clientsecret, tenantid"
              throw
          }

          $tenantId = $env:tenantid.Trim()
          $clientId = $env:clinetid.Trim()
          $clientSecret = $env:Clientsecret.Trim()

          # Optional debugging checks (avoid printing sensitive data)
          if ($tenantId) {
              Write-Host "Tenant ID is set."
          } else {
              Write-Error "Tenant ID is not set."
              throw
          }

          if ($clientId) {
              Write-Host "Client ID is set."
          } else {
              Write-Error "Client ID is not set."
              throw
          }

          if ($clientSecret) {
              Write-Host "Client Secret is set."
          } else {
              Write-Error "Client Secret is not set."
              throw
          }

          # Convert client secret to secure string
          $secureSecret = ConvertTo-SecureString $clientSecret -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential ($clientId, $secureSecret)

          # Check if service principal or username/password
          $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
          $isServicePrincipal = $false

          if ($credential.UserName -match $guidRegex) {
            $isServicePrincipal = $true
          }

          # ----------- Login to Azure and Fabric ----------- #
          $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
            [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
          )

          # Set Fabric Connection
          if ($isServicePrincipal) {
            Set-FabricAuthToken -servicePrincipalId $credential.UserName `
              -servicePrincipalSecret $plainTextPwd `
              -tenantId $tenantId -reset
          } else {
            Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
          }

          # ----------- Connect to Power BI ----------- #
          if ($isServicePrincipal) {
            Connect-PowerBIServiceAccount -ServicePrincipal `
              -Credential $credential `
              -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
          } else {
            Connect-PowerBIServiceAccount -Credential $credential `
              -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
          }

          Write-Host "Authentication successful."

          # ----------- Process Changes ----------- #
          Write-Host "Processing changes..."

          # Get list of files changed in the current commit
          $changedFiles = @(git diff-tree --no-commit-id --name-only -r $env:BUILD_SOURCEVERSION)

          Write-Host "##[debug]Changed files: $($changedFiles)"

          # Identify Semantic Model changes
          $pbipDSChanges = $changedFiles | Where-Object { $_ -like '*.pbism' }

          # Identify Report changes
          $pbipRPTChanges = $changedFiles | Where-Object { $_ -like '*.pbir' }

          $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
          $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

          # Output detected changes for debugging
          Write-Host "##[debug]Detected Semantic Model Changes: $($pbipDSChanges)"
          Write-Host "##[debug]Detected Report Changes: $($pbipRPTChanges)"

          # Detect if no changes
          if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
              Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
              exit 0
          }

          # ----------- Get Workspace IDs ----------- #
          $devWorkspaceName = "$env:DEV_WORKSPACE_NAME".Trim()
          $uatWorkspaceName = "$env:UAT_WORKSPACE_NAME".Trim()

          $devWorkspaceObj = Get-FabricWorkspace -workspaceName $devWorkspaceName
          $uatWorkspaceObj = Get-FabricWorkspace -workspaceName $uatWorkspaceName

          if (-not $devWorkspaceObj) {
              Write-Error "Dev workspace '$devWorkspaceName' not found."
              throw
          }

          if (-not $uatWorkspaceObj) {
              Write-Error "UAT workspace '$uatWorkspaceName' not found."
              throw
          }

          $devWorkspaceID = $devWorkspaceObj.WorkspaceId
          $uatWorkspaceID = $uatWorkspaceObj.WorkspaceId

          # ----------- Promote Changes ----------- #
          # Prepare paths to promote
          $smPathsToPromote = @()
          foreach ($change in $pbipDSChanges) {
              $smPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
          }

          $rptPathsToPromote = @()
          foreach ($change in $pbipRPTChanges) {
              $rptPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
          }

          # Import Semantic Models
          foreach ($promotePath in $smPathsToPromote) {
              try {
                  Write-Host "Promoting semantic model at $promotePath to UAT workspace $uatWorkspaceName"
                  $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
              } catch {
                  Write-Error "Failed to promote semantic model at $promotePath: $_"
                  throw
              }
          }

          # Import Reports
          foreach ($promotePath in $rptPathsToPromote) {
              try {
                  Write-Host "Promoting report at $promotePath to UAT workspace $uatWorkspaceName"
                  $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
              } catch {
                  Write-Error "Failed to promote report at $promotePath: $_"
                  throw
              }
          }

          Write-Host "Promotion of changes to UAT workspace completed successfully."

          # ----------- DQV Testing ----------- #
          Write-Host "Starting Data Quality Validation (DQV) testing..."

          # Assume you have a DQV script or function to execute
          # Replace the following with your actual DQV testing commands

          try {
              # Example DQV Testing Command
              # Replace with your actual DQV testing logic
              Invoke-DQVTest -workspaceId $uatWorkspaceID -Verbose -Debug
              Write-Host "DQV testing completed successfully."
          } catch {
              Write-Error "DQV testing failed: $_"
              throw
          }

          # ----------- Validate Data Refresh ----------- #
          Write-Host "Validating data refresh..."

          try {
              # Example Data Refresh Command
              # Replace with your actual data refresh logic
              Invoke-SemanticModelRefresh -workspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
              Write-Host "Data refresh validated successfully."
          } catch {
              Write-Error "Data refresh validation failed: $_"
              throw
          }

          Write-Host "All steps completed successfully."

      } catch {
          Write-Error "An error occurred: $_"
          throw
      }
  env:
    DEV_WORKSPACE_NAME: ${{ parameters.DEV_WORKSPACE_NAME }}
    UAT_WORKSPACE_NAME: ${{ parameters.UAT_WORKSPACE_NAME }}

--------------------------------------------------------------------------------------

- task: PowerShell@2
  displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
  inputs:
    pwsh: true
    targetType: 'inline'
    script: |
      try {
          # ----------- Import PowerShell Modules ----------- #
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
          Import-Module Az.Accounts -Force
          Import-Module MicrosoftPowerBIMgmt -Force

          # ----------- Setup Credentials ----------- #
          $secret = ${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
          $credential = [System.Management.Automation.PSCredential]::new(${env:CLIENT_ID}, $secret)

          # Check if service principal or username/password
          $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
          $isServicePrincipal = $false

          if ($credential.UserName -match $guidRegex) {
            $isServicePrincipal = $true
          }

          # ----------- Login to Azure and Fabric ----------- #
          $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
          $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

          # Set Fabric Connection
          if ($isServicePrincipal) {
            Set-FabricAuthToken -servicePrincipalId $credential.UserName `
              -servicePrincipalSecret $plainTextPwd `
              -tenantId ${env:TENANT_ID} -reset
          } else {
            Set-FabricAuthToken -credential $credential -tenantId ${env:TENANT_ID} -reset
          }

          # Set AzCopy Connection
          $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
          $oneLakeUri = New-Object System.Uri("${env:ONELAKE_ENDPOINT}")
          $oneLakeDomain = $oneLakeUri.Host

          $loginResult = azcopy login --service-principal `
            --application-id $credential.UserName `
            --tenant-id "${env:TENANT_ID}" `
            --trusted-microsoft-suffixes="${oneLakeDomain}" `
            --output-type json | ConvertFrom-Json

          # Check if login was successful
          $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

          if (!$checkResult) {
            Write-Host "##[error] Failed to login to azcopy"
            throw "AzCopy login failed."
          }

          Write-Host "Authentication successful."

          # ----------- Connect to Power BI ----------- #
          if ($isServicePrincipal) {
            Connect-PowerBIServiceAccount -ServicePrincipal `
              -Credential $credential `
              -TenantId ${env:TENANT_ID} -ErrorAction Stop -Verbose -Debug
          } else {
            Connect-PowerBIServiceAccount -Credential $credential `
              -TenantId ${env:TENANT_ID} -ErrorAction Stop -Verbose -Debug
          }

          Write-Host "Connected to Power BI successfully."

          # ----------- Process Changes ----------- #
          Write-Host "Processing changes..."

--------------------------------------------------------------------------------

TEMP:



parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: ONELAKE_ENDPOINT
    displayName: "OneLake Endpoint"
    type: string
    default: 'https://onelakeendpoint.fabric.microsoft.com'  # Replace with your actual OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: ONELAKE_ENDPOINT
    value: '${{ parameters.ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Uninstall AzureRM Modules ----------- #
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = ${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new(${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # Set AzCopy Connection
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("${env:ONELAKE_ENDPOINT}")
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="${oneLakeDomain}" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipDSChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRPTChanges)"

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get Dev and UAT workspace IDs
                $devWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:DEV_WORKSPACE_NAME}"
                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:UAT_WORKSPACE_NAME}"

                if (-not $devWorkspaceObj) {
                    Write-Error "Dev workspace '${env:DEV_WORKSPACE_NAME}' not found."
                    throw
                }

                if (-not $uatWorkspaceObj) {
                    Write-Error "UAT workspace '${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $devWorkspaceID = $devWorkspaceObj.Id
                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Prepare paths to promote
                $smPathsToPromote = @()
                foreach ($change in $pbipDSChanges) {
                    $smPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Semantic Models
                foreach ($promotePath in $smPathsToPromote) {
                    try {
                        Write-Host "Promoting semantic model at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath: $_"
                        throw
                    }
                }

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Prepare paths to promote
                $rptPathsToPromote = @()
                foreach ($change in $pbipRPTChanges) {
                    $rptPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Reports
                foreach ($promotePath in $rptPathsToPromote) {
                    try {
                        Write-Host "Promoting report at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote report at $promotePath: $_"
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $uatWorkspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          ONELAKE_ENDPOINT: $(ONELAKE_ENDPOINT)
------------------------------------------------------------------------------------------------------

one lake system varibale:

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Uninstall AzureRM Modules ----------- #
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = ${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new(${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # Set AzCopy Connection
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("${env:ONELAKE_ENDPOINT}")
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="${oneLakeDomain}" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipDSChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRPTChanges)"

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get Dev and UAT workspace IDs
                $devWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:DEV_WORKSPACE_NAME}"
                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:UAT_WORKSPACE_NAME}"

                if (-not $devWorkspaceObj) {
                    Write-Error "Dev workspace '${env:DEV_WORKSPACE_NAME}' not found."
                    throw
                }

                if (-not $uatWorkspaceObj) {
                    Write-Error "UAT workspace '${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $devWorkspaceID = $devWorkspaceObj.Id
                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Prepare paths to promote
                $smPathsToPromote = @()
                foreach ($change in $pbipDSChanges) {
                    $smPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Semantic Models
                foreach ($promotePath in $smPathsToPromote) {
                    try {
                        Write-Host "Promoting semantic model at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath: $_"
                        throw
                    }
                }

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Prepare paths to promote
                $rptPathsToPromote = @()
                foreach ($change in $pbipRPTChanges) {
                    $rptPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Reports
                foreach ($promotePath in $rptPathsToPromote) {
                    try {
                        Write-Host "Promoting report at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote report at $promotePath: $_"
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $uatWorkspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
---------------------------------------------------------


2 lake points:


parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual Dev OneLake endpoint

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual UAT OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Uninstall AzureRM Modules ----------- #
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = $${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = $${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $$false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $$true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # Set AzCopy Connection based on the target OneLake endpoint
                # We need to determine which endpoint to use based on the workspace we're promoting to
                $targetWorkspaceName = "$${env:UAT_WORKSPACE_NAME}".Trim()
                $targetOneLakeEndpoint = "$${env:UAT_ONELAKE_ENDPOINT}".Trim()

                $${env:AZCOPY_SPA_CLIENT_SECRET} = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("$${targetOneLakeEndpoint}")
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="$${oneLakeDomain}" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $$_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $$($pbipDSChanges)"
                Write-Host "##[debug]Detected Report Changes: $$($pbipRPTChanges)"

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "$${env:UAT_WORKSPACE_NAME}"

                if (-not $uatWorkspaceObj) {
                    Write-Error "UAT workspace '$${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Prepare paths to promote
                $smPathsToPromote = @()
                foreach ($change in $pbipDSChanges) {
                    $smPathsToPromote += (Join-Path -Path $${env:BUILD_SOURCESDIRECTORY} -ChildPath $change)
                }

                # Import Semantic Models
                foreach ($promotePath in $smPathsToPromote) {
                    try {
                        Write-Host "Promoting semantic model at $$promotePath to UAT workspace $${env:UAT_WORKSPACE_NAME}"
                        $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $$promotePath -Verbose -Debug
                        Write-Host "Semantic model imported successfully."
                    } catch {
                        Write-Error "Failed to promote semantic model at $$promotePath: $$_"
                        throw
                    }
                }

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Prepare paths to promote
                $rptPathsToPromote = @()
                foreach ($change in $pbipRPTChanges) {
                    $rptPathsToPromote += (Join-Path -Path $${env:BUILD_SOURCESDIRECTORY} -ChildPath $change)
                }

                # Import Reports
                foreach ($promotePath in $rptPathsToPromote) {
                    try {
                        Write-Host "Promoting report at $$promotePath to UAT workspace $${env:UAT_WORKSPACE_NAME}"
                        $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $$promotePath -Verbose -Debug
                        Write-Host "Report imported successfully."
                    } catch {
                        Write-Error "Failed to promote report at $$promotePath: $$_"
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $uatWorkspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $$_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $$_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $$_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)
--------------------------------------------------------------------
reference code imported logic:

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual Dev OneLake endpoint

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual UAT OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # Uninstall AzureRM Modules
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # Install Required PowerShell Modules
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $$_ -OutFile ".\.nuget\custom_modules\$$(Split-Path $$_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = $${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = $${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($$tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$$($$tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($$credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$$($$credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $$guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $$isServicePrincipal = $$false

                if ($$credential.UserName -match $$guidRegex) {
                  $$isServicePrincipal = $$true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $$secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($$credential.Password)
                $$plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($$secureStringPtr)

                # Set Fabric Connection
                if ($$isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $$credential.UserName `
                    -servicePrincipalSecret $$plainTextPwd `
                    -tenantId $$tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $$credential -tenantId $$tenantId -reset
                }

                # Set AzCopy Connection based on the target OneLake endpoint
                $${env:AZCOPY_SPA_CLIENT_SECRET} = $$plainTextPwd
                $$oneLakeUri = New-Object System.Uri("$${env:UAT_ONELAKE_ENDPOINT}".Trim())
                $$oneLakeDomain = $$oneLakeUri.Host

                $$loginResult = azcopy login --service-principal `
                  --application-id $$credential.UserName `
                  --tenant-id $$tenantId `
                  --trusted-microsoft-suffixes="$$oneLakeDomain" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $$checkResult = $$loginResult | Where-Object { $$_.$MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($$isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $$credential `
                    -TenantId $$tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $$credential `
                    -TenantId $$tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $$pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $$pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $$pbipSMChanges = $$pbipSMChanges | Sort-Object -Unique
                $$pbipRptChanges = $$pbipRptChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $$($$pbipSMChanges)"
                Write-Host "##[debug]Detected Report Changes: $$($$pbipRptChanges)"

                # Detect if no changes
                if ($$pbipSMChanges.Count -eq 0 -and $$pbipRptChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $$workspaceObj = Get-FabricWorkspace -workspaceName "$${env:UAT_WORKSPACE_NAME}"

                if (-not $$workspaceObj) {
                    Write-Error "UAT workspace '$${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $$workspaceID = $$workspaceObj.Id

                # ----------- Handle Semantic Models For Promotion ----------- #
                # Identify Semantic Models changed
                $$smPathsToPromote = @()
                $$filter = "*.pbism"

                foreach ($$change in $$pbipSMChanges) {
                    $$parentFolder = Split-Path $$change -Parent
                    while ($$null -ne $$parentFolder -and !(-Test-Path (Join-Path $$parentFolder $$filter))) {
                        $$parentFolder = Split-Path $$parentFolder -Parent
                    }
                    $$smPathsToPromote += $$parentFolder
                }

                # Remove duplicates
                $$smPathsToPromote = @([System.Collections.Generic.HashSet[string]]$$smPathsToPromote)

                # Setup promoted items array
                $$smPromotedItems = @()

                # Promote semantic models to UAT workspace
                foreach ($$promotePath in $$smPathsToPromote) {
                    Write-Host "##[debug]Promoting semantic model at $$($$promotePath) to workspace $${env:UAT_WORKSPACE_NAME}"
                    $$smPromotedItems += Import-FabricItem -workspaceId $$workspaceID -path $$promotePath
                }

                # Retrieve all items in workspace
                $$items = Invoke-FabricRestMethod -Method GET -Url "workspaces/$$workspaceID/items"

                # ----------- Handle Reports For Promotion ----------- #
                # Identify Reports changed
                $$rptPathsToPromote = @()
                $$filter = "*.pbir"

                foreach ($$change in $$pbipRptChanges) {
                    $$parentFolder = Split-Path $$change -Parent
                    while ($$null -ne $$parentFolder -and !(-Test-Path (Join-Path $$parentFolder $$filter))) {
                        $$parentFolder = Split-Path $$parentFolder -Parent
                    }
                    $$rptPathsToPromote += $$parentFolder
                }

                # Remove duplicates
                $$rptPathsToPromote = @([System.Collections.Generic.HashSet[string]]$$rptPathsToPromote)

                # Setup promoted items array
                $$rptPromotedItems = @()

                $$semanticModelName = $$null

                Write-Host "##[debug] rptPathsToPromote: $$($$rptPathsToPromote)"

                # Promote reports to UAT workspace
                foreach ($$promotePath in $$rptPathsToPromote) {
                    # Get report definition
                    $$def = Get-ChildItem -Path $$promotePath -Recurse -Include "definition.pbir"
                    $$semanticModelPath = (Get-Content $$def.FullName | ConvertFrom-Json).datasetReference.byPath

                    Write-Host "##[debug] SemanticModelPath: $$($$semanticModelPath)"

                    # If byPath was null, we'll assume byConnection is set and skip
                    if ($$semanticModelPath -ne $$null) {
                        # Semantic Model path is relative to the report path, Join-Path can handle relative paths
                        $$pathToCheck = Join-Path $$promotePath $$semanticModelPath.path
                        $$metadataSM = Get-ChildItem -Path $$pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                      Where-Object { (Split-Path -Path $$_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $$_.FullName).EndsWith(".SemanticModel") }

                        if ($$metadataSM -ne $$null) {
                            $$content = Get-Content $$metadataSM.FullName | ConvertFrom-Json

                            # Handle item.metadata.json
                            if ($$metadataSM.Name -eq "item.metadata.json") {
                                # Prior to March-2024 release
                                $$semanticModelName = $$content.displayName
                                Write-Host "##[debug] SemanticModelName: $$($$semanticModelName)"
                            } else {
                                $$semanticModelName = $$content.metadata.displayName
                                Write-Host "##[debug] SemanticModelName: $$($$semanticModelName)"
                            }
                        } else {
                            Write-Host "##[vso[task.logissue type=error]Semantic Model definition not found in workspace."
                        }
                    }

                    # Get the semantic model id from items in the workspace
                    $$semanticModel = $$items | Where-Object { $$_.type -eq "SemanticModel" -and $$_.displayName -eq $$semanticModelName }

                    Write-Host "##[debug] semanticModel: $$($$semanticModel)"

                    if (!$$semanticModel) {
                        Write-Host "##[vso[task.logissue type=error]Semantic Model not found in workspace."
                    } else {
                        # Import report with appropriate semantic model id
                        Write-Host "##[debug] Promoting report at $$($$promotePath) to workspace $${env:UAT_WORKSPACE_NAME}"
                        $$promotedItem = Import-FabricItem -workspaceId $$workspaceID -path $$promotePath -itemProperties @{ semanticmodelId = "$$($$semanticModel.id)" }
                        $$rptPromotedItems += $$promotedItem
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $$workspaceID -Credential $$credential -TenantId $$tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $$_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $$workspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $$_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $$_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)

--------------------------------------------------------------------------

new gpt:

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual Dev OneLake endpoint

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual UAT OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # Uninstall AzureRM Modules
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # Install Required PowerShell Modules
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = $env:TENANT_ID.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                Write-Host "Authenticating to Fabric API..."
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset -Verbose -Debug
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset -Verbose -Debug
                }

                # Verify that the token is set
                $authToken = Get-FabricAuthToken
                if (-not $authToken) {
                  Write-Error "Failed to obtain Fabric authentication token."
                  throw "Fabric authentication failed."
                } else {
                  Write-Host "Fabric authentication token obtained successfully."
                }

                # Set AzCopy Connection based on the target OneLake endpoint
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("$($env:UAT_ONELAKE_ENDPOINT)".Trim())
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="$oneLakeDomain" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Error "Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipSMChanges = $pbipSMChanges | Sort-Object -Unique
                $pbipRptChanges = $pbipRptChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipSMChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRptChanges)"

                # Detect if no changes
                if ($pbipSMChanges.Count -eq 0 -and $pbipRptChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"

                if (-not $workspaceObj) {
                    Write-Error "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
                    throw
                }

                $workspaceID = $workspaceObj.Id

                # ----------- Handle Semantic Models For Promotion ----------- #
                # Identify Semantic Models changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipSMChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    $smPathsToPromote += $parentFolder
                }

                # Remove duplicates
                $smPathsToPromote = $smPathsToPromote | Select-Object -Unique

                # Setup promoted items array
                $smPromotedItems = @()

                # Promote semantic models to UAT workspace
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "Promoting semantic model at $promotePath to workspace $($env:UAT_WORKSPACE_NAME)"
                    try {
                        $smPromotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath -Verbose -Debug
                        $smPromotedItems += $smPromotedItem
                        Write-Host "Semantic model imported successfully."
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath."
                        Write-Error "Error Details: $_"
                        if ($_.Exception.Response) {
                            $responseContent = $_.Exception.Response.Content
                            Write-Error "API Response: $responseContent"
                        }
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $workspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $workspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)


----------------------------------------------------------------------------------------

test anna
__________________________________________________________________
trigger:
  - main  # Adjust branch as needed

pool:
  vmImage: 'windows-latest'

steps:
  # Step 1: Checkout Repository with Full History
  - task: Checkout@1
    displayName: "Checkout Repository"
    inputs:
      fetchDepth: 0  # Fetch full commit history

  # Step 2: Detect Changes in .pbism and .pbir Files
  - task: PowerShell@2
    displayName: "Detect Changes in Power BI Files"
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "Detecting changes in Power BI files..."

        # Detect changes for .pbism and .pbir files
        $pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
        $pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')

        # Output detected changes for debugging
        Write-Host "Detected Semantic Model Changes: $($pbipSMChanges)"
        Write-Host "Detected Report Changes: $($pbipRptChanges)"

        # Exit if no changes detected
        if ($pbipSMChanges.Count -eq 0 -and $pbipRptChanges.Count -eq 0) {
            Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
            exit 0
        }

  # Step 3: Publish Build Artifacts (if changes are detected)
  - task: PublishBuildArtifacts@1
    displayName: "Publish Build Artifacts"
    inputs:
      pathToPublish: '$(System.DefaultWorkingDirectory)'
      artifactName: 'PowerBIArtifacts'





---------------------------------------------------------------------------
trigger: none  # Trigger manually or by the CI pipeline artifact

resources:
  pipelines:
    - pipeline: ciPipeline  # Reference name for the CI pipeline
      project: Power-BI  # Replace with your actual project name
      source: 142  # CI pipeline ID

variables:
  - group: powerbi
  - name: workspace_id_uat
    value: a4628c7b-adda-4285-8c1f-758b19162d0b

stages:
- stage: Deploy
  displayName: "Continuous Deployment"
  jobs:
  - job: DeployReports
    displayName: "Deploy Reports to Power BI workspace"
    pool:
      vmImage: windows-latest
    steps:
    # Step 1: Install Power BI Module
    - task: PowerShell@2
      displayName: Install and Import Power BI Module
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Checking if the MicrosoftPowerBIMgmt module is already installed..."
          if (-not (Get-Module -ListAvailable -Name MicrosoftPowerBIMgmt)) {
            Write-Host "MicrosoftPowerBIMgmt module not found. Installing now..."
            Install-Module -Name MicrosoftPowerBIMgmt -Force -Scope CurrentUser -AllowClobber
            Install-Module -Name MicrosoftPowerBIMgmt.Profile -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name MicrosoftPowerBIMgmt.Reports -Scope CurrentUser -AllowClobber -Force
          } else {
            Write-Host "MicrosoftPowerBIMgmt module is already installed."
          }
          Import-Module MicrosoftPowerBIMgmt
          Import-Module MicrosoftPowerBIMgmt.Profile
          Import-Module MicrosoftPowerBIMgmt.Reports
          Write-Host "Modules installed and imported successfully."

    # Step 2: Download Artifacts from CI Pipeline
    - task: DownloadPipelineArtifact@2
      displayName: Download Artifacts from CI Pipeline
      inputs:
        source: current
        artifact: PowerBIArtifacts
        path: $(Pipeline.Workspace)

    # Step 3: Deploy Power BI Reports and Models
    - task: PowerShell@2
      displayName: Deploy Power BI Reports and Models
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting deployment of Power BI files to UAT..."
          $workspaceId = "$(workspace_id_uat)"
          Write-Host "Workspace ID set to UAT: $workspaceId"

          # Authenticate to Power BI Service using Service Principal
          $credential = New-Object System.Management.Automation.PSCredential(
            "$(clinetid)",
            (ConvertTo-SecureString "$(Clientsecret)" -AsPlainText -Force)
          )
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId "$(tenantid)"

          # Deploy .pbir files (Power BI Reports)
          $reportFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/PowerBIArtifacts/**/*.pbir" -Recurse
          if ($reportFiles.Count -eq 0) {
            Write-Host "No report files (.pbir) found. Skipping deployment."
          } else {
            $reportFiles | ForEach-Object {
              Write-Host "Deploying report: $($_.FullName)"
              Import-PowerBIReport -Path $_.FullName -WorkspaceId $workspaceId -ConflictAction Overwrite
            }
          }

          # Deploy .pbism files (Power BI Semantic Models)
          $modelFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/PowerBIArtifacts/**/*.pbism" -Recurse
          if ($modelFiles.Count -eq 0) {
            Write-Host "No semantic model files (.pbism) found. Skipping deployment."
          } else {
            $modelFiles | ForEach-Object {
              Write-Host "Deploying semantic model: $($_.FullName)"
              # Add deployment logic for .pbism files if needed
            }
          }

          Write-Host "Deployment completed successfully for UAT."
--------------------------------

trigger: none  # Trigger manually or by the CI pipeline artifact

resources:
  pipelines:
    - pipeline: ciPipeline  # Reference name for the CI pipeline
      project: Power-BI  # Replace with your actual project name
      source: Power-BI-(CI)  # The exact name of your CI pipeline
      trigger: true  # Optional: Enable triggering the CD pipeline after CI completes

variables:
  - group: powerbi
  - name: workspace_id_uat
    value: a4628c7b-adda-4285-8c1f-758b19162d0b

stages:
- stage: Deploy
  displayName: "Continuous Deployment"
  jobs:
  - job: DeployReports
    displayName: "Deploy Reports to Power BI workspace"
    pool:
      vmImage: windows-latest
    steps:
    # Step 1: Install Power BI Module
    - task: PowerShell@2
      displayName: Install and Import Power BI Module
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Checking if the MicrosoftPowerBIMgmt module is already installed..."
          if (-not (Get-Module -ListAvailable -Name MicrosoftPowerBIMgmt)) {
            Write-Host "MicrosoftPowerBIMgmt module not found. Installing now..."
            Install-Module -Name MicrosoftPowerBIMgmt -Force -Scope CurrentUser -AllowClobber
            Install-Module -Name MicrosoftPowerBIMgmt.Profile -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name MicrosoftPowerBIMgmt.Reports -Scope CurrentUser -AllowClobber -Force
          } else {
            Write-Host "MicrosoftPowerBIMgmt module is already installed."
          }
          Import-Module MicrosoftPowerBIMgmt
          Import-Module MicrosoftPowerBIMgmt.Profile
          Import-Module MicrosoftPowerBIMgmt.Reports
          Write-Host "Modules installed and imported successfully."

    # Step 2: Download Artifacts from CI Pipeline
    - download: ciPipeline  # Reference to the pipeline resource defined above
      artifact: 'PowerBIArtifacts'  # Exact artifact name from the CI pipeline
      patterns: '**'  # Optional: Specify patterns if needed
      path: $(Pipeline.Workspace)  # Destination path for the downloaded artifacts

    # Step 3: Deploy Power BI Reports and Models
    - task: PowerShell@2
      displayName: Deploy Power BI Reports and Models
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting deployment of Power BI files to UAT..."
          $workspaceId = "$(workspace_id_uat)"
          Write-Host "Workspace ID set to UAT: $workspaceId"

          # Authenticate to Power BI Service using Service Principal
          $credential = New-Object System.Management.Automation.PSCredential(
            "$(clinetid)",
            (ConvertTo-SecureString "$(Clientsecret)" -AsPlainText -Force)
          )
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId "$(tenantid)"

          # Deploy .pbir files (Power BI Reports)
          $reportFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbir" -Recurse
          if ($reportFiles.Count -eq 0) {
            Write-Host "No report files (.pbir) found. Skipping deployment."
          } else {
            $reportFiles | ForEach-Object {
              Write-Host "Deploying report: $($_.FullName)"
              Import-PowerBIReport -Path $_.FullName -WorkspaceId $workspaceId -ConflictAction Overwrite
            }
          }

          # Deploy .pbism files (Power BI Semantic Models)
          $modelFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbism" -Recurse
          if ($modelFiles.Count -eq 0) {
            Write-Host "No semantic model files (.pbism) found. Skipping deployment."
          } else {
            $modelFiles | ForEach-Object {
              Write-Host "Deploying semantic model: $($_.FullName)"
              # Add deployment logic for .pbism files if needed
            }
          }

          Write-Host "Deployment completed successfully for UAT."
-------------------------------------------------------------------------

- task: DownloadPipelineArtifact@2
      displayName: Download Artifacts from CI Pipeline
      inputs:
        buildType: 'specific'
        project: 'Power-BI'  # Replace with your project name
        definition: 'Power-BI-(CI)'  # Replace with your CI pipeline name
        buildVersionToDownload: 'latest'
        artifactName: 'PowerBIArtifacts'  # Ensure the artifact name matches exactly
        targetPath: '$(Pipeline.Workspace)'

--------------------------------------------

trigger: none  # Trigger manually or by the CI pipeline artifact

resources:
  pipelines:
    - pipeline: ciPipeline  # Reference name for the CI pipeline
      project: Power-BI  # Replace with your actual project name
      source: Power-BI-(CI)  # The exact name of your CI pipeline
      trigger: true  # Optional: Enable triggering the CD pipeline after CI completes

variables:
  - group: powerbi
  - name: workspace_id_uat
    value: a4628c7b-adda-4285-8c1f-758b19162d0b

stages:
- stage: Deploy
  displayName: "Continuous Deployment"
  jobs:
  - job: DeployReports
    displayName: "Deploy Reports to Power BI workspace"
    pool:
      vmImage: windows-latest
    steps:
    # Step 1: Install and Import Power BI Module
    - task: PowerShell@2
      displayName: Install and Import Power BI Module
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Installing MicrosoftPowerBIMgmt modules..."
          # Install all MicrosoftPowerBIMgmt modules
          Install-Module -Name MicrosoftPowerBIMgmt -Force -Scope CurrentUser -AllowClobber -ErrorAction Stop
          # Import the module
          Import-Module MicrosoftPowerBIMgmt -ErrorAction Stop -Verbose
          Write-Host "Modules installed and imported successfully."
          # Verify that Import-PowerBIReport cmdlet is available
          if (Get-Command -Name 'Import-PowerBIReport' -ErrorAction SilentlyContinue) {
              Write-Host "Import-PowerBIReport cmdlet is available."
          } else {
              Write-Error "Import-PowerBIReport cmdlet is not available."
          }
        pwsh: false  # Use Windows PowerShell instead of PowerShell Core

    # Step 2: Download Artifacts from CI Pipeline
    - download: ciPipeline  # Reference to the pipeline resource defined above
      artifact: 'PowerBIArtifacts'  # Exact artifact name from the CI pipeline
      root: $(Pipeline.Workspace)  # Destination path for the downloaded artifacts

    # Step 3: Deploy Power BI Reports and Models
    - task: PowerShell@2
      displayName: Deploy Power BI Reports and Models
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting deployment of Power BI files to UAT..."
          $workspaceId = "$(workspace_id_uat)"
          Write-Host "Workspace ID set to UAT: $workspaceId"

          # Authenticate to Power BI Service using Service Principal
          $credential = New-Object System.Management.Automation.PSCredential(
            "$(clientid)",
            (ConvertTo-SecureString "$(Clientsecret)" -AsPlainText -Force)
          )
          Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId "$(tenantid)" -ErrorAction Stop

          # Deploy .pbix files (Power BI Reports)
          $reportFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbix" -Recurse
          if ($reportFiles.Count -eq 0) {
            Write-Host "No report files (.pbix) found. Skipping deployment."
          } else {
            $reportFiles | ForEach-Object {
              Write-Host "Deploying report: $($_.FullName)"
              Import-PowerBIReport -Path $_.FullName -WorkspaceId $workspaceId -ConflictAction Overwrite -ErrorAction Stop
            }
          }

          # Deploy .pbism files (Power BI Semantic Models)
          $modelFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbism" -Recurse
          if ($modelFiles.Count -eq 0) {
            Write-Host "No semantic model files (.pbism) found. Skipping deployment."
          } else {
            $modelFiles | ForEach-Object {
              Write-Host "Deploying semantic model: $($_.FullName)"
              # Add deployment logic for .pbism files if needed
            }
          }

          Write-Host "Deployment completed successfully for UAT."
        pwsh: false  # Use Windows PowerShell instead of PowerShell Core

-------------------------------------------------------------------

steps:
    # Step 1: Install and Import Power BI Module
    - task: PowerShell@2
      displayName: Install and Import Power BI Module
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "PowerShell Version:"
          $PSVersionTable

          # Update the NuGet provider
          Write-Host "Updating NuGet provider..."
          Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -ErrorAction Stop

          # Update PowerShellGet module
          Write-Host "Updating PowerShellGet module..."
          Install-Module -Name PowerShellGet -Force -AllowClobber -ErrorAction Stop -Scope AllUsers

          # Set Execution Policy
          Write-Host "Setting execution policy..."
          Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope LocalMachine -Force

          # Install MicrosoftPowerBIMgmt module in AllUsers scope
          Write-Host "Installing MicrosoftPowerBIMgmt modules..."
          Install-Module -Name MicrosoftPowerBIMgmt -Force -AllowClobber -ErrorAction Stop -Scope AllUsers

          # Add the module path to PSModulePath
          $modulePath = "$env:ProgramFiles\WindowsPowerShell\Modules"
          Write-Host "Adding $modulePath to PSModulePath"
          $env:PSModulePath = "$env:PSModulePath;$modulePath"

          # Import the module
          Write-Host "Importing MicrosoftPowerBIMgmt modules..."
          Import-Module MicrosoftPowerBIMgmt -ErrorAction Stop -Force -Verbose

          # Verify that Import-PowerBIReport cmdlet is available
          if (Get-Command -Name 'Import-PowerBIReport' -ErrorAction SilentlyContinue) {
              Write-Host "Import-PowerBIReport cmdlet is available."
          } else {
              Write-Error "Import-PowerBIReport cmdlet is not available."
          }

          # Output available modules
          Write-Host "Available Modules:"
          Get-Module -ListAvailable

          # Output PSModulePath
          Write-Host "PSModulePath is: $env:PSModulePath"

        pwsh: false  # Use Windows PowerShell instead of PowerShell Core




---------------------------------------------------------------------


trigger: none  # Trigger manually or by the CI pipeline artifact

resources:
  pipelines:
    - pipeline: ciPipeline  # Reference name for the CI pipeline
      project: Power-BI  # Replace with your actual project name
      source: Power-BI-(CI)  # The exact name of your CI pipeline
      trigger: true  # Optional: Enable triggering the CD pipeline after CI completes

variables:
  - group: powerbi  # Your variable group containing the variables
  - name: workspace_id_uat
    value: a4628c7b-adda-4285-8c1f-758b19162d0b

stages:
- stage: Deploy
  displayName: "Continuous Deployment"
  jobs:
  - job: DeployReports
    displayName: "Deploy Reports to Power BI workspace"
    pool:
      vmImage: windows-latest
    steps:
    # Step 1: Download Artifacts from CI Pipeline
    - download: ciPipeline  # Reference to the pipeline resource defined above
      artifact: 'PowerBIArtifacts'  # Exact artifact name from the CI pipeline
      root: $(Pipeline.Workspace)  # Destination path for the downloaded artifacts

    # Step 2: Deploy Power BI Reports using REST API
    - task: PowerShell@2
      displayName: Deploy Power BI Reports and Models via REST API
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Starting deployment of Power BI files to UAT..."

          $tenantId = "$(tenantid)"
          $clientId = "$(clinetid)"
          $clientSecret = "$(Clientsecret)"
          $workspaceId = "$(workspace_id_uat)"

          # Output the variables for debugging (optional, remove in production)
          Write-Host "Tenant ID: $tenantId"
          Write-Host "Client ID: $clientId"
          Write-Host "Workspace ID: $workspaceId"

          # Authenticate and get an access token
          $tokenResponse = Invoke-RestMethod -Method Post -Uri "https://login.microsoftonline.com/$tenantId/oauth2/token" -Body @{
              grant_type    = "client_credentials"
              client_id     = $clientId
              client_secret = $clientSecret
              resource      = "https://analysis.windows.net/powerbi/api"
          }

          if ($tokenResponse -and $tokenResponse.access_token) {
              Write-Host "Successfully obtained access token."
          } else {
              Write-Error "Failed to obtain access token."
              exit 1
          }

          $accessToken = $tokenResponse.access_token

          # Set up the authorization header
          $headers = @{
              "Authorization" = "Bearer $accessToken"
          }

          # Find .pbix files
          $reportFiles = Get-ChildItem -Path "$(Pipeline.Workspace)/**/*.pbix" -Recurse

          if ($reportFiles.Count -eq 0) {
              Write-Host "No report files (.pbix) found. Skipping deployment."
          } else {
              foreach ($file in $reportFiles) {
                  Write-Host "Deploying report: $($file.FullName)"

                  # Read the file content
                  $fileContent = [IO.File]::ReadAllBytes($file.FullName)

                  # Create a boundary for the multipart/form-data
                  $boundary = [System.Guid]::NewGuid().ToString()
                  $contentType = "multipart/form-data; boundary=`"$boundary`""

                  # Build the body
                  $body = "--$boundary`r`n"
                  $body += "Content-Disposition: form-data; name=`"file`"; filename=`"$($file.Name)`"`r`n"
                  $body += "Content-Type: application/octet-stream`r`n`r`n"
                  $bodyBytes = [System.Text.Encoding]::UTF8.GetBytes($body)
                  $fileBytes = $fileContent
                  $endBoundary = "`r`n--$boundary--`r`n"
                  $endBoundaryBytes = [System.Text.Encoding]::UTF8.GetBytes($endBoundary)

                  # Combine the byte arrays
                  $memoryStream = New-Object System.IO.MemoryStream
                  $memoryStream.Write($bodyBytes, 0, $bodyBytes.Length)
                  $memoryStream.Write($fileBytes, 0, $fileBytes.Length)
                  $memoryStream.Write($endBoundaryBytes, 0, $endBoundaryBytes.Length)
                  $memoryStream.Position = 0

                  # Define the URI
                  $uri = "https://api.powerbi.com/v1.0/myorg/groups/$workspaceId/imports?datasetDisplayName=$($file.BaseName)&nameConflict=Overwrite"

                  # Make the POST request
                  try {
                      $response = Invoke-RestMethod -Method Post -Uri $uri -Headers $headers -ContentType $contentType -Body $memoryStream -TimeoutSec 600
                      Write-Host "Successfully deployed report: $($file.Name)"
                  } catch {
                      Write-Error "Failed to deploy report $($file.Name): $_"
                  } finally {
                      $memoryStream.Dispose()
                  }
              }
          }

          Write-Host "Deployment completed successfully for UAT."
      pwsh: false  # Use Windows PowerShell instead of PowerShell Core

_________________________________________________________________________________

CI with auth



trigger:
- main  # Adjust as needed

variables:
- group: powerbi  # References tenantid, clinetid, Clientsecret

pool:
  vmImage: 'windows-latest'

steps:
# Step 1: Checkout Repository with Full History
- checkout: self
  displayName: "Checkout Repository"
  fetchDepth: 0

# Step 2: Detect Changes in .pbism and .pbir Files
- task: PowerShell@2
  displayName: "Detect Changes in Power BI Files"
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Detecting changes in Power BI files..."
      $pbismChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
      $pbirChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')

      Write-Host "Detected Semantic Model Changes (.pbism): $($pbismChanges)"
      Write-Host "Detected Report Changes (.pbir): $($pbirChanges)"

      if ($pbismChanges.Count -eq 0 -and $pbirChanges.Count -eq 0) {
          Write-Host "No changes detected in .pbism or .pbir files. Exiting..."
          exit 0
      } else {
          Write-Host "Changes detected. Proceeding..."
      }

# Step 3: Install Power BI Modules and Authenticate to Confirm Dev Environment
- task: PowerShell@2
  displayName: "Authenticate and Confirm Dev Environment"
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Installing MicrosoftPowerBIMgmt modules..."
      Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -Force -AllowClobber

      Write-Host "Importing modules..."
      Import-Module MicrosoftPowerBIMgmt
      Import-Module MicrosoftPowerBIMgmt.Profile
      Import-Module MicrosoftPowerBIMgmt.Reports

      $tenantId = "$(tenantid)"
      $clientId = "$(clinetid)"
      $clientSecret = "$(Clientsecret)"

      $secureSecret = ConvertTo-SecureString $clientSecret -AsPlainText -Force
      $credential = New-Object System.Management.Automation.PSCredential($clientId, $secureSecret)

      Write-Host "Connecting to Power BI Service..."
      Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $tenantId -ErrorAction Stop

      Write-Host "Listing Workspaces..."
      $workspaces = Get-PowerBIWorkspace -Scope Organization

      # Check for the Dev workspace by name and ID
      $devWorkspace = $workspaces | Where-Object { $_.Name -eq "Version Control[Dev]" -and $_.Id -eq "c017440f-4a5b-46bd-a2c0-93ee3f04ab4d" }

      if (-not $devWorkspace) {
        Write-Error "Dev workspace 'Version Control[Dev]' with ID 'c017440f-4a5b-46bd-a2c0-93ee3f04ab4d' not found. This might not be the Dev environment."
        exit 1
      } else {
        Write-Host "Confirmed Dev environment with workspace 'Version Control[Dev]' (ID: c017440f-4a5b-46bd-a2c0-93ee3f04ab4d)."
      }

# Step 4: Publish Artifacts
- task: PublishBuildArtifacts@1
  displayName: "Publish Power BI Artifacts"
  inputs:
    pathToPublish: '$(System.DefaultWorkingDirectory)'
    artifactName: 'PowerBIArtifacts'


-----------------------------------------------------------

.pbir logic

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'

trigger:
  branches:
    include:
      - develop

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # Uninstall AzureRM Modules
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # Install Required Modules
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)
                $tenantId = $env:TENANT_ID.Trim()

                if ($tenantId.Length -ge 4) { Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'" }
                if ($credential.UserName.Length -ge 4) { Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'" }

                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # Authenticate to Fabric
                Write-Host "Authenticating to Fabric API..."
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret ([Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password))) `
                    -tenantId $tenantId -reset -Verbose -Debug
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset -Verbose -Debug
                }

                $authToken = Get-FabricAuthToken
                if (-not $authToken) {
                  Write-Error "Failed to obtain Fabric authentication token."
                  throw "Fabric authentication failed."
                } else {
                  Write-Host "Fabric authentication token obtained successfully."
                }

                # Connect to Azure if needed for storage access (optional)
                Import-Module Az.Accounts -Force
                Connect-AzAccount -ServicePrincipal -Tenant $tenantId -Credential $credential

                # AzCopy Authentication
                $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password))
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("$($env:UAT_ONELAKE_ENDPOINT)".Trim())
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="$oneLakeDomain" `
                  --output-type json | ConvertFrom-Json

                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Error "Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."
                
                # Connect to Power BI
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                Write-Host "Processing changes..."

                # Detect changes
                $pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipSMChanges = $pbipSMChanges | Sort-Object -Unique
                $pbipRptChanges = $pbipRptChanges | Sort-Object -Unique

                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipSMChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRptChanges)"

                if ($pbipSMChanges.Count -eq 0 -and $pbipRptChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"

                if (-not $workspaceObj) {
                    Write-Error "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
                    throw
                }

                $workspaceID = $workspaceObj.Id

                # Import Semantic Models if changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipSMChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    $smPathsToPromote += $parentFolder
                }

                $smPathsToPromote = $smPathsToPromote | Select-Object -Unique
                $smPromotedItems = @()

                # Import semantic models first
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "Promoting semantic model at $promotePath to workspace $($env:UAT_WORKSPACE_NAME)"
                    try {
                        $smPromotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath -Verbose -Debug
                        $smPromotedItems += $smPromotedItem
                        Write-Host "Semantic model imported successfully."
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath."
                        Write-Error "Error Details: $_"
                        if ($_.Exception.Response) {
                            $responseContent = $_.Exception.Response.Content
                            Write-Error "API Response: $responseContent"
                        }
                        throw
                    }
                }

                # If no reports changed, we are done
                if ($pbipRptChanges.Count -eq 0) {
                    Write-Host "No report changes detected. Semantic models promotion completed."
                    # Proceed with DQV testing or refresh if needed
                    Write-Host "Starting Data Quality Validation (DQV) testing..."
                    try {
                        Invoke-DQVTesting -WorkspaceId $workspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                        Write-Host "DQV testing completed successfully."
                    } catch {
                        Write-Error "DQV testing failed: $_"
                        throw
                    }

                    Write-Host "Validating data refresh..."
                    try {
                        Invoke-SemanticModelRefresh -WorkspaceId $workspaceID -RefreshType Full -Wait -Verbose -Debug
                        Write-Host "Data refresh validated successfully."
                    } catch {
                        Write-Error "Data refresh validation failed: $_"
                        throw
                    }

                    Write-Host "All steps completed successfully."
                    exit 0
                }

                # Retrieve all items in workspace to identify semantic models if needed
                $items = Invoke-FabricRestMethod -Method GET -Url "workspaces/$workspaceID/items"

                # Import Reports
                foreach ($change in $pbipRptChanges) {
                    $parentFolder = Split-Path $change -Parent
                    $filter = "*.pbir"
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        # Identify the semantic model for the report
                        $def = Get-ChildItem -Path $parentFolder -Recurse -Include "definition.pbir"
                        if ($def -eq $null) {
                            Write-Error "Report definition.pbir not found in $parentFolder"
                            throw "Report definition not found."
                        }

                        $reportDefinition = Get-Content $def.FullName | ConvertFrom-Json
                        $semanticModelPath = $reportDefinition.datasetReference.byPath

                        Write-Host "##[debug] SemanticModelPath: $($semanticModelPath)"

                        $semanticModelName = $null
                        if ($semanticModelPath -ne $null) {
                            $pathToCheck = Join-Path $parentFolder $semanticModelPath.path
                            $metadataSM = Get-ChildItem -Path $pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                          Where-Object { (Split-Path -Path $_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $_.FullName).EndsWith(".SemanticModel") }

                            if ($metadataSM -ne $null) {
                                $content = Get-Content $metadataSM.FullName | ConvertFrom-Json
                                if ($metadataSM.Name -eq "item.metadata.json") {
                                    # Pre-March 2024 logic
                                    $semanticModelName = $content.displayName
                                    Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                                } else {
                                    $semanticModelName = $content.metadata.displayName
                                    Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                                }
                            } else {
                                Write-Host "##[vso[task.logissue type=error]Semantic Model definition not found in workspace."
                                throw "Semantic Model definition for the report not found."
                            }
                        }

                        # Determine semanticModelId
                        $semanticModelId = $null

                        # If we just imported semantic models, check if we have it from $smPromotedItems
                        if ($smPromotedItems.Count -gt 0 -and $semanticModelName) {
                            $importedSM = $smPromotedItems | Where-Object { $_.displayName -eq $semanticModelName -and $_.type -eq "SemanticModel" }
                            if ($importedSM) {
                                $semanticModelId = $importedSM.id
                            }
                        }

                        # If not found in imported SMs, try to find from existing items
                        if (-not $semanticModelId -and $semanticModelName) {
                            $existingSM = $items | Where-Object { $_.type -eq "SemanticModel" -and $_.displayName -eq $semanticModelName }
                            if ($existingSM) {
                                $semanticModelId = $existingSM.id
                            }
                        }

                        if (-not $semanticModelId) {
                            Write-Error "Semantic Model '$semanticModelName' not found in workspace. Cannot import report."
                            throw "Semantic model for the report not found."
                        }

                        Write-Host "Promoting report at $parentFolder to workspace $($env:UAT_WORKSPACE_NAME) with semantic model ID: $semanticModelId"
                        try {
                            $promotedItem = Import-FabricItem -workspaceId $workspaceID -path $parentFolder -itemProperties @{ semanticModelId = $semanticModelId } -Verbose -Debug
                            Write-Host "Report imported successfully."
                        } catch {
                            Write-Error "Failed to promote report at $parentFolder: $_"
                            throw
                        }
                    }
                }

                # DQV Testing and Data Refresh after promoting reports
                Write-Host "Starting Data Quality Validation (DQV) testing..."
                try {
                    Invoke-DQVTesting -WorkspaceId $workspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                Write-Host "Validating data refresh..."
                try {
                    Invoke-SemanticModelRefresh -WorkspaceId $workspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)
