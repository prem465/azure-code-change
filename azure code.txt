trigger:
  branches:
    include:
      - develop

pool:
  vmImage: 'windows-latest'

variables:
  group: powerbi # Ensure this variable group contains clientid, clientsecret, and tenantid
  SOURCE_WORKSPACE_ID: "c017440f-4a5b-46bd-a2c0-93ee3f04ab4d"
  TARGET_WORKSPACE_ID: "a4628c7b-adda-4285-8c1f-758b19162d0b"
  MODULE_LIST: |
    MicrosoftPowerBIMgmt
    Invoke-DQVTesting
    Invoke-SemanticModelRefresh

steps:
# Step 1: Checkout Repository
- checkout: self
  displayName: 'Checkout Repository'
- task: PowerShell@2
  displayName: 'Setup PowerShell Environment'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
      Set-PSRepository -Name "PSGallery" -InstallationPolicy Trusted
      Install-Module PowerShellGet -Force -AllowClobber -Scope CurrentUser

- task: PowerShell@2
  displayName: 'Remove AzureRM Module if Loaded and Install Az Module'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      # Remove any AzureRM module that might be loaded in the session
      Get-Module AzureRM* -ListAvailable | Remove-Module -Force -ErrorAction SilentlyContinue

      # Install Az Module explicitly to avoid conflicts
      Install-Module -Name Az.Accounts -Force -AllowClobber -Scope CurrentUser
# Step 2: Install Dependencies Dynamically
- task: PowerShell@2
  displayName: 'Install Required Modules'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Installing dependencies dynamically..."

      # Include Az.Accounts module in the list
      $modules = @(
        "Az.Accounts"
        "MicrosoftPowerBIMgmt"
        "Invoke-DQVTesting"
        "Invoke-SemanticModelRefresh"
      )
      
      # Loop through the modules and install if missing
      foreach ($module in $modules) {
        Write-Host "Checking module: $module"
        if (-not (Get-Module -ListAvailable -Name $module)) {
          Write-Host "Installing module: $module"
          Install-Module -Name $module -Scope CurrentUser -Force -ErrorAction Stop
        } else {
          Write-Host "Module $module is already installed."
        }
      }
# Step 3: Authenticate with Azure and Power BI Service
- task: PowerShell@2
  displayName: 'Authenticate with Azure and Power BI Service'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Authenticating with Azure and Power BI Service..."

      # Setup variables for credentials
      $clientSecret = "${{ variables.Clientsecret }}"
      $clientId = "${{ variables.clinetid }}"
      $tenantId = "${{ variables.tenantid }}"

      # Directly login to Azure
      Write-Host "Logging in to Azure using Service Principal..."
      Connect-AzAccount -ServicePrincipal -TenantId $tenantId -ApplicationId $clientId -CertificateThumbprint $clientSecret -ErrorAction Stop

      Write-Host "Azure authentication successful."

      # Optionally set Fabric Auth Token if required
      Write-Host "Setting Fabric authentication token..."
      Set-FabricAuthToken -servicePrincipalId $clientId `
                          -servicePrincipalSecret $clientSecret `
                          -tenantId $tenantId -reset

      Write-Host "Authentication with Azure and Power BI Service completed successfully!"










# Step 4: Detect Changes in Commit
- task: PowerShell@2
  displayName: 'Detect Changes in Commit'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Detecting changes in the latest commit..."
      $changedFiles = git diff --name-only HEAD~1 HEAD
      Write-Host "Changed files detected:"
      Write-Host $changedFiles

# Step 5: Validate Semantic Models and Reports
- task: PowerShell@2
  displayName: 'Validate Semantic Models and Reports'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Validating Semantic Models and Reports..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel") {
          Write-Host "Running Semantic Model Validation for: $file"
          Invoke-SemanticModelRefresh -ModelPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
        if ($file -match "report") {
          Write-Host "Running Data Quality Validation for: $file"
          Invoke-DQVTesting -ReportPath $file -WorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }}
        }
      }

# Step 6: Promote Files to UAT
- task: PowerShell@2
  displayName: 'Promote Files to UAT'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Promoting files to UAT..."
      foreach ($file in $changedFiles) {
        if ($file -match "semanticmodel" -or $file -match "report") {
          Write-Host "Promoting $file to UAT Workspace..."
          Publish-PowerBIFile -Path $file -SourceWorkspaceId ${{ variables.SOURCE_WORKSPACE_ID }} -TargetWorkspaceId ${{ variables.TARGET_WORKSPACE_ID }}
        }
      }

# Step 7: Log Results
- task: PowerShell@2
  displayName: 'Log Results'
  inputs:
    pwsh: true
    targetType: inline
    script: |
      Write-Host "Logging results..."
      # Log timestamp
      Get-Date | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      # Log changes and promotions
      foreach ($file in $changedFiles) {
        $logEntry = "Promoted file: $file"
        $logEntry | Out-File -FilePath $(Pipeline.Workspace)/log.txt -Append
      }
      Write-Host "Logs stored in: $(Pipeline.Workspace)/log.txt"





---------------------------------------------------------------------------



parameters:
  - name: WORKSPACE_NAME
    displayName: "Workspace name to conduct tests?"
    type: string
    default: 'YourWorkspaceName'  # Replace with your default workspace name

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains Clientsecret, clinetid, tenantid
  - name: WORKSPACE_NAME
    value: '${{ parameters.WORKSPACE_NAME }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      - task: PowerShell@2
        displayName: 'Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

      - task: PowerShell@2
        displayName: 'Install Dependencies'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      - task: PowerShell@2
        displayName: 'Deploy Changes and Conduct Testing'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                if (-not ${env:clinetid} -or -not ${env:Clientsecret} -or -not ${env:tenantid}) {
                    Write-Error "Missing one or more required environment variables: clinetid, Clientsecret, tenantid"
                    throw
                }

                $secret = ${env:Clientsecret} | ConvertTo-SecureString -AsPlainText -Force
                $credential = New-Object System.Management.Automation.PSCredential (${env:clinetid}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:tenantid}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
                  [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                )

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                }

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Dataset/**/*.SemanticModel/**')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Report/**')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get workspace Id
                $workspaceObj = Get-FabricWorkspace -workspaceName "${env:WORKSPACE_NAME}"
                $workspaceID = $workspaceObj.Id

                # ----------- Handle Semantic Models For Promotion ----------- #
                # Identify Semantic Models changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipDSChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $smPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $smPathsToPromote = $smPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $smPromotedItems = @()

                # Promote semantic models to workspace
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "##[debug]Promoting semantic model at $($promotePath) to workspace ${env:WORKSPACE_NAME}"
                    $smPromotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath
                    $smPromotedItems += $smPromotedItem
                }

                # ----------- Promote Reports ----------- #
                # Retrieve all items in workspace (after semantic models have been promoted)
                $items = Invoke-FabricAPIRequest -Uri "workspaces/${workspaceID}/items" -Method Get

                # Identify Reports changed
                $rptPathsToPromote = @()
                $filter = "*.pbir"

                foreach ($change in $pbipRPTChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $rptPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $rptPathsToPromote = $rptPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $rptPromotedItems = @()

                Write-Host "##[debug] rptPathsToPromote: $($rptPathsToPromote)"

                # Promote reports to workspace
                foreach ($promotePath in $rptPathsToPromote) {
                    # Get report definition
                    $def = Get-ChildItem -Path $promotePath -Recurse -Include "definition.pbir"
                    $semanticModelPath = (Get-Content $def.FullName | ConvertFrom-Json).datasetReference.byPath

                    Write-Host "##[debug] SemanticModelPath: $($semanticModelPath)"

                    # If byPath was null, we'll assume byConnection is set and skip
                    if ($semanticModelPath -ne $null) {
                        # Semantic Model path is relative to the report path, Join-Path can handle relative paths
                        $pathToCheck = Join-Path $promotePath $semanticModelPath.path
                        $metadataSM = Get-ChildItem -Path $pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                      Where-Object { (Split-Path -Path $_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $_.FullName).EndsWith(".SemanticModel") }

                        if ($metadataSM -ne $null) {
                            $content = Get-Content $metadataSM.FullName | ConvertFrom-Json

                            # Handle item.metadata.json
                            if ($metadataSM.Name -eq "item.metadata.json") {
                                # Prior to March-2024 release
                                $semanticModelName = $content.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            } else {
                                $semanticModelName = $content.metadata.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            }
                        } else {
                            Write-Host "##[error] Semantic Model definition not found in workspace."
                        }
                    }

                    # Get the semantic model id from items in the workspace
                    $semanticModel = $items | Where-Object { $_.type -eq "SemanticModel" -and $_.displayName -eq $semanticModelName }

                    Write-Host "##[debug] semanticModel: $($semanticModel)"

                    if (!$semanticModel) {
                        Write-Host "##[error] Semantic Model not found in workspace."
                    } else {
                        # Import report with appropriate semantic model id
                        Write-Host "##[debug] Promoting report at $($promotePath) to workspace ${env:WORKSPACE_NAME}"
                        $promotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath -itemProperties @{ semanticmodelId = "$($semanticModel.id)" }
                        $rptPromotedItems += $promotedItem
                    }
                }

                # ----------- Run Refreshes and Tests ----------- #

                # Generate Run GUID
                $runGuid = (New-Guid).Guid
                $projectName = $($env:SYSTEM_TEAMPROJECT)
                $repoName = $($env:BUILD_REPOSITORY_NAME)
                $branchName = $($env:BUILD_SOURCEBRANCHNAME)
                $userName = "$($env:BUILD_REQUESTEDFOREMAIL)"
                $buildReason = "$($env:BUILD_REASON)"

                if ($buildReason -eq 'schedule' -or $buildReason -eq 'ScheduleForced') {
                    $userName = "Scheduled - Build-Agent"
                }

                Write-Host "##[debug]Run GUID: $($runGuid)"
                Write-Host "##[debug]Project Name: $($projectName)"
                Write-Host "##[debug]Repository Name: $($repoName)"
                Write-Host "##[debug]Branch Name: $($branchName)"
                Write-Host "##[debug]User Name: $($userName)"

                $idqVersion = (Get-Module -Name "Invoke-DQVTesting" -ListAvailable).Version.toString()
                $testResults = @()

                # Get UTC representation of run
                $dateTimeofRun = (Get-Date -Format "yyyy-MM-ddTHH-mm-ssZ")
                $fileName = "$($dateTimeofRun)-$($runGuid).csv"

                # Run synchronous refresh for each semantic model
                foreach ($promotedItem in $smPromotedItems) {
                    # Test refresh which validates functionality
                    Invoke-SemanticModelRefresh -WorkspaceId $workspaceID `
                        -SemanticModelId $promotedItem.Id `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -Environment Public `
                        -LogOutput "ADO"
                }

                # Run tests for functionality and data accuracy
                foreach ($promotedItem in $smPromotedItems) {
                    $testResults += Invoke-DQVTesting -WorkspaceName "${env:WORKSPACE_NAME}" `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -DatasetId $promotedItem.Id `
                        -LogOutput "Table"
                }

                # Add additional properties to the array of objects
                $i = 0

                $testResults | ForEach-Object {
                    Add-Member -InputObject $_ -Name "BranchName" -Value $branchName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RepositoryName" -Value $repoName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "ProjectName" -Value $projectName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "UserName" -Value $userName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunID" -Value $runGuid -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "Order" -Value $i -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunDateTime" -Value $dateTimeofRun -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "InvokeDQTestingVersion" -Value $idqVersion -MemberType NoteProperty
                    $i++
                }

                $testResults | Select-Object * | Export-Csv -Path ".\$fileName"

                $getAbsPath = (Resolve-Path ".\$fileName").Path

                Write-Host "##[debug] Test Results for $($promotedItem.Id) saved locally to $($getAbsPath)."

                # Output test results
                $testResults | ForEach-Object {
                    $prefix = "##[debug]"
                    switch ($_.LogType) {
                        'Warning' { $prefix = "##vso[task.logissue type=warning]" }
                        'Error' { $prefix = "##vso[task.logissue type=error]" }
                        'Failure' { $prefix = "##vso[task.complete result=Failed;]" }
                        'Success' { $prefix = "##vso[task.complete result=Succeeded;]" }
                    }
                    Write-Host "$($prefix)$($_.Message)"
                }

            } catch {
                Write-Error "Authentication or processing failed: $_"
                throw
            }
        env:
          Clientsecret: $(Clientsecret)
          clinetid: $(clinetid)
          tenantid: $(tenantid)
          WORKSPACE_NAME: $(WORKSPACE_NAME)


--------------------------------------------------------------------------------

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains Clientsecret, clinetid, tenantid
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      - task: PowerShell@2
        displayName: 'Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

      - task: PowerShell@2
        displayName: 'Install Dependencies'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      - task: PowerShell@2
        displayName: 'Deploy Changes and Conduct Testing'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                if (-not ${env:clinetid} -or -not ${env:Clientsecret} -or -not ${env:tenantid}) {
                    Write-Error "Missing one or more required environment variables: clinetid, Clientsecret, tenantid"
                    throw
                }

                $secret = ${env:Clientsecret} | ConvertTo-SecureString -AsPlainText -Force
                $credential = New-Object System.Management.Automation.PSCredential (${env:clinetid}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:tenantid}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
                  [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                )

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop
                }

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Dataset/**/*.SemanticModel/**')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '*.Report/**')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get Dev and UAT workspace IDs
                $devWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:DEV_WORKSPACE_NAME}"
                $devWorkspaceID = $devWorkspaceObj.Id

                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:UAT_WORKSPACE_NAME}"
                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Identify Semantic Models changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipDSChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $smPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $smPathsToPromote = $smPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $smPromotedItems = @()

                # Promote semantic models to UAT workspace
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "##[debug]Promoting semantic model at $($promotePath) to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                    $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath
                    $smPromotedItems += $smPromotedItem
                }

                # ----------- Retrieve Items in UAT Workspace ----------- #
                $items = Invoke-FabricAPIRequest -Uri "workspaces/${uatWorkspaceID}/items" -Method Get

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Identify Reports changed
                $rptPathsToPromote = @()
                $filter = "*.pbir"

                foreach ($change in $pbipRPTChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    if ($parentFolder -ne $null) {
                        $rptPathsToPromote += $parentFolder
                    }
                }

                # Remove duplicates
                $rptPathsToPromote = $rptPathsToPromote | Sort-Object -Unique

                # Setup promoted items array
                $rptPromotedItems = @()

                Write-Host "##[debug] rptPathsToPromote: $($rptPathsToPromote)"

                # Promote reports to UAT workspace
                foreach ($promotePath in $rptPathsToPromote) {
                    # Get report definition
                    $def = Get-ChildItem -Path $promotePath -Recurse -Include "definition.pbir"
                    $semanticModelPath = (Get-Content $def.FullName | ConvertFrom-Json).datasetReference.byPath

                    Write-Host "##[debug] SemanticModelPath: $($semanticModelPath)"

                    # If byPath was null, we'll assume byConnection is set and skip
                    if ($semanticModelPath -ne $null) {
                        # Semantic Model path is relative to the report path, Join-Path can handle relative paths
                        $pathToCheck = Join-Path $promotePath $semanticModelPath.path
                        $metadataSM = Get-ChildItem -Path $pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                      Where-Object { (Split-Path -Path $_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $_.FullName).EndsWith(".SemanticModel") }

                        if ($metadataSM -ne $null) {
                            $content = Get-Content $metadataSM.FullName | ConvertFrom-Json

                            # Handle item.metadata.json
                            if ($metadataSM.Name -eq "item.metadata.json") {
                                # Prior to March-2024 release
                                $semanticModelName = $content.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            } else {
                                $semanticModelName = $content.metadata.displayName
                                Write-Host "##[debug] SemanticModelName: $($semanticModelName)"
                            }
                        } else {
                            Write-Host "##[error] Semantic Model definition not found."
                            continue
                        }
                    }

                    # Get the semantic model id from items in the UAT workspace
                    $semanticModel = $items | Where-Object { $_.type -eq "SemanticModel" -and $_.displayName -eq $semanticModelName }

                    Write-Host "##[debug] semanticModel: $($semanticModel)"

                    if (!$semanticModel) {
                        Write-Host "##[error] Semantic Model not found in UAT workspace."
                        continue
                    } else {
                        # Import report with appropriate semantic model id
                        Write-Host "##[debug] Promoting report at $($promotePath) to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $promotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -itemProperties @{ semanticmodelId = "$($semanticModel.id)" }
                        $rptPromotedItems += $promotedItem
                    }
                }

                # ----------- Run Refreshes and Tests in UAT Workspace ----------- #

                # Generate Run GUID
                $runGuid = (New-Guid).Guid
                $projectName = $($env:SYSTEM_TEAMPROJECT)
                $repoName = $($env:BUILD_REPOSITORY_NAME)
                $branchName = $($env:BUILD_SOURCEBRANCHNAME)
                $userName = "$($env:BUILD_REQUESTEDFOREMAIL)"
                $buildReason = "$($env:BUILD_REASON)"

                if ($buildReason -eq 'schedule' -or $buildReason -eq 'ScheduleForced') {
                    $userName = "Scheduled - Build-Agent"
                }

                Write-Host "##[debug]Run GUID: $($runGuid)"
                Write-Host "##[debug]Project Name: $($projectName)"
                Write-Host "##[debug]Repository Name: $($repoName)"
                Write-Host "##[debug]Branch Name: $($branchName)"
                Write-Host "##[debug]User Name: $($userName)"

                $idqVersion = (Get-Module -Name "Invoke-DQVTesting" -ListAvailable).Version.toString()
                $testResults = @()

                # Get UTC representation of run
                $dateTimeofRun = (Get-Date -Format "yyyy-MM-ddTHH-mm-ssZ")
                $fileName = "$($dateTimeofRun)-$($runGuid).csv"

                # Run synchronous refresh for each semantic model in UAT workspace
                foreach ($promotedItem in $smPromotedItems) {
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID `
                        -SemanticModelId $promotedItem.Id `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -Environment Public `
                        -LogOutput "ADO"
                }

                # Run tests for functionality and data accuracy in UAT workspace
                foreach ($promotedItem in $smPromotedItems) {
                    $testResults += Invoke-DQVTesting -WorkspaceName "${env:UAT_WORKSPACE_NAME}" `
                        -Credential $credential `
                        -TenantId $tenantId `
                        -DatasetId $promotedItem.Id `
                        -LogOutput "Table"
                }

                # Add additional properties to the array of objects
                $i = 0

                $testResults | ForEach-Object {
                    Add-Member -InputObject $_ -Name "BranchName" -Value $branchName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RepositoryName" -Value $repoName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "ProjectName" -Value $projectName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "UserName" -Value $userName -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunID" -Value $runGuid -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "Order" -Value $i -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "RunDateTime" -Value $dateTimeofRun -MemberType NoteProperty
                    Add-Member -InputObject $_ -Name "InvokeDQTestingVersion" -Value $idqVersion -MemberType NoteProperty
                    $i++
                }

                $testResults | Select-Object * | Export-Csv -Path ".\$fileName"

                $getAbsPath = (Resolve-Path ".\$fileName").Path

                Write-Host "##[debug] Test Results saved locally to $($getAbsPath)."

                # Output test results
                $testResults | ForEach-Object {
                    $prefix = "##[debug]"
                    switch ($_.LogType) {
                        'Warning' { $prefix = "##vso[task.logissue type=warning]" }
                        'Error' { $prefix = "##vso[task.logissue type=error]" }
                        'Failure' { $prefix = "##vso[task.complete result=Failed;]" }
                        'Success' { $prefix = "##vso[task.complete result=Succeeded;]" }
                    }
                    Write-Host "$($prefix)$($_.Message)"
                }

            } catch {
                Write-Error "Authentication or processing failed: $_"
                throw
            }
        env:
          Clientsecret: $(Clientsecret)
          clinetid: $(clinetid)
          tenantid: $(tenantid)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
______________________________________________________________________________--trigger:
  branches:
    include:
      - develop

variables:
  - group: powerbi  # Contains Clientsecret, clinetid, tenantid

parameters:
  - name: DEV_WORKSPACE_NAME
    type: string
    default: 'Your_Dev_Workspace_Name'
  - name: UAT_WORKSPACE_NAME
    type: string
    default: 'Your_UAT_Workspace_Name'

pool:
  vmImage: 'windows-latest'

steps:
- checkout: self
  fetchDepth: 0
  displayName: 'Checkout Repository'

- task: PowerShell@2
  displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
  inputs:
    targetType: 'inline'
    script: |
      try {
          # ----------- Import PowerShell Modules ----------- #
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP.psm1" -Force
          Import-Module Az.Accounts -Force
          Import-Module MicrosoftPowerBIMgmt -Force

          # ----------- Setup Credentials ----------- #
          if (-not $env:clinetid -or -not $env:Clientsecret -or -not $env:tenantid) {
              Write-Error "Missing one or more required environment variables: clinetid, Clientsecret, tenantid"
              throw
          }

          $tenantId = $env:tenantid.Trim()
          $clientId = $env:clinetid.Trim()
          $clientSecret = $env:Clientsecret.Trim()

          # Optional debugging checks (avoid printing sensitive data)
          if ($tenantId) {
              Write-Host "Tenant ID is set."
          } else {
              Write-Error "Tenant ID is not set."
              throw
          }

          if ($clientId) {
              Write-Host "Client ID is set."
          } else {
              Write-Error "Client ID is not set."
              throw
          }

          if ($clientSecret) {
              Write-Host "Client Secret is set."
          } else {
              Write-Error "Client Secret is not set."
              throw
          }

          # Convert client secret to secure string
          $secureSecret = ConvertTo-SecureString $clientSecret -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential ($clientId, $secureSecret)

          # Check if service principal or username/password
          $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
          $isServicePrincipal = $false

          if ($credential.UserName -match $guidRegex) {
            $isServicePrincipal = $true
          }

          # ----------- Login to Azure and Fabric ----------- #
          $plainTextPwd = [Runtime.InteropServices.Marshal]::PtrToStringAuto(
            [Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
          )

          # Set Fabric Connection
          if ($isServicePrincipal) {
            Set-FabricAuthToken -servicePrincipalId $credential.UserName `
              -servicePrincipalSecret $plainTextPwd `
              -tenantId $tenantId -reset
          } else {
            Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
          }

          # ----------- Connect to Power BI ----------- #
          if ($isServicePrincipal) {
            Connect-PowerBIServiceAccount -ServicePrincipal `
              -Credential $credential `
              -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
          } else {
            Connect-PowerBIServiceAccount -Credential $credential `
              -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
          }

          Write-Host "Authentication successful."

          # ----------- Process Changes ----------- #
          Write-Host "Processing changes..."

          # Get list of files changed in the current commit
          $changedFiles = @(git diff-tree --no-commit-id --name-only -r $env:BUILD_SOURCEVERSION)

          Write-Host "##[debug]Changed files: $($changedFiles)"

          # Identify Semantic Model changes
          $pbipDSChanges = $changedFiles | Where-Object { $_ -like '*.pbism' }

          # Identify Report changes
          $pbipRPTChanges = $changedFiles | Where-Object { $_ -like '*.pbir' }

          $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
          $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

          # Output detected changes for debugging
          Write-Host "##[debug]Detected Semantic Model Changes: $($pbipDSChanges)"
          Write-Host "##[debug]Detected Report Changes: $($pbipRPTChanges)"

          # Detect if no changes
          if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
              Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
              exit 0
          }

          # ----------- Get Workspace IDs ----------- #
          $devWorkspaceName = "$env:DEV_WORKSPACE_NAME".Trim()
          $uatWorkspaceName = "$env:UAT_WORKSPACE_NAME".Trim()

          $devWorkspaceObj = Get-FabricWorkspace -workspaceName $devWorkspaceName
          $uatWorkspaceObj = Get-FabricWorkspace -workspaceName $uatWorkspaceName

          if (-not $devWorkspaceObj) {
              Write-Error "Dev workspace '$devWorkspaceName' not found."
              throw
          }

          if (-not $uatWorkspaceObj) {
              Write-Error "UAT workspace '$uatWorkspaceName' not found."
              throw
          }

          $devWorkspaceID = $devWorkspaceObj.WorkspaceId
          $uatWorkspaceID = $uatWorkspaceObj.WorkspaceId

          # ----------- Promote Changes ----------- #
          # Prepare paths to promote
          $smPathsToPromote = @()
          foreach ($change in $pbipDSChanges) {
              $smPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
          }

          $rptPathsToPromote = @()
          foreach ($change in $pbipRPTChanges) {
              $rptPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
          }

          # Import Semantic Models
          foreach ($promotePath in $smPathsToPromote) {
              try {
                  Write-Host "Promoting semantic model at $promotePath to UAT workspace $uatWorkspaceName"
                  $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
              } catch {
                  Write-Error "Failed to promote semantic model at $promotePath: $_"
                  throw
              }
          }

          # Import Reports
          foreach ($promotePath in $rptPathsToPromote) {
              try {
                  Write-Host "Promoting report at $promotePath to UAT workspace $uatWorkspaceName"
                  $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
              } catch {
                  Write-Error "Failed to promote report at $promotePath: $_"
                  throw
              }
          }

          Write-Host "Promotion of changes to UAT workspace completed successfully."

          # ----------- DQV Testing ----------- #
          Write-Host "Starting Data Quality Validation (DQV) testing..."

          # Assume you have a DQV script or function to execute
          # Replace the following with your actual DQV testing commands

          try {
              # Example DQV Testing Command
              # Replace with your actual DQV testing logic
              Invoke-DQVTest -workspaceId $uatWorkspaceID -Verbose -Debug
              Write-Host "DQV testing completed successfully."
          } catch {
              Write-Error "DQV testing failed: $_"
              throw
          }

          # ----------- Validate Data Refresh ----------- #
          Write-Host "Validating data refresh..."

          try {
              # Example Data Refresh Command
              # Replace with your actual data refresh logic
              Invoke-SemanticModelRefresh -workspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
              Write-Host "Data refresh validated successfully."
          } catch {
              Write-Error "Data refresh validation failed: $_"
              throw
          }

          Write-Host "All steps completed successfully."

      } catch {
          Write-Error "An error occurred: $_"
          throw
      }
  env:
    DEV_WORKSPACE_NAME: ${{ parameters.DEV_WORKSPACE_NAME }}
    UAT_WORKSPACE_NAME: ${{ parameters.UAT_WORKSPACE_NAME }}

--------------------------------------------------------------------------------------

- task: PowerShell@2
  displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
  inputs:
    pwsh: true
    targetType: 'inline'
    script: |
      try {
          # ----------- Import PowerShell Modules ----------- #
          Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
          Import-Module Az.Accounts -Force
          Import-Module MicrosoftPowerBIMgmt -Force

          # ----------- Setup Credentials ----------- #
          $secret = ${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
          $credential = [System.Management.Automation.PSCredential]::new(${env:CLIENT_ID}, $secret)

          # Check if service principal or username/password
          $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
          $isServicePrincipal = $false

          if ($credential.UserName -match $guidRegex) {
            $isServicePrincipal = $true
          }

          # ----------- Login to Azure and Fabric ----------- #
          $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
          $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

          # Set Fabric Connection
          if ($isServicePrincipal) {
            Set-FabricAuthToken -servicePrincipalId $credential.UserName `
              -servicePrincipalSecret $plainTextPwd `
              -tenantId ${env:TENANT_ID} -reset
          } else {
            Set-FabricAuthToken -credential $credential -tenantId ${env:TENANT_ID} -reset
          }

          # Set AzCopy Connection
          $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
          $oneLakeUri = New-Object System.Uri("${env:ONELAKE_ENDPOINT}")
          $oneLakeDomain = $oneLakeUri.Host

          $loginResult = azcopy login --service-principal `
            --application-id $credential.UserName `
            --tenant-id "${env:TENANT_ID}" `
            --trusted-microsoft-suffixes="${oneLakeDomain}" `
            --output-type json | ConvertFrom-Json

          # Check if login was successful
          $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

          if (!$checkResult) {
            Write-Host "##[error] Failed to login to azcopy"
            throw "AzCopy login failed."
          }

          Write-Host "Authentication successful."

          # ----------- Connect to Power BI ----------- #
          if ($isServicePrincipal) {
            Connect-PowerBIServiceAccount -ServicePrincipal `
              -Credential $credential `
              -TenantId ${env:TENANT_ID} -ErrorAction Stop -Verbose -Debug
          } else {
            Connect-PowerBIServiceAccount -Credential $credential `
              -TenantId ${env:TENANT_ID} -ErrorAction Stop -Verbose -Debug
          }

          Write-Host "Connected to Power BI successfully."

          # ----------- Process Changes ----------- #
          Write-Host "Processing changes..."

--------------------------------------------------------------------------------

TEMP:



parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: ONELAKE_ENDPOINT
    displayName: "OneLake Endpoint"
    type: string
    default: 'https://onelakeendpoint.fabric.microsoft.com'  # Replace with your actual OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: ONELAKE_ENDPOINT
    value: '${{ parameters.ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Uninstall AzureRM Modules ----------- #
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = ${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new(${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # Set AzCopy Connection
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("${env:ONELAKE_ENDPOINT}")
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="${oneLakeDomain}" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipDSChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRPTChanges)"

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get Dev and UAT workspace IDs
                $devWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:DEV_WORKSPACE_NAME}"
                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:UAT_WORKSPACE_NAME}"

                if (-not $devWorkspaceObj) {
                    Write-Error "Dev workspace '${env:DEV_WORKSPACE_NAME}' not found."
                    throw
                }

                if (-not $uatWorkspaceObj) {
                    Write-Error "UAT workspace '${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $devWorkspaceID = $devWorkspaceObj.Id
                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Prepare paths to promote
                $smPathsToPromote = @()
                foreach ($change in $pbipDSChanges) {
                    $smPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Semantic Models
                foreach ($promotePath in $smPathsToPromote) {
                    try {
                        Write-Host "Promoting semantic model at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath: $_"
                        throw
                    }
                }

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Prepare paths to promote
                $rptPathsToPromote = @()
                foreach ($change in $pbipRPTChanges) {
                    $rptPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Reports
                foreach ($promotePath in $rptPathsToPromote) {
                    try {
                        Write-Host "Promoting report at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote report at $promotePath: $_"
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $uatWorkspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          ONELAKE_ENDPOINT: $(ONELAKE_ENDPOINT)
------------------------------------------------------------------------------------------------------

one lake system varibale:

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Uninstall AzureRM Modules ----------- #
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = ${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new(${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = ${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # Set AzCopy Connection
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("${env:ONELAKE_ENDPOINT}")
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="${oneLakeDomain}" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipDSChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRPTChanges)"

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get Dev and UAT workspace IDs
                $devWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:DEV_WORKSPACE_NAME}"
                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "${env:UAT_WORKSPACE_NAME}"

                if (-not $devWorkspaceObj) {
                    Write-Error "Dev workspace '${env:DEV_WORKSPACE_NAME}' not found."
                    throw
                }

                if (-not $uatWorkspaceObj) {
                    Write-Error "UAT workspace '${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $devWorkspaceID = $devWorkspaceObj.Id
                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Prepare paths to promote
                $smPathsToPromote = @()
                foreach ($change in $pbipDSChanges) {
                    $smPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Semantic Models
                foreach ($promotePath in $smPathsToPromote) {
                    try {
                        Write-Host "Promoting semantic model at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath: $_"
                        throw
                    }
                }

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Prepare paths to promote
                $rptPathsToPromote = @()
                foreach ($change in $pbipRPTChanges) {
                    $rptPathsToPromote += (Join-Path -Path $env:BUILD_SOURCESDIRECTORY -ChildPath $change)
                }

                # Import Reports
                foreach ($promotePath in $rptPathsToPromote) {
                    try {
                        Write-Host "Promoting report at $promotePath to UAT workspace ${env:UAT_WORKSPACE_NAME}"
                        $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $promotePath -Verbose -Debug
                    } catch {
                        Write-Error "Failed to promote report at $promotePath: $_"
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $uatWorkspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
---------------------------------------------------------


2 lake points:


parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual Dev OneLake endpoint

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual UAT OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # ----------- Uninstall AzureRM Modules ----------- #
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # ----------- Install Required PowerShell Modules ----------- #
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = $${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = $${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $$false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $$true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset
                }

                # Set AzCopy Connection based on the target OneLake endpoint
                # We need to determine which endpoint to use based on the workspace we're promoting to
                $targetWorkspaceName = "$${env:UAT_WORKSPACE_NAME}".Trim()
                $targetOneLakeEndpoint = "$${env:UAT_ONELAKE_ENDPOINT}".Trim()

                $${env:AZCOPY_SPA_CLIENT_SECRET} = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("$${targetOneLakeEndpoint}")
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="$${oneLakeDomain}" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $$_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipDSChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRPTChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipDSChanges = $pbipDSChanges | Sort-Object -Unique
                $pbipRPTChanges = $pbipRPTChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $$($pbipDSChanges)"
                Write-Host "##[debug]Detected Report Changes: $$($pbipRPTChanges)"

                # Detect if no changes
                if ($pbipDSChanges.Count -eq 0 -and $pbipRPTChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $uatWorkspaceObj = Get-FabricWorkspace -workspaceName "$${env:UAT_WORKSPACE_NAME}"

                if (-not $uatWorkspaceObj) {
                    Write-Error "UAT workspace '$${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $uatWorkspaceID = $uatWorkspaceObj.Id

                # ----------- Promote Semantic Models to UAT Workspace ----------- #
                # Prepare paths to promote
                $smPathsToPromote = @()
                foreach ($change in $pbipDSChanges) {
                    $smPathsToPromote += (Join-Path -Path $${env:BUILD_SOURCESDIRECTORY} -ChildPath $change)
                }

                # Import Semantic Models
                foreach ($promotePath in $smPathsToPromote) {
                    try {
                        Write-Host "Promoting semantic model at $$promotePath to UAT workspace $${env:UAT_WORKSPACE_NAME}"
                        $smPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $$promotePath -Verbose -Debug
                        Write-Host "Semantic model imported successfully."
                    } catch {
                        Write-Error "Failed to promote semantic model at $$promotePath: $$_"
                        throw
                    }
                }

                # ----------- Promote Reports to UAT Workspace ----------- #
                # Prepare paths to promote
                $rptPathsToPromote = @()
                foreach ($change in $pbipRPTChanges) {
                    $rptPathsToPromote += (Join-Path -Path $${env:BUILD_SOURCESDIRECTORY} -ChildPath $change)
                }

                # Import Reports
                foreach ($promotePath in $rptPathsToPromote) {
                    try {
                        Write-Host "Promoting report at $$promotePath to UAT workspace $${env:UAT_WORKSPACE_NAME}"
                        $rptPromotedItem = Import-FabricItem -workspaceId $uatWorkspaceID -path $$promotePath -Verbose -Debug
                        Write-Host "Report imported successfully."
                    } catch {
                        Write-Error "Failed to promote report at $$promotePath: $$_"
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $uatWorkspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $$_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $uatWorkspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $$_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $$_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)
--------------------------------------------------------------------
reference code imported logic:

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual Dev OneLake endpoint

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual UAT OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # Uninstall AzureRM Modules
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # Install Required PowerShell Modules
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $$_ -OutFile ".\.nuget\custom_modules\$$(Split-Path $$_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = $${env:CLIENT_SECRET} | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($${env:CLIENT_ID}, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = $${env:TENANT_ID}.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($$tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$$($$tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($$credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$$($$credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $$guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $$isServicePrincipal = $$false

                if ($$credential.UserName -match $$guidRegex) {
                  $$isServicePrincipal = $$true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $$secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($$credential.Password)
                $$plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($$secureStringPtr)

                # Set Fabric Connection
                if ($$isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $$credential.UserName `
                    -servicePrincipalSecret $$plainTextPwd `
                    -tenantId $$tenantId -reset
                } else {
                  Set-FabricAuthToken -credential $$credential -tenantId $$tenantId -reset
                }

                # Set AzCopy Connection based on the target OneLake endpoint
                $${env:AZCOPY_SPA_CLIENT_SECRET} = $$plainTextPwd
                $$oneLakeUri = New-Object System.Uri("$${env:UAT_ONELAKE_ENDPOINT}".Trim())
                $$oneLakeDomain = $$oneLakeUri.Host

                $$loginResult = azcopy login --service-principal `
                  --application-id $$credential.UserName `
                  --tenant-id $$tenantId `
                  --trusted-microsoft-suffixes="$$oneLakeDomain" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $$checkResult = $$loginResult | Where-Object { $$_.$MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$$checkResult) {
                  Write-Host "##[error] Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($$isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $$credential `
                    -TenantId $$tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $$credential `
                    -TenantId $$tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $$pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $$pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $$pbipSMChanges = $$pbipSMChanges | Sort-Object -Unique
                $$pbipRptChanges = $$pbipRptChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $$($$pbipSMChanges)"
                Write-Host "##[debug]Detected Report Changes: $$($$pbipRptChanges)"

                # Detect if no changes
                if ($$pbipSMChanges.Count -eq 0 -and $$pbipRptChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $$workspaceObj = Get-FabricWorkspace -workspaceName "$${env:UAT_WORKSPACE_NAME}"

                if (-not $$workspaceObj) {
                    Write-Error "UAT workspace '$${env:UAT_WORKSPACE_NAME}' not found."
                    throw
                }

                $$workspaceID = $$workspaceObj.Id

                # ----------- Handle Semantic Models For Promotion ----------- #
                # Identify Semantic Models changed
                $$smPathsToPromote = @()
                $$filter = "*.pbism"

                foreach ($$change in $$pbipSMChanges) {
                    $$parentFolder = Split-Path $$change -Parent
                    while ($$null -ne $$parentFolder -and !(-Test-Path (Join-Path $$parentFolder $$filter))) {
                        $$parentFolder = Split-Path $$parentFolder -Parent
                    }
                    $$smPathsToPromote += $$parentFolder
                }

                # Remove duplicates
                $$smPathsToPromote = @([System.Collections.Generic.HashSet[string]]$$smPathsToPromote)

                # Setup promoted items array
                $$smPromotedItems = @()

                # Promote semantic models to UAT workspace
                foreach ($$promotePath in $$smPathsToPromote) {
                    Write-Host "##[debug]Promoting semantic model at $$($$promotePath) to workspace $${env:UAT_WORKSPACE_NAME}"
                    $$smPromotedItems += Import-FabricItem -workspaceId $$workspaceID -path $$promotePath
                }

                # Retrieve all items in workspace
                $$items = Invoke-FabricRestMethod -Method GET -Url "workspaces/$$workspaceID/items"

                # ----------- Handle Reports For Promotion ----------- #
                # Identify Reports changed
                $$rptPathsToPromote = @()
                $$filter = "*.pbir"

                foreach ($$change in $$pbipRptChanges) {
                    $$parentFolder = Split-Path $$change -Parent
                    while ($$null -ne $$parentFolder -and !(-Test-Path (Join-Path $$parentFolder $$filter))) {
                        $$parentFolder = Split-Path $$parentFolder -Parent
                    }
                    $$rptPathsToPromote += $$parentFolder
                }

                # Remove duplicates
                $$rptPathsToPromote = @([System.Collections.Generic.HashSet[string]]$$rptPathsToPromote)

                # Setup promoted items array
                $$rptPromotedItems = @()

                $$semanticModelName = $$null

                Write-Host "##[debug] rptPathsToPromote: $$($$rptPathsToPromote)"

                # Promote reports to UAT workspace
                foreach ($$promotePath in $$rptPathsToPromote) {
                    # Get report definition
                    $$def = Get-ChildItem -Path $$promotePath -Recurse -Include "definition.pbir"
                    $$semanticModelPath = (Get-Content $$def.FullName | ConvertFrom-Json).datasetReference.byPath

                    Write-Host "##[debug] SemanticModelPath: $$($$semanticModelPath)"

                    # If byPath was null, we'll assume byConnection is set and skip
                    if ($$semanticModelPath -ne $$null) {
                        # Semantic Model path is relative to the report path, Join-Path can handle relative paths
                        $$pathToCheck = Join-Path $$promotePath $$semanticModelPath.path
                        $$metadataSM = Get-ChildItem -Path $$pathToCheck -Recurse -Include "item.metadata.json", ".platform" |
                                      Where-Object { (Split-Path -Path $$_.FullName).EndsWith(".Dataset") -or (Split-Path -Path $$_.FullName).EndsWith(".SemanticModel") }

                        if ($$metadataSM -ne $$null) {
                            $$content = Get-Content $$metadataSM.FullName | ConvertFrom-Json

                            # Handle item.metadata.json
                            if ($$metadataSM.Name -eq "item.metadata.json") {
                                # Prior to March-2024 release
                                $$semanticModelName = $$content.displayName
                                Write-Host "##[debug] SemanticModelName: $$($$semanticModelName)"
                            } else {
                                $$semanticModelName = $$content.metadata.displayName
                                Write-Host "##[debug] SemanticModelName: $$($$semanticModelName)"
                            }
                        } else {
                            Write-Host "##[vso[task.logissue type=error]Semantic Model definition not found in workspace."
                        }
                    }

                    # Get the semantic model id from items in the workspace
                    $$semanticModel = $$items | Where-Object { $$_.type -eq "SemanticModel" -and $$_.displayName -eq $$semanticModelName }

                    Write-Host "##[debug] semanticModel: $$($$semanticModel)"

                    if (!$$semanticModel) {
                        Write-Host "##[vso[task.logissue type=error]Semantic Model not found in workspace."
                    } else {
                        # Import report with appropriate semantic model id
                        Write-Host "##[debug] Promoting report at $$($$promotePath) to workspace $${env:UAT_WORKSPACE_NAME}"
                        $$promotedItem = Import-FabricItem -workspaceId $$workspaceID -path $$promotePath -itemProperties @{ semanticmodelId = "$$($$semanticModel.id)" }
                        $$rptPromotedItems += $$promotedItem
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $$workspaceID -Credential $$credential -TenantId $$tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $$_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $$workspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $$_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $$_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)

--------------------------------------------------------------------------

new gpt:

parameters:
  - name: DEV_WORKSPACE_NAME
    displayName: "Development Workspace Name"
    type: string
    default: 'YourDevWorkspaceName'  # Replace with your actual Dev workspace name

  - name: UAT_WORKSPACE_NAME
    displayName: "UAT Workspace Name"
    type: string
    default: 'YourUATWorkspaceName'  # Replace with your actual UAT workspace name

  - name: DEV_ONELAKE_ENDPOINT
    displayName: "Dev OneLake Endpoint"
    type: string
    default: 'https://dev-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual Dev OneLake endpoint

  - name: UAT_ONELAKE_ENDPOINT
    displayName: "UAT OneLake Endpoint"
    type: string
    default: 'https://uat-onelakeendpoint.fabric.microsoft.com'  # Replace with your actual UAT OneLake endpoint

trigger:
  branches:
    include:
      - develop  # Update to the branch you want to trigger on

pool:
  vmImage: 'windows-latest'

variables:
  - group: powerbi  # Contains CLIENT_ID, CLIENT_SECRET, TENANT_ID
  - name: DEV_WORKSPACE_NAME
    value: '${{ parameters.DEV_WORKSPACE_NAME }}'
  - name: UAT_WORKSPACE_NAME
    value: '${{ parameters.UAT_WORKSPACE_NAME }}'
  - name: DEV_ONELAKE_ENDPOINT
    value: '${{ parameters.DEV_ONELAKE_ENDPOINT }}'
  - name: UAT_ONELAKE_ENDPOINT
    value: '${{ parameters.UAT_ONELAKE_ENDPOINT }}'

jobs:
  - job: Job1
    displayName: "Automated Deployment and Testing Job"
    steps:
      - checkout: self
        fetchDepth: 0
        displayName: 'Checkout Repository'

      # Step 1: Install Dependencies and Uninstall AzureRM Modules
      - task: PowerShell@2
        displayName: 'Install Dependencies and Uninstall AzureRM Modules'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            # Uninstall AzureRM Modules
            Get-Module -ListAvailable -Name AzureRM* | Uninstall-Module -Force -AllVersions -ErrorAction SilentlyContinue
            Write-Host "AzureRM modules uninstalled."

            # Install Required PowerShell Modules
            if (!(Get-Module -ListAvailable -Name "Az.Accounts")) {
              Install-Module -Name Az.Accounts -Scope CurrentUser -AllowClobber -Force
            }
            Install-Module -Name MicrosoftPowerBIMgmt -Scope CurrentUser -AllowClobber -Force
            Install-Module -Name Invoke-DQVTesting -Scope CurrentUser -AllowClobber -Force -AllowPrerelease
            Install-Module -Name Invoke-SemanticModelRefresh -Scope CurrentUser -AllowClobber -Force

            # Create a custom modules directory
            if (-not (Test-Path -Path ".\.nuget\custom_modules")) {
              New-Item -Path ".\.nuget\custom_modules" -ItemType Directory -Force
            }

            # Download FabricPS-PBIP module files
            @(
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psm1",
              "https://raw.githubusercontent.com/microsoft/Analysis-Services/master/pbidevmode/fabricps-pbip/FabricPS-PBIP.psd1"
            ) | ForEach-Object {
              Invoke-WebRequest -Uri $_ -OutFile ".\.nuget\custom_modules\$(Split-Path $_ -Leaf)"
            }

      # Step 2: Deploy Changes, Conduct Testing, and Validate Data Refresh
      - task: PowerShell@2
        displayName: 'Deploy Changes, Conduct Testing, and Validate Data Refresh'
        inputs:
          pwsh: true
          targetType: inline
          script: |
            try {
                # ----------- Import PowerShell Modules ----------- #
                Import-Module ".\.nuget\custom_modules\FabricPS-PBIP" -Force
                Import-Module Az.Accounts -Force
                Import-Module MicrosoftPowerBIMgmt -Force

                # ----------- Setup Credentials ----------- #
                $secret = $env:CLIENT_SECRET | ConvertTo-SecureString -AsPlainText -Force
                $credential = [System.Management.Automation.PSCredential]::new($env:CLIENT_ID, $secret)

                # Clean any potential whitespace from tenant ID
                $tenantId = $env:TENANT_ID.Trim()

                # Output partial values for debugging (do not expose sensitive information)
                if ($tenantId.Length -ge 4) {
                    Write-Host "Using sanitized tenant ID (partial): '$($tenantId.Substring(0, 4))...'"
                } else {
                    Write-Host "Tenant ID appears to be empty or too short."
                }

                if ($credential.UserName.Length -ge 4) {
                    Write-Host "Using client ID (partial): '$($credential.UserName.Substring(0, 4))...'"
                } else {
                    Write-Host "Client ID appears to be empty or too short."
                }

                # Check if service principal or username/password
                $guidRegex = '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
                $isServicePrincipal = $false

                if ($credential.UserName -match $guidRegex) {
                  $isServicePrincipal = $true
                }

                # ----------- Login to Azure and Fabric ----------- #
                $secureStringPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($credential.Password)
                $plainTextPwd = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($secureStringPtr)

                # Set Fabric Connection
                Write-Host "Authenticating to Fabric API..."
                if ($isServicePrincipal) {
                  Set-FabricAuthToken -servicePrincipalId $credential.UserName `
                    -servicePrincipalSecret $plainTextPwd `
                    -tenantId $tenantId -reset -Verbose -Debug
                } else {
                  Set-FabricAuthToken -credential $credential -tenantId $tenantId -reset -Verbose -Debug
                }

                # Verify that the token is set
                $authToken = Get-FabricAuthToken
                if (-not $authToken) {
                  Write-Error "Failed to obtain Fabric authentication token."
                  throw "Fabric authentication failed."
                } else {
                  Write-Host "Fabric authentication token obtained successfully."
                }

                # Set AzCopy Connection based on the target OneLake endpoint
                $env:AZCOPY_SPA_CLIENT_SECRET = $plainTextPwd
                $oneLakeUri = New-Object System.Uri("$($env:UAT_ONELAKE_ENDPOINT)".Trim())
                $oneLakeDomain = $oneLakeUri.Host

                $loginResult = azcopy login --service-principal `
                  --application-id $credential.UserName `
                  --tenant-id $tenantId `
                  --trusted-microsoft-suffixes="$oneLakeDomain" `
                  --output-type json | ConvertFrom-Json

                # Check if login was successful
                $checkResult = $loginResult | Where-Object { $_.MessageContent -eq "INFO: SPN Auth via secret succeeded." }

                if (!$checkResult) {
                  Write-Error "Failed to login to azcopy"
                  throw "AzCopy login failed."
                }

                Write-Host "Authentication successful."

                # ----------- Connect to Power BI ----------- #
                if ($isServicePrincipal) {
                  Connect-PowerBIServiceAccount -ServicePrincipal `
                    -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                } else {
                  Connect-PowerBIServiceAccount -Credential $credential `
                    -TenantId $tenantId -ErrorAction Stop -Verbose -Debug
                }

                Write-Host "Connected to Power BI successfully."

                # ----------- Process Changes ----------- #
                Write-Host "Processing changes..."

                # Identify changes for promotion
                $pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
                $pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
                $pbipSMChanges = $pbipSMChanges | Sort-Object -Unique
                $pbipRptChanges = $pbipRptChanges | Sort-Object -Unique

                # Output detected changes for debugging
                Write-Host "##[debug]Detected Semantic Model Changes: $($pbipSMChanges)"
                Write-Host "##[debug]Detected Report Changes: $($pbipRptChanges)"

                # Detect if no changes
                if ($pbipSMChanges.Count -eq 0 -and $pbipRptChanges.Count -eq 0) {
                    Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
                    exit 0
                }

                # Get UAT workspace ID
                $workspaceObj = Get-FabricWorkspace -workspaceName "$($env:UAT_WORKSPACE_NAME)"

                if (-not $workspaceObj) {
                    Write-Error "UAT workspace '$($env:UAT_WORKSPACE_NAME)' not found."
                    throw
                }

                $workspaceID = $workspaceObj.Id

                # ----------- Handle Semantic Models For Promotion ----------- #
                # Identify Semantic Models changed
                $smPathsToPromote = @()
                $filter = "*.pbism"

                foreach ($change in $pbipSMChanges) {
                    $parentFolder = Split-Path $change -Parent
                    while ($null -ne $parentFolder -and !(-Test-Path (Join-Path $parentFolder $filter))) {
                        $parentFolder = Split-Path $parentFolder -Parent
                    }
                    $smPathsToPromote += $parentFolder
                }

                # Remove duplicates
                $smPathsToPromote = $smPathsToPromote | Select-Object -Unique

                # Setup promoted items array
                $smPromotedItems = @()

                # Promote semantic models to UAT workspace
                foreach ($promotePath in $smPathsToPromote) {
                    Write-Host "Promoting semantic model at $promotePath to workspace $($env:UAT_WORKSPACE_NAME)"
                    try {
                        $smPromotedItem = Import-FabricItem -workspaceId $workspaceID -path $promotePath -Verbose -Debug
                        $smPromotedItems += $smPromotedItem
                        Write-Host "Semantic model imported successfully."
                    } catch {
                        Write-Error "Failed to promote semantic model at $promotePath."
                        Write-Error "Error Details: $_"
                        if ($_.Exception.Response) {
                            $responseContent = $_.Exception.Response.Content
                            Write-Error "API Response: $responseContent"
                        }
                        throw
                    }
                }

                Write-Host "Promotion of changes to UAT workspace completed successfully."

                # ----------- DQV Testing ----------- #
                Write-Host "Starting Data Quality Validation (DQV) testing..."

                try {
                    # Replace with your actual DQV testing logic
                    Invoke-DQVTesting -WorkspaceId $workspaceID -Credential $credential -TenantId $tenantId -Verbose -Debug
                    Write-Host "DQV testing completed successfully."
                } catch {
                    Write-Error "DQV testing failed: $_"
                    throw
                }

                # ----------- Validate Data Refresh ----------- #
                Write-Host "Validating data refresh..."

                try {
                    # Replace with your actual data refresh validation logic
                    Invoke-SemanticModelRefresh -WorkspaceId $workspaceID -RefreshType Full -Wait -Verbose -Debug
                    Write-Host "Data refresh validated successfully."
                } catch {
                    Write-Error "Data refresh validation failed: $_"
                    throw
                }

                Write-Host "All steps completed successfully."

            } catch {
                Write-Error "An error occurred: $_"
                throw
            }
        env:
          CLIENT_SECRET: $(CLIENT_SECRET)
          CLIENT_ID: $(CLIENT_ID)
          TENANT_ID: $(TENANT_ID)
          DEV_WORKSPACE_NAME: $(DEV_WORKSPACE_NAME)
          UAT_WORKSPACE_NAME: $(UAT_WORKSPACE_NAME)
          DEV_ONELAKE_ENDPOINT: $(DEV_ONELAKE_ENDPOINT)
          UAT_ONELAKE_ENDPOINT: $(UAT_ONELAKE_ENDPOINT)


----------------------------------------------------------------------------------------

test anna
__________________________________________________________________
trigger:
  - main  # Adjust the branch as needed

pool:
  vmImage: 'windows-latest'

steps:
  # Step 1: Check for Changes in Files
  - task: PowerShell@2
    displayName: "Check for Changes in Power BI Files"
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "Starting change detection for Power BI files..."

        # Detect changes for .pbism and .pbir files
        $pbipSMChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbism')
        $pbipRptChanges = @(git diff --name-only --relative --diff-filter=d HEAD~1..HEAD '**/*.pbir')
        $pbipSMChanges = $pbipSMChanges | Sort-Object -Unique
        $pbipRptChanges = $pbipRptChanges | Sort-Object -Unique

        # Debugging output for detected changes
        Write-Host "##[debug]Detected Semantic Model Changes: $($pbipSMChanges)"
        Write-Host "##[debug]Detected Report Changes: $($pbipRptChanges)"

        # Detect if there are no changes
        if ($pbipSMChanges.Count -eq 0 -and $pbipRptChanges.Count -eq 0) {
            Write-Host "No changes detected in the Semantic Model or Report folders. Exiting..."
            exit 0
        }

  # Step 2: Validate Files if Changes are Detected
  - task: PowerShell@2
    displayName: "Validate Power BI Files"
    inputs:
      targetType: 'inline'
      script: |
        Write-Host "Starting validation of Power BI files..."

        # Correct paths for validation
        $pbirFolder = "$(System.DefaultWorkingDirectory)/Custodial Loads Monitor.Repo/StaticResources"
        $pbismFolder = "$(System.DefaultWorkingDirectory)/Custodial Loads Monitor.SemanticModel"

        # Debug: Print resolved paths
        Write-Host "Resolved .pbir folder path: $pbirFolder"
        Write-Host "Resolved .pbism folder path: $pbismFolder"

        # Validate .pbir files in StaticResources
        if ((Test-Path $pbirFolder) -eq $false) {
            Write-Error "The folder $pbirFolder does not exist. Please verify the path."
        } elseif ((Get-ChildItem -Path $pbirFolder -Filter "*.pbir" -File | Measure-Object).Count -eq 0) {
            Write-Error "No .pbir files found in the StaticResources folder."
        } else {
            Write-Host ".pbir file(s) found in the StaticResources folder."
        }

        # Validate .pbism files in SemanticModel
        if ((Test-Path $pbismFolder) -eq $false) {
            Write-Error "The folder $pbismFolder does not exist. Please verify the path."
        } elseif ((Get-ChildItem -Path $pbismFolder -Filter "*.pbism" -File | Measure-Object).Count -eq 0) {
            Write-Error "No .pbism files found in the SemanticModel folder."
        } else {
            Write-Host ".pbism file(s) found in the SemanticModel folder."
        }

  # Step 3: Publish Build Artifacts
  - task: PublishBuildArtifacts@1
    displayName: "Publish Build Artifacts"
    inputs:
      pathToPublish: '$(System.DefaultWorkingDirectory)'
      artifactName: 'PowerBIArtifacts'



---------------------------------------------------------------------------
stages:
  - stage: Deploy
    displayName: "Continuous Deployment"
    variables:
      workspace_id_dev: "c017440f-4a5b-46bd-a2c0-93ee3f04ab4d"  # Development Workspace ID
      workspace_id_uat: "a4628c7b-adda-4285-8c1f-758b19162d0b"  # UAT Workspace ID
    jobs:
      - job: DeployReports
        displayName: "Deploy Reports to Power BI Workspace"
        pool:
          vmImage: 'windows-latest'
        steps:
          # Step 1: Install Power BI Module
          - task: PowerShell@2
            displayName: "Install Power BI Module"
            inputs:
              targetType: 'inline'
              script: |
                Install-Module -Name MicrosoftPowerBIMgmt -Force -AllowClobber

          # Step 2: Connect to Power BI Service Account
          - task: PowerShell@2
            displayName: "Connect to Power BI Service Account"
            inputs:
              targetType: 'inline'
              script: |
                $credential = New-Object System.Management.Automation.PSCredential ($env:clinetid, (ConvertTo-SecureString $env:Clientsecret -AsPlainText -Force))
                Connect-PowerBIServiceAccount -ServicePrincipal -Credential $credential -TenantId $env:tenantid

          # Step 3: Deploy Reports
          - task: PowerShell@2
            displayName: "Deploy Reports"
            inputs:
              targetType: 'inline'
              script: |
                # Select the environment (e.g., dev or uat)
                $workspaceId = $env:workspace_id_dev  # Change this to workspace_id_uat for UAT
                $reportPath = "$(Pipeline.Workspace)/static resources/definition.pbir"
                Import-PowerBIReport -Path $reportPath -WorkspaceId $workspaceId

          # Step 4: Refresh Datasets
          - task: PowerShell@2
            displayName: "Refresh Power BI Dataset"
            inputs:
              targetType: 'inline'
              script: |
                # Select the environment (e.g., dev or uat)
                $datasetId = "YOUR_DATASET_ID"  # Replace this with the actual dataset ID
                Invoke-PowerBIRestMethod -Url "datasets/$datasetId/refreshes" -Method POST
